<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>keen blog</title>
  <subtitle>keen&#39;s tech blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://keen.devpools.kr/"/>
  <updated>2018-05-27T23:34:44.735Z</updated>
  <id>http://keen.devpools.kr/</id>
  
  <author>
    <name>ehrudxo@gmail.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[2018-05-22]2018년 4~5월 깃헙 트렌드 - 당신만의 프로젝트를 스스로 만들어보기</title>
    <link href="http://keen.devpools.kr/2018/05/27/2018-05-22-2018%EB%85%84-4-5%EC%9B%94-%EA%B9%83%ED%97%99-%ED%8A%B8%EB%A0%8C%EB%93%9C-%EB%8B%B9%EC%8B%A0%EB%A7%8C%EC%9D%98-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A5%BC-%EC%8A%A4%EC%8A%A4%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0/"/>
    <id>http://keen.devpools.kr/2018/05/27/2018-05-22-2018년-4-5월-깃헙-트렌드-당신만의-프로젝트를-스스로-만들어보기/</id>
    <published>2018-05-26T22:51:17.000Z</published>
    <updated>2018-05-27T23:34:44.735Z</updated>
    
    <content type="html"><![CDATA[<p>우리가 편하게 개발하고 있는 토대가 되는 여러가지 도구들, 혹은 기술들 중에 ‘이건 도대체 어떻게 만들었을까?’ 라는 의문을 가지게 될때가 종종 있다.<br>나중에 한번 알아봐야지 하고 그냥 지나칠 경우가 굉장히 많은데 세상은 나처럼 게으른 자를 위해 나보다 조금 더 부지런한 사람이 작업을 해 두었다. ‘Build your own X’ 라는 프로젝트가 오늘의 주인공이다. X 대신에 내가 만들고 싶은 무엇을 대입하면 된다라는 뜻의 이 프로젝트는 프로젝트 Readme 파일에 리차드 파인만의 명언이 적혀있다. ‘What I cannot create, I do not understand’<br>대체적으로 동감한다. (대체적이라고 쓴 것은 리처드 파인만이 천재중의 천재이기 때문에 여지를 남겨 둔 것이다.) HTML의 한 부분을 파싱할려고 해도 jQuery를 import 해서 쓰던 옛 습관들을 되돌아 보면 가끔은 내가 라이브러리 덕후인지 개발자인지를 헷갈릴 때도 있다. </p>
<h3 id="개인적으로-궁금해-했었던-프로젝트들"><a href="#개인적으로-궁금해-했었던-프로젝트들" class="headerlink" title="개인적으로 궁금해 했었던 프로젝트들"></a>개인적으로 궁금해 했었던 프로젝트들</h3><h4 id="Web-Framework"><a href="#Web-Framework" class="headerlink" title="Web Framework"></a>Web Framework</h4><p>가장 최근에 궁금해 했었던 프로젝트는 아마도 React 가 아니었나 싶다. GIS(Geographic Information System) 프로젝트를 하면서 Zero Dependency Map Framework를 만들던 추억을 되짚어 보면서 언젠가 비슷한 프레임워크를 만들어야지 했었던 다짐(?)들이 솔솔 떠오르는 주제중의 하나가 웹 프레임워크인데 Virtual DOM이 어떻게 작동할지가 가장 궁금한 영역이었다.<br>아래의 리스트들을 살펴보자.</p>
<ul>
<li><a href="https://jasonformat.com/wtf-is-jsx/" target="_blank" rel="external">JavaScript: WTF is JSX (Let’s Build a JSX Renderer)</a></li>
<li><a href="https://github.com/hexacta/didact" target="_blank" rel="external">JavaScript: A DIY guide to build your own React</a></li>
<li><a href="https://vimeo.com/album/3930691" target="_blank" rel="external">JavaScript: Reverse Engineering React</a><br>(중략)</li>
<li><a href="https://github.com/jsrebuild/build-your-own-vuejs" target="_blank" rel="external">JavaScript: Build your own Vuejs</a></li>
<li><a href="https://blog.mgechev.com/2015/03/09/build-learn-your-own-light-lightweight-angularjs/" target="_blank" rel="external">JavaScript: Build Your own Simplified AngularJS in 200 Lines of JavaScript</a></li>
<li><p><a href="https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060" target="_blank" rel="external">JavaScript: How to write your own Virtual DOM</a></p>
<p>Welcome To Facebook 의 약자라 믿으며(응?) 읽어볼 수 있는 “WTF is JSX”는 어떻게 JSX를 파싱해서 렌더링 트리를 만드는지에 대한 내용이 주로 있다. 이 글에서 가장 중요한 부부은 h() 함수. hyperscript 부분이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">nodeName, attributes, ...args</span>) </span>&#123;  </div><div class="line">      <span class="keyword">let</span> children = args.length ? [].concat(...args) : <span class="literal">null</span>;</div><div class="line">      <span class="keyword">return</span> &#123; nodeName, attributes, children &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>hypertext를 JavaScript 객체로 바꿔 주는 부분이라고 볼 수 있다.<br>이 내용은 마지막 링크인 “How to write your own Virtual DOM” 과 굉장히 자연스레 이어지기 때문에 독자들에게는 좋은 인사이트를 줄 수 있을 것 같다.<br>위의 hyperscript가 JSX 를 파싱해서 아래와 같은 형태의 DOM 트리를 만들고나면 브라우저에 DOM으로 표현을 하게 되면 이른바 우리가 알고 있는 브라우저에 렌더링 하는 형태로 드러나지게 되는 것이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">h(‘ul’, &#123; ‘class’: ‘list’ &#125;,</div><div class="line">  h(‘li’, &#123;&#125;, ‘item <span class="number">1</span>’),</div><div class="line">  h(‘li’, &#123;&#125;, ‘item <span class="number">2</span>’),</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>이후, Hanlding Changes 부분이 바로 Tree의 변화를 감지해서 바로 그려주게 되는 내용을 기술하고 있다고 보면 된다. props와 state등의 더 깊은 부분은 이 포스팅에서는 찾아볼 수 없지만, 이루어지는 메커니즘을 이해하는데에는 훌륭한 글이라 보여진다.</p>
<h4 id="물리엔진"><a href="#물리엔진" class="headerlink" title="물리엔진"></a>물리엔진</h4><p>물리 엔진(영어: physics engine) 또는 물리 연산 엔진은 강체동역학(충돌 감지 포함), 연체동역학, 유동역학과 같은 단순한 특정 물리 시스템을 최대한 시뮬레이션하려고 하는 컴퓨터 소프트웨어이다. </p>
<ul>
<li><a href="https://ko.wikipedia.org/wiki/%EB%AC%BC%EB%A6%AC_%EC%97%94%EC%A7%84" target="_blank" rel="external">참고: 위키백과</a><br>물리엔진의 존재를 처음 생각하게 된 것은 Doom 이라는 게임을 접하면서 였던 거 같다. 물론 그 당시 수준이란게 물리엔진이라는 수준 보다는 3D 엔진의 도화선이 된 것이었지만 움직이면서 오브젝트가 작동하는 방식들이 일종의 물리엔진을 가지기는 한다.<br>유명한 물리엔진은 하복(<a href="https://www.havok.com/" target="_blank" rel="external">havok</a>) 과 크로노 프로젝트(<a href="https://projectchrono.org/" target="_blank" rel="external">project chrono</a>)가 있다.<br>하복을 사용하는 게임으로는 철권 태그 토너먼트, 디아블로3, 엘더스크롤5: 스카이림, 헤일로2~4, 하프라이프2, 스타크래프트2 등의 명작 게임이 즐비하다. </li>
</ul>
<p>이 물리 엔진을 위해서 아래의 내용들을 제공하고 있다.</p>
<ul>
<li><a href="https://www.toptal.com/game/video-game-physics-part-i-an-introduction-to-rigid-body-dynamics" target="_blank" rel="external">C: Video Game Physics Tutorial</a></li>
<li><a href="http://allenchou.net/game-physics-series/" target="_blank" rel="external">C++: Game physics series by Allen Chou</a></li>
<li><a href="https://gamedevelopment.tutsplus.com/series/how-to-create-a-custom-physics-engine--gamedev-12715" target="_blank" rel="external">C++: How to Create a Custom Physics Engine</a><br>(중략)</li>
<li><a href="https://www.graphitedigital.com/blog/build-your-own-basic-physics-engine-in-javascript" target="_blank" rel="external">JavaScript: Build your own basic physics engine in JavaScript</a></li>
<li><a href="http://buildnewgames.com/gamephysics/" target="_blank" rel="external">JavaScript: How Physics Engines Work</a></li>
</ul>
<p>이 중에서  “Build your own basic physics engine in JavaScript”에는 브라우저에서 어떻게 캔버스에 물리 오브젝트를 그리고 값을 변화시기는지 간단하게 나와 있다. 이 중에서 가장 초보자들이 가장 눈여겨 봐야할 부분은 다음의 소스 코드에서 requestAnimationFrame 이 들어간 부분이다. 이 부분은 브라우저 캔버스에서 60프레임을 확보하기 위해서 사용되는 내장 브라우저 함수이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Loop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//재귀호출을 실행한다.</span></div><div class="line">    requestAnimationFrame(Loop);</div><div class="line">    <span class="comment">//실제 프레임 안에서 작동하는 내용을 기술해서 작동하도록 한다.</span></div><div class="line">    frameRender();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>requestAnimation에 대한 자세한 내용은 다음을 통해 숙지하자.<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="external">모질라 개발자 사이트 - requestAnimationFrame</a></p>
<p>“How Physics Engines Work” 글에서는 조금 더 나아가서 실제로 오브젝트에 물리식들을 조금씩 적용해 보는 예제들을 확인할 수 있다. 뉴턴의 제2법칙 -<br>물체의 운동량의 시간에 따른 변화율은 그 물체에 작용하는 힘과 (크기와 방향에 있어서) 같다. -인  F=ma 를 찾아볼 수 있다. 즉 질량 * 가속도 = 힘으로 우리가 알고 있는 내용이다.<br>실제 중력 가속도 인 0.98을 이용해서 공이 자유낙하 하는 예제를 포함하고 있다.<br><a href="http://jsfiddle.net/bkanber/vmkZR/?utm_source=website&amp;utm_medium=embed&amp;utm_campaign=vmkZR" target="_blank" rel="external">jsfiddle 예제</a><br>jsfiddle 예제를 통해서도 볼 수 있다.<br><img src="/images/2018/05/tongtong.gif" alt="통통"></p>
<p>더 관심이 있는 사람은 다른 아티클들을 가지고 더 들여다 볼수도 있다. </p>
<p>이 외에도 블럭체인, OS, Database, 검색엔진 같은 흥미로운 주제들을 생각해 볼 수 있을 것으로 보인다.</p>
<h3 id="맺으며"><a href="#맺으며" class="headerlink" title="맺으며"></a>맺으며</h3><p>조금 더 좋은 개발자가 된다는 일은 어떤 느낌일까? 개인적으로는 조금 더 깊은 본질에 가까워지는 노력을 게을리 하지 않고, 흘러가는 트렌드를 놓치지 않기 위해 노력하지만 천둥 벌거숭이 같은 남자 아이 셋을 키우는 입장에서는 언제나 시간이 부족하다. 하지만 언제나 이런 좋은 리소스들이 넘쳐나는 세상에서 배울것이 무궁무진하다는 것은 고무적인 일이다. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;우리가 편하게 개발하고 있는 토대가 되는 여러가지 도구들, 혹은 기술들 중에 ‘이건 도대체 어떻게 만들었을까?’ 라는 의문을 가지게 될때가 종종 있다.&lt;br&gt;나중에 한번 알아봐야지 하고 그냥 지나칠 경우가 굉장히 많은데 세상은 나처럼 게으른 자를
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[2018-04-27]Responsive Web을 위해 개발자가 꼭 알아야 하는 기술들</title>
    <link href="http://keen.devpools.kr/2018/04/27/2018-04-27-Responsive-Web%EC%9D%84-%EC%9C%84%ED%95%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0%EB%93%A4/"/>
    <id>http://keen.devpools.kr/2018/04/27/2018-04-27-Responsive-Web을-위해-개발자가-꼭-알아야-하는-기술들/</id>
    <published>2018-04-27T01:38:11.000Z</published>
    <updated>2018-05-02T13:07:06.452Z</updated>
    
    <content type="html"><![CDATA[<p>반응형 웹(Responsive Web) 개발은 이미 일상이 되어버린 2018년 봄에 이런 글을 쓰게될 줄은 몰랐는데, 최근에 몇가지 프로젝트를 진행을 하다가 대부분의 개발자들이 반응형 웹에 대한 개념은 있지만 어떻게 개발해야 하는지를 모른다는 사실과 직면하게 되었다.<br><img src="/images/2018/05/responsive.jpg" alt="그림1"></p>
<ul>
<li>왜 이런 일이 발생했을까?<br>친구들과 이야기들을 하면서 찾아가다보니 대부분 부트스트랩과 같은 CSS 웹 프레임워크를 쓰거나, 퍼블리셔의 영역이라고 생각하고 있다는 것을 알게 되었다. 영역에 대한 갑론을박은 나중에 하자. 이 포스팅에서는 다루지 않을 생각이다. </li>
<li>그런데, 왜 지금에서야 이 문제가 되었을까?<br>최신 개발을 진행을 하게 되면 대부분 리액트(React), 뷰(Vue), 앵귤러(Angular) 같은 웹 컴포넌트를 쓰게 된다. 그런데 개발자들이 이런 프레임워크들을 쓰게 되면서 제이쿼리(jQuery)에 대해서 반감(?)을 갖게 되었고 부트스트랩은 기본적으로 제이쿼리 기반으로 갖춰진 터라 배재하고 쓰기 시작하는데 반응형이라는 숙제 앞에서 대략난감(?)한 상황이 된 것이었다. 게다가 퍼블리셔가 회사에서 점점 사라져가는 개발 프로세스들(스케치와 제플린 콤보)이 정립되고 나니 개발자들이 반응형 웹의 영역을 떠 받게 되는 상황이 되었다. </li>
</ul>
<p>지금 포스팅은 이런 상황에 직면한 개발자들을 위해 쓰여졌다. 하지만 유용할 것이라고 생각한다. </p>
<p>아래와 같은 순서로 포스팅은 진행된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- 반응형 웹의 정의</div><div class="line">- 반응형 웹의 기술들</div><div class="line">  1. 픽셀의 정의와 viewport metatag</div><div class="line">  2. 반응형 레이아웃</div><div class="line">  2.1. 미디어 쿼리</div><div class="line">  2.2. 레이아웃 패턴과 중단점 </div><div class="line">  2.3. flexbox</div><div class="line">  3. 반응형 리소스</div><div class="line">  3.1. 이미지</div><div class="line">  3.2. 텍스트</div><div class="line">  3.3. 폰트(em,rem)</div><div class="line">  3.3. 반응형 CSS 로딩</div><div class="line">  4.개발자 도구 툴 활용</div></pre></td></tr></table></figure></p>
<h2 id="반응형-웹이란"><a href="#반응형-웹이란" class="headerlink" title="반응형 웹이란"></a>반응형 웹이란</h2><p>반응형 웹(Responsive Web)을 정의할때면 언제난 적응형 웹(Adaptive Web)에 대한 이야기가 같이 나온다.<br>모바일 환경이 시작되면서 장치도 같이 다양해 지기 시작했다. 해상도의 크기도 다르고 비율이 달라지는 일들이 벌어졌다. 그 전에는 모니터에 맞춰서 1024x768, 1280x960 등의 동일 비율의 크기에 대한 대응만 하면 되던 일들이 아예 비율도 달라지고 해상도는 굉장히 높은데, 모바일 디바이스의 경우는 픽셀의 크기자체가 모니터의 크기랑 비교가 안되게 작아지는 일들이 생겨서 페이지를 설계하는데에 고려할 사항들이 많이 늘어 났다.<br><img src="/images/2018/05/multi_device.png" alt="반응형 웹이 필요한 장비들"></p>
<p>이런 상황에 적응할 수 있도록 반응형 웹 기술과 적응형 웹 기술이 탄생했다. 적응형 웹은 기본적으로 서버사이드에서 미리 클라이언트의 정보를 받아서 클라이언트가 모바일인지 웹인지를 파악해서 리소스를 선택해서 내려주는 형태를 이야기한다. 예를 들어 모바일 폰으로 네이버에 접속할 때를 생각해보면 쉽게 이해가 될 것이다. www.naver.com을 쳤지만 모바일 브라우저로 접근하면 m.naver.com로 리다이렉트 하고 렌더링하는 리소스들도 전혀 다르다. www.naver.com 의 크기를 늘였다 줄여도 레이아웃이 전혀 변경되지 않는다.<br><img src="/images/2018/05/multi_naver.png" alt="네이버는 적응형과 반응형의 조합"><br>하지만 반응형 웹은 같은 페이지 리소스를 가지고 오지만 해당 페이지의 크기에 따라서 다르게 보이는 것을 이야기 한다. 하지만 삼성 SDS 사이트의 경우는 브라우저의 사이즈를 줄일 수록 레이아웃 자체가 바뀌는 것을 볼 수 있다.<br><img src="/images/2018/05/sds.png" alt="SDS는 반응형 홈페이다"></p>
<p>어떤 것이 더 좋은지는 웹 페이지의 지향점에 따라 다르기 때문에 무엇이 더 좋다고 할 수는 없지만, 모바일 환경에서 반응형 웹 페이지를 고려해야 하는 것은 요즘에는 너무나 당연한 것으로 이야기 되어진다. 왜 그런지 알아보도록 하자.( 심지어 m.naver.com 으로 일단 진입하고 나면 레이아웃이 바뀌는 모습도 발견할 수 있다.) </p>
<h2 id="반응형-웹-페이지를-만들기-위해-알아야할-개념들"><a href="#반응형-웹-페이지를-만들기-위해-알아야할-개념들" class="headerlink" title="반응형 웹 페이지를 만들기 위해 알아야할 개념들"></a>반응형 웹 페이지를 만들기 위해 알아야할 개념들</h2><p>그렇다면 이 반응형 웹 페이지를 만들기 위해서는 어떤 기술들을 알아야 할까요? 어떤 기술들이 있으면 반응형 웹 페이지를 만들 수 있는지, 모바일과 웹에서 같은 사용자의 경험을 가져갈 수 있는지 알아봅시다.</p>
<h3 id="1-픽셀의-정의와-viewport-metatag"><a href="#1-픽셀의-정의와-viewport-metatag" class="headerlink" title="1. 픽셀의 정의와 viewport metatag"></a>1. 픽셀의 정의와 viewport metatag</h3><h4 id="픽셀"><a href="#픽셀" class="headerlink" title="픽셀"></a>픽셀</h4><p>먼저 픽셀에 대해서 알아보자.<br>웹페이지를 제작할 때에 대부분의 사이트가 <code>width:600px</code> 같은 형태로 픽셀을 기준으로 페이지를 그리고 있다. 픽셀은 화면을 구성하는 가장 기본이 되는 단위로 보통 Picture Element 혹은 화소라고도 불린다. 이른바 15인치 모니터에 1024x768이라고 하면 모니터의 수평으로 1024개의 픽셀이 수직으로 768개의 픽셀이 배치되어 있다고 보면 된다. 즉 786432개의 픽셀로 이루어진 셈이다.<br><img src="/images/2018/05/square-2724387_640.jpg" alt="픽셀을 형상화한 이미지."></p>
<p>하지만 모바일 환경에서는 이 픽셀을 그대로 사용하지는 않는다. 왜냐하면 손 안에 들어오는 작은 디스플레이에 같은 픽셀을 기준으로 적용을 할 수 없기 때문이다. 아이폰 3GS 시절만 해도 320x480 같은 저해상도의 디스플레이였기 때문에 대부분의 페이지가 화면을 넘어가는 문제로 해상도를 그대로 사용할 수 없었다면, 현재 갤러시 S9은 1440x2960 과 같은 해상도의 화면이기 때문에 깨알 같이 보이는 어려움이 있다. </p>
<p>이 문제를 처음 깨닫고 해결하려고 덤벼든 것은 당연히 가장 먼저 스마트 폰에서 제대로 된 웹 환경을 제공한 애플이다. 당시에는 지금처럼 사이트를 모바일 사이트로 만들지 않았고 웹 페이지가 기준이었으니까 가상 viewport 개념을 도입했다. 실제로는 320px의 디스플레이를 980px의 viewport를 그린 것이다. 아래 그림을 보면 이해가 더 편할 것으로 보인다. 아래 그림은 애플 개발자 사이트에서 viewport 부분을 캡처한 화면이다. 320px 에서는 다 보이지 않는 페이지들이 980px의 viewport 안에 보이게 브라우저가 작동을 하는 것을 볼 수 있을 것이다.<br><img src="/images/2018/05/apple_viewport.png" alt="320px를 980 px로 렌더링하다."><br>출처 : 애플 개발자 사이트 - <a href="https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html" target="_blank" rel="external">Configuring the Viewport </a></p>
<p>이 때부터 대부분의 모바일 브라우저의 virtual viewport는 980px로 고정이 되었다. ( virtual viewport는 진짜 해상도가 320px,1440px,1080px등 다양한 장비들이 width는 보시다시피 같은 너비 기준으로 렌더링한다. 모바일 웹페이지의 width height 들을 작성을 할때는 참고하자. )<br>현재도 그런지 시뮬레이터에서 다음의 소스로 확인해 보자. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> w = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.clientWidth, <span class="built_in">window</span>.innerWidth || <span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> h = <span class="built_in">Math</span>.max(<span class="built_in">document</span>.documentElement.clientHeight, <span class="built_in">window</span>.innerHeight || <span class="number">0</span>);</div><div class="line">alert(w);</div></pre></td></tr></table></figure>
<p>보기와 같은 소스코드로 확인해 보면 최신의 장비도 아래와 같이 980px를 안드로이드와 iOS모두 고수하고 있음을 알 수 있다.<br><img src="/images/2018/05/980.png" alt="모두가 980픽셀"><br>즉 우리가 보는 픽셀은 실제로 장비의 픽셀 너비는 980/(실제 장비의 pixel width) 임을 알수 있다.</p>
<p>그런데, 실제로 모바일 장비의 해상도는 더 커지고 다양해 지는데, 모든 장비에서 사람들에게 편안한 크기의 이미지를 제작하고 폰트를 제공하려면 어떻게 해야 될까? ( 그에 관련된 내용도 출처를 밝힌 위의 링크에서 확인해 볼수 있다. )</p>
<h4 id="viewport-meta-tag"><a href="#viewport-meta-tag" class="headerlink" title="viewport meta tag"></a>viewport meta tag</h4><p>일단 데스크 탑 용 네이버 사이트를 980px에서 확인해 보자.<br><img src="/images/2018/05/iphone_naver.png" alt="가독성이?"><br>도저히 한눈에 들어오는 가독성은 아니다. 결국 사람이 익숙한 폰트도 12~16px의 폰트가 적당하다고 봤을때, 각각 장비별로 적정한 device-width를 정의하기 시작했고, 아이폰은 처음 시작은 320px를 device-width로 주고 meta 태그에 viewport라는 아래와 같은 옵션을 주면 장비의 가독성이 가장 좋은 viewport를 가지기 시작했다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/2018/05/viewport.png" alt="장비별로 viewport가 달라졌다."><br>최신의 아이폰들은 375px를, Pixel XL은 412px를 viewport로 가지고 있다. </p>
<p>이제 viewport 라는 개념이 헷갈리기 시작할텐데 다음과 같은 원칙으로 정의해 보자.</p>
<ul>
<li>meta tag에 viewport에 대한 별 내용이 없으면 기본적으로 980px를 기준으로 웹 페이지는 렌더링한다.</li>
<li>하지만 글자의 가독성이 떨어지므로 각 장비별로 가독성이 가장 좋은 device-width를 viewport에 셋팅할 수 있는 옵션이 있다.</li>
<li>그 옵션을 정의하고 나면 각 장비별 device-width로 페이지는 렌더링 된다.</li>
</ul>
<p>이해를 돕기 위해 가로 640px 세로 640px의 이미지를 렌더링 하는 코드를 여러 장비에서 한번 확인해 보자. 사용된 시뮬레이터는 왼쪽으로 부터 iPhone X 와 iPhone 6, 그리고 Pixel2 XL과 저해상도 안드로이드 장비다.  (저해상도 안드로이드 장비는 아이폰 3GS 시절의 320x400이 동작하는 방식을 재현하기 위해서다. )</p>
<ul>
<li><p>일반적인 이미지보기를 할 때<br>img 태그만 적용해서 확인을 해 보면 640px의 이미지가 출력이 되는데, viewport가 980px 이므로 저해상도 안드로이드 장비말고는 모두 오른쪽에 여백이 남는다. 각 이미지별로 사각무늬의 크기도 제각각이다.<br><img src="/images/2018/05/plain_pixel.png" alt="meta 태그 넣기 전의 모습"></p>
</li>
<li><p>viewport 옵션을 적용한 이미지보기를 할 때<br><img src="/images/2018/05/pixel_viewport.png" alt="meta 태그를 추가한 모습"><br>각 장비별로 이미지가 보이는 부분은 다르지만 사각무늬의 크기는 동일하게 나온다. 이것을 이용하면 어떤 장비든지 보기 좋고 동일한 UX를 만들 수 있을 것 같은 확신이 든다. </p>
</li>
</ul>
<p>viewport의 옵션을 더 알아보자.<br>먼저 페이지에 들어가서 핀치투 줌 같은 사용자의 행동을 막기 위한 옵션을 줄 수 있다. 네이버나 다음 사이트에 들어갔을때 두 손가락으로 줌인 줌아웃이 안되는 것을 볼 수 있을 것이다. viewport를 마음대로 변경하면 서비스 사업자가 원하는 데로 서비스가 제공되지 않을 때 사용한다.<br>가장 좋은 예는 지도 앱의 경우는 두손으로 확대를 하면 지도가 확대가 되어야 하는데 웹 페이지가 확대되는 걸 본적이 있을 것이다. 이런 경우를 위해서 사용이 된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>여기서 device-width이외에 추가된 부분들이 그 역할을 하는데, 최초의 scale을 기준으로 사용자가 임의로 스케일을 변경할 수 없음을 이야기 한다. scale은 각 장비의 가장 가독성이 높은 device-width의 배율로 정의하면 이해하기 편하다. 즉 0.5로 scale을 바꾸면 Pixel XL2의 경우는 824 픽셀이 나온다.(414/0.5)</p>
<p>이상의 내용을 잘 이해하면 앞으로 나올 반응형 레이아웃과 미디어쿼리등의 상황을 잘 적응할 수 있을 것으로 보인다.<br>참고로 landscape(핸드폰을 옆으로 뉘였을때)일 때도 980px가 기본 viewport width 이다. meta-tag 설정을 하면 어떻게 되는지는 각자 확인을 해보자. 안드로이드 에뮬레이터에서 데스크 탑의 localhost 를 접속하려면 10.0.2.2를 사용하는 것도 이번 포스팅을 알면서 알게된 좋은 성과다.</p>
<p>이번 포스팅을 통해서 기하급수적으로 늘어나는 모바일 디바이스에서 화면을 어떻게 적응 시키기 위한 노력들을 했는지 알아보았고 그에대한 대답으로 가상 뷰포트라는 것이 존재한다는 것과 실제 여러 디비이스에서 동일하게 폰트와 이미지 크기를 나오게 하기 위해서 viewport와 scale=1.0 옵션을 가지고 있다는 것을 알게 되었다. 이후에는 반응형 웹을 어떻게 만들 것인지에 대한 실체에 조금더 접근해 보자.</p>
<p>이어지는 포스팅에는 반응형 레이아웃에 대해서 알아보도록 하겠다. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;반응형 웹(Responsive Web) 개발은 이미 일상이 되어버린 2018년 봄에 이런 글을 쓰게될 줄은 몰랐는데, 최근에 몇가지 프로젝트를 진행을 하다가 대부분의 개발자들이 반응형 웹에 대한 개념은 있지만 어떻게 개발해야 하는지를 모른다는 사
    
    </summary>
    
    
      <category term="Front-End" scheme="http://keen.devpools.kr/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>[2018-01-08] 2018년 1월 깃헙 트렌드 - Rust와 웹 어셈블리의 혁신적인 도발</title>
    <link href="http://keen.devpools.kr/2018/01/08/2018-01-08-2018%EB%85%84-1%EC%9B%94-%EA%B9%83%ED%97%99-%ED%8A%B8%EB%A0%8C%EB%93%9C/"/>
    <id>http://keen.devpools.kr/2018/01/08/2018-01-08-2018년-1월-깃헙-트렌드/</id>
    <published>2018-01-08T08:47:43.000Z</published>
    <updated>2018-01-10T11:30:04.457Z</updated>
    
    <content type="html"><![CDATA[<p>2018년 새해가 밝았다. 올해는 어떤 포스팅을 더 할 수 있을지 고민해 보았다. 물론 언제나 나의 계획과 이룰 수 있는데에는 한계가 있다. </p>
<h3 id="올-한해-하고-싶은-포스팅"><a href="#올-한해-하고-싶은-포스팅" class="headerlink" title="올 한해 하고 싶은 포스팅"></a>올 한해 하고 싶은 포스팅</h3><ol>
<li>가방끈 짧은 개발자의 딥러닝 시리즈 </li>
<li>프론트엔드 개발자가 배워야 하는 기반 기술 총망라. ( HTTP1.0 부터 ES2018까지. 아 이건 위키가 더 좋을까.  총망라 라니.. 이런 아재 감각.)</li>
<li>머리속에 그리는 리액트 심화 가즈아~</li>
<li>깃헙 트렌드 격주 발행 ( 가능할 것인가?!! )</li>
</ol>
<h3 id="1월의-깃헙-트렌드"><a href="#1월의-깃헙-트렌드" class="headerlink" title="1월의 깃헙 트렌드"></a>1월의 깃헙 트렌드</h3><p>1월 한달간 깃헙에 올라온 프로젝트 중 많은 호응을 얻었던 프로젝트들을 정리해 보았다. 특이하게 디버깅에 관련된 프로젝트들이 많이 올라 왔다.  30 seconds of code 는 매우 유용한 자바스크립트 코드를 확인해 볼 수 있다.</p>
<ul>
<li><a href="https://github.com/x64dbg/x64dbg" target="_blank" rel="external">x64dbg</a></li>
<li><a href="https://github.com/tipsy/github-profile-summary" target="_blank" rel="external">github-profile-summary</a></li>
<li><a href="https://github.com/Chalarangelo/30-seconds-of-code" target="_blank" rel="external">30-seconds-of-code</a></li>
<li><a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="external">wechat_jump_game</a></li>
<li><a href="https://github.com/parcel-bundler/parcel" target="_blank" rel="external">parcel</a></li>
<li><a href="https://github.com/skylot/jadx" target="_blank" rel="external">jadx</a></li>
<li><a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="external">coding-interview-university</a></li>
<li><a href="https://github.com/Konloch/bytecode-viewer" target="_blank" rel="external">bytecode-viewer</a></li>
<li><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow</a></li>
<li><a href="https://github.com/google/boardgame.io" target="_blank" rel="external">boardgame.io</a></li>
</ul>
<p>이 중에서 yew라는 rust 기반의 프로젝트를 살펴보자.</p>
<h3 id="yew"><a href="#yew" class="headerlink" title="yew"></a>yew</h3><p>yew는 rust 기반의 웹 프레임 워크를 표방하고 있다. </p>
<h4 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h4><p><img src="/images/2018/01/rust_page.png" alt="rust page"><br>rust 라고 하면 기본적으로 어려운 언어. 파이어폭스의 다음버전 퀀텀의 기반. 혁신적인 속도 등의 키워드로 개발자들에게 알려져 있다. 물론 비슷한 시기에 나와서 더 성공적으로 론칭된 go의 경우는 구글의 버프를 받고 무럭 무럭 개발자 커뮤니티가 성장하고 있다. 그에 비해 rust 는 많이 외면 받아 왔는데 그 이유로는 어려운 문맥과 더불어 타게팅된 어플리케이션을 찾기가 힘들었다.  </p>
<p><img src="/images/2018/01/servo_page.png" alt="servo page"><br>그 와중에 우리가 들어 봤던 가장 좋은 소식중에 하나는 아마도 <a href="https://servo.org/" target="_blank" rel="external">servo</a> 일 것이고 그 servo가 차기 파이어 폭스 퀀텀의 핵심이 될 것이다.(아니 이미 서브 프로젝트들은 퀀텀에 장착되기 시작했다.) 그런데 퀀텀은 이미 개발자들 사이에 굉장히 화제가 되었고 속도가 많이 개선되었다는 이야기들이 오가기 시작했다. 다만 이전 플러그인들 호환 문제 때문에 파이어 폭스의 미래는 여전히 밝지 않지만 모두에게 rust === ‘고성능이였지’ 공식의 향수를 일으키기에 충분했다.</p>
<p>그러던 와중에 1월의 프로젝트중에 yew가 눈에 띄었다. 그래서 한 번 살펴 보았는데, 프론트엔트 개발자들에게는 개발에 대한 패러다임을 바꿀 수 있는 어떤 무언가가 보여서 한 번 나눠볼까 한다. </p>
<h4 id="React-like-Virtural-DOM"><a href="#React-like-Virtural-DOM" class="headerlink" title="React like Virtural DOM"></a>React like Virtural DOM</h4><p>Rust 내부에 DOM 코드를 작성하는 형식은 리액트의 Virtual DOM을 따라 했는데, 컴파일을 하고 서비스가 로딩이 된 후 사이트에 접속을 하면 react 처럼 virtual dom을 만들고 렌더링을 한다.<br>네트워크를 통해 전송되는 html은 다음과 같다.</p>
<ul>
<li>소스코드 - To Do MVC HTML 코드<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Yew • TodoMVC<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>하지만 DOM의 경우는 다음 그림처럼 렌더링이 되어 있다.<br><img src="/images/2018/01/todo_mvc_html_dom.png" alt="To Do MVC HTML DOM"></p>
<h4 id="Web-Assembly"><a href="#Web-Assembly" class="headerlink" title="Web Assembly"></a>Web Assembly</h4><p>자바 스크립트는 웹 어셈블리(혹은 Asm.js)로 작성되어서 떨어진다. Asm.js는 브라우저가 이해하기 쉬운 기계어 포맷에 가까운 자바스크립트이고, 웹 어셈블리는 이전에 블로그에서 언급한 적이 있다.<br><img src="/images/2018/01/web_assemply.png" alt="WebAssembly - hello world 어셈블리를 브라우저에 올려보자"><br>링크 : <a href="http://www.devpools.kr/2017/01/21/webassembly-binaryen-emscripten/" target="_blank" rel="external">WebAssembly - hello world 어셈블리를 브라우저에 올려보자</a><br>말 그대로 브라우저에서 돌아가는 기계어다.<br>아무래도 ???! 이게 뭐지? 하는 느낌으로 지금쯤 읽고 있는 독자들이 많으리라.<br>코드를 보고 이야기 하자.</p>
<h4 id="백타가-불여일견"><a href="#백타가-불여일견" class="headerlink" title="백타가 불여일견"></a>백타가 불여일견</h4><p>먼저 TO DO MVC 코드는 다음과 같다. 맞다 . 여러분이 아는 그 To Do MVC 말이다. <a href="http://todomvc.com/" target="_blank" rel="external">ToDoMVC</a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 중략 </span></div><div class="line"><span class="comment">// 모델을 정의한다.</span></div><div class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Model</span></span> &#123;</div><div class="line">    entries: <span class="built_in">Vec</span>&lt;Entry&gt;,</div><div class="line">    filter: Filter,</div><div class="line">    value: <span class="built_in">String</span>,</div><div class="line">    edit_value: <span class="built_in">String</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#[derive(Serialize, Deserialize)]</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entry</span></span> &#123;</div><div class="line">    description: <span class="built_in">String</span>,</div><div class="line">    completed: <span class="built_in">bool</span>,</div><div class="line">    editing: <span class="built_in">bool</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//중략 </span></div><div class="line"><span class="comment">// update 함수는 Add,Edit 등등의 명령어를 받으면 모델을 변경한다.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">update</span></span>(context: &amp;<span class="keyword">mut</span> Context, model: &amp;<span class="keyword">mut</span> Model, msg: Msg) &#123;</div><div class="line">    <span class="keyword">match</span> msg &#123;</div><div class="line">        Msg::Add =&gt; &#123;</div><div class="line">            <span class="keyword">let</span> entry = Entry &#123;</div><div class="line">                description: model.value.clone(),</div><div class="line">                completed: <span class="literal">false</span>,</div><div class="line">                editing: <span class="literal">false</span>,</div><div class="line">            &#125;;</div><div class="line">            model.entries.push(entry);</div><div class="line">            model.value = <span class="string">""</span>.to_string();</div><div class="line">        &#125;</div><div class="line">        Msg::Edit(idx) =&gt; &#123;</div><div class="line">            <span class="keyword">let</span> edit_value = model.edit_value.clone();</div><div class="line">            model.complete_edit(idx, edit_value);</div><div class="line">            model.edit_value = <span class="string">""</span>.to_string();</div><div class="line">        &#125;</div><div class="line">        Msg::Update(val) =&gt; &#123;</div><div class="line">            <span class="built_in">println!</span>(<span class="string">"Input: &#123;&#125;"</span>, val);</div><div class="line">            model.value = val;</div><div class="line">        &#125;</div><div class="line">        Msg::UpdateEdit(val) =&gt; &#123;</div><div class="line">            <span class="built_in">println!</span>(<span class="string">"Input: &#123;&#125;"</span>, val);</div><div class="line">            model.edit_value = val;</div><div class="line">        &#125;</div><div class="line">        Msg::Remove(idx) =&gt; &#123;</div><div class="line">            model.remove(idx);</div><div class="line">        &#125;</div><div class="line">        Msg::SetFilter(filter) =&gt; &#123;</div><div class="line">            model.filter = filter;</div><div class="line">        &#125;</div><div class="line">        Msg::ToggleEdit(idx) =&gt; &#123;</div><div class="line">            model.toggle_edit(idx);</div><div class="line">        &#125;</div><div class="line">        Msg::ToggleAll =&gt; &#123;</div><div class="line">            <span class="keyword">let</span> status = !model.is_all_completed();</div><div class="line">            model.toggle_all(status);</div><div class="line">        &#125;</div><div class="line">        Msg::Toggle(idx) =&gt; &#123;</div><div class="line">            model.toggle(idx);</div><div class="line">        &#125;</div><div class="line">        Msg::ClearCompleted =&gt; &#123;</div><div class="line">            model.clear_completed();</div><div class="line">        &#125;</div><div class="line">        Msg::Nope =&gt; &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    context.storage.store(KEY, Json(&amp;model));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//중략</span></div><div class="line"><span class="comment">// view 는 브라우저에 렌더링한다. 변경에 따른 바인딩과 이벤트의 바인등을 정의한다.</span></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">view</span></span>(model: &amp;Model) -&gt; Html&lt;Msg&gt; &#123;</div><div class="line">    html! &#123;</div><div class="line">        &lt;div class=<span class="string">"todomvc-wrapper"</span>,&gt;</div><div class="line">            &lt;section class=<span class="string">"todoapp"</span>,&gt;</div><div class="line">                &lt;header class=<span class="string">"header"</span>,&gt;</div><div class="line">                    &lt;h1&gt;&#123; "todos" &#125;&lt;/h1&gt;</div><div class="line">                    &#123; view_input(&amp;model) &#125;</div><div class="line">                &lt;/header&gt;</div><div class="line">                &lt;section class=<span class="string">"main"</span>,&gt;</div><div class="line">                    &lt;input class="toggle-all", type="checkbox", checked=model.is_all_completed(), onclick=|_| Msg::ToggleAll, /&gt;</div><div class="line">                    &lt;ul class=<span class="string">"todo-list"</span>,&gt;</div><div class="line">                        &#123; <span class="keyword">for</span> model.entries.iter().filter(|e| model.filter.fit(e)).enumerate().map(view_entry) &#125;</div><div class="line">                    &lt;/ul&gt;</div><div class="line">                &lt;/section&gt;</div><div class="line">                &lt;footer class=<span class="string">"footer"</span>,&gt;</div><div class="line">                    &lt;span class=<span class="string">"todo-count"</span>,&gt;</div><div class="line">                        &lt;strong&gt;&#123; model.total() &#125;&lt;/strong&gt;</div><div class="line">                        &#123; <span class="string">" item(s) left"</span> &#125;</div><div class="line">                    &lt;/span&gt;</div><div class="line">                    &lt;ul class=<span class="string">"filters"</span>,&gt;</div><div class="line">                        &#123; <span class="keyword">for</span> Filter::iter().map(|flt| view_filter(&amp;model, flt)) &#125;</div><div class="line">                    &lt;/ul&gt;</div><div class="line">                    &lt;button class=<span class="string">"clear-completed"</span>, onclick=|_| Msg::ClearCompleted,&gt;</div><div class="line">                        &#123; <span class="built_in">format!</span>(<span class="string">"Clear completed (&#123;&#125;)"</span>, model.total_completed()) &#125;</div><div class="line">                    &lt;/button&gt;</div><div class="line">                &lt;/footer&gt;</div><div class="line">            &lt;/section&gt;</div><div class="line">            &lt;footer class=<span class="string">"info"</span>,&gt;</div><div class="line">                &lt;p&gt;&#123; "Double-click to edit a todo" &#125;&lt;/p&gt;</div><div class="line">                &lt;p&gt;&#123; "Written by " &#125;&lt;a href="https://github.com/DenisKolodin/", target="_blank",&gt;&#123; "Denis Kolodin" &#125;&lt;/a&gt;&lt;/p&gt;</div><div class="line">                &lt;p&gt;&#123; "Part of " &#125;&lt;a href="http://todomvc.com/", target="_blank",&gt;&#123; "TodoMVC" &#125;&lt;/a&gt;&lt;/p&gt;</div><div class="line">            &lt;/footer&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>코드는 생각보다 어렵지 않다. Gorilla 같은 Go의 웹 프레임워크를 처음 볼때와 흡사하다. 다만 다른 부분은 view안에 JSX 처럼 코드 스니펫을 사용한다는 것이다. JSX 처럼 컴포넌트화 하지는 않는 것 같다.<br>struct는 모델을 정의하고 이벤트를 처리할 함수를 update로 정의한 후에 view 에서 렌더링을 하고 있다. 이렇게 코드를 작성하고 실행을 시키고 나면, 다음과 같이 ToDoMVC 앱이 뜨는 것이다.<br><img src="/images/2018/01/todo_mvc.png" alt="진리의 asdf"></p>
<p>이것이 정확히 어떻게 작동하게 되는지 app.js를 알아보자. toggleEdit이라는 이벤트의 아래 코드는 다음과 같이 바뀐다.<br><img src="/images/2018/01/code_converted.png" alt="그만 알아 보자"></p>
<h4 id="cargo-web"><a href="#cargo-web" class="headerlink" title="cargo-web"></a>cargo-web</h4><p>이런 극적인 코드가 가능해 지는데에는 cargo-web 이라는 프로젝트가 뒤에 있다.<br><img src="/images/2018/01/cargo_web.png" alt="카르고 웹"><br>링크 : <a href="https://github.com/koute/cargo-web" target="_blank" rel="external">cargo web</a> </p>
<p>cargo는 rust 에서 사용되는 패키지 매니저인데 subcommand라는 개념으로 패키지들을 관리한다.<br>그 중에 이 cargo web이라는 프로젝트가 rust 코드를 asm.js 록은 웹어셈블리로 변환해 주는 역할을 하고 있다.</p>
<h4 id="설치스크립트"><a href="#설치스크립트" class="headerlink" title="설치스크립트"></a>설치스크립트</h4><p>Mac OS 기준으로 아래와 같은 명령어를 사용해서 설치를 했다.</p>
<ol>
<li><p>emscripten 설치</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$curl -O https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz</div><div class="line">$tar -xzf emsdk-portable.tar.gz</div><div class="line">$source ./emsdk_portable/emsdk_env.sh</div><div class="line">$emsdk install sdk-incoming-<span class="number">64</span>bit</div><div class="line">$emsdk activate sdk-incoming-<span class="number">64</span>bit</div><div class="line">``` </div><div class="line">설치하다 openssl 관련해서 에러가 날 수가 있는데, 그럴 경우에는 OPENSSL_DIR을 제대로 지정해 주면 에러가 사라진다. </div><div class="line"></div><div class="line"><span class="number">2</span>. rust 설치</div><div class="line">```<span class="built_in">cmd</span></div><div class="line">$curl https://sh.rustup.rs -sSf | sh</div></pre></td></tr></table></figure>
</li>
<li><p>cargo 설치</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$curl -sSf https://static.rust-lang.org/rustup.sh | sh</div></pre></td></tr></table></figure>
</li>
<li><p>cargo web 설치</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$cargo install cargo-web</div></pre></td></tr></table></figure>
</li>
<li><p>yew 설치</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cargo install cargo-web</div><div class="line">$ rustup target add asmjs-unknown-emscripten</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h4><p>프로젝트에 데모가 존재한다.<br>깃으로 클론을 받자<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/DenisKolodin/yew</div></pre></td></tr></table></figure></p>
<p>프로젝트에 들어가서 해당 샘플폴더(Cargo.toml이 있는 곳)에서 cargo web start를 실행하면 프로젝트가 시작이 된다. 기본포트는 8000번을 사용한다.<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$cargo web <span class="built_in">start</span></div></pre></td></tr></table></figure></p>
<p><img src="/images/2018/01/cargo_web_started.png" alt="카르고 웹 스타트"></p>
<h4 id="링크-모음"><a href="#링크-모음" class="headerlink" title="링크 모음"></a>링크 모음</h4><p>관련 링크는 다음과 같다.</p>
<ul>
<li><a href="https://www.rust-lang.org/ko-KR/" target="_blank" rel="external">rust</a></li>
<li><a href="https://servo.org/" target="_blank" rel="external">servo</a> </li>
<li><a href="https://github.com/koute/cargo-web" target="_blank" rel="external">cargo-web</a></li>
<li><a href="https://github.com/DenisKolodin/yew" target="_blank" rel="external">yew</a></li>
<li><a href="https://github.com/mbasso/asm-dom" target="_blank" rel="external">asm-dom</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018년 새해가 밝았다. 올해는 어떤 포스팅을 더 할 수 있을지 고민해 보았다. 물론 언제나 나의 계획과 이룰 수 있는데에는 한계가 있다. &lt;/p&gt;
&lt;h3 id=&quot;올-한해-하고-싶은-포스팅&quot;&gt;&lt;a href=&quot;#올-한해-하고-싶은-포스팅&quot; cla
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>peer-review.md</title>
    <link href="http://keen.devpools.kr/2018/01/05/peer-review-md/"/>
    <id>http://keen.devpools.kr/2018/01/05/peer-review-md/</id>
    <published>2018-01-05T03:38:30.000Z</published>
    <updated>2018-01-05T03:38:30.767Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[2017-11-27] 11월 깃헙 트렌드</title>
    <link href="http://keen.devpools.kr/2017/11/27/2017-11-27-11%EC%9B%94-%EA%B9%83%ED%97%99-%ED%8A%B8%EB%A0%8C%EB%93%9C/"/>
    <id>http://keen.devpools.kr/2017/11/27/2017-11-27-11월-깃헙-트렌드/</id>
    <published>2017-11-27T03:42:39.000Z</published>
    <updated>2017-11-29T02:59:24.336Z</updated>
    
    <content type="html"><![CDATA[<p>11월 한달간 깃헙에 올라온 프로젝트 중 많은 호응을 얻었던 프로젝트들을 정리해 보았다.<br>여전히 자바스크립트와 딥러닝 쪽 트렌드가 초 강세를 보이고 있다. awesome 시리즈 같은 curation 프로젝트도 여전히 최상위권에 존재하는 중.<br>(curation 프로젝트라 함은 좋은 팁과 사이트들을 집합해 놓을 것을 의미함)</p>
<p>11월 한달(27일 기준) 가장 핫한 프로젝트 10선</p>
<ul>
<li><a href="https://github.com/k88hudson/git-flight-rules" target="_blank" rel="external">git-flight-rules</a></li>
<li><a href="https://github.com/i0natan/nodebestpractices" target="_blank" rel="external">nodebestpractices</a></li>
<li><a href="https://github.com/frappe/charts" target="_blank" rel="external">charts</a></li>
<li><a href="https://github.com/thedaviddias/Front-End-Checklist" target="_blank" rel="external">Front-End-Checklist</a></li>
<li><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">tensorflow</a> </li>
<li><a href="https://github.com/RedditSota/state-of-the-art-result-for-machine-learning-problems" target="_blank" rel="external">state-of-the-art-result-for-machine-learning-problems</a></li>
<li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="external">awesome</a></li>
<li><a href="https://github.com/ant-design/ant-design-pro" target="_blank" rel="external">ant-design-pro</a></li>
<li><a href="https://github.com/moment/luxon" target="_blank" rel="external">luxon</a> </li>
<li><a href="https://github.com/vuejs/vue" target="_blank" rel="external">vue</a> </li>
</ul>
<h2 id="git-flight-rules"><a href="#git-flight-rules" class="headerlink" title="git-flight-rules"></a>git-flight-rules</h2><p>링크 : <a href="https://github.com/k88hudson/git-flight-rules" target="_blank" rel="external">git-flight-rules</a></p>
<p>이 프로젝트는 작명도 훌륭하지만 더 훌륭한 것은 내용이다.<br>예를 들어서 “특정한 리비전으로 파일을 리버트 하고 싶을때에는 어떻게 하지?” 라는 질문 형태의 목록들을 가지고 있다.<br>(우리가 궁금해 하는 바로 그것! 느낌!)<br>예를 들어 질문 목록을 확인해 보면 아래 그림과 같다.</p>
<p><img src="/images/2017112701.png" alt="질문 목록"></p>
<p>해석해 보면 </p>
<ul>
<li>방금 내가 한 커밋은 뭐였지? </li>
<li>커밋 메세지를 잘못 입력했을 때 </li>
<li>커밋할 때 이메일과 이름을 잘못 썼다. </li>
<li>커밋에서 파일 하나를 제외하고 싶을 때 </li>
</ul>
<p>등등으로 실제로 필요한 일상의 개발 노하우가 잘 나타나 있다<br>물론 한글이 아니라 좀 답답하기는 한데 누군가가 한글로 금방 번역해서 올려 줄 것으로 예상된다. </p>
<h2 id="Node-js-Best-Practices"><a href="#Node-js-Best-Practices" class="headerlink" title="Node.js Best Practices"></a>Node.js Best Practices</h2><p>최근 팀에서 코드리뷰를 하다가 자바스크립트에서 세미콜론(;)을 붙이는것을 표준으로 할 것인지 아니면 붙이지 않는 것을 표준으로 할 것인지에 대한 논쟁이 일어났다.<br>당연히 최근에 나온것이 세미콜론이 없어도 해석할 수 있다이므로 없애는 것에 한표를 던졌는데, 지지를 철회해야 할 지도 모르겠다.</p>
<p>링크 : <a href="https://github.com/trending?since=monthly" target="_blank" rel="external">Node.js Best Practice</a></p>
<p><img src="/images/2017112702.png" alt="Node.js Best Practices"></p>
<p>이 프로젝트는 Node.js 의 BP들을 잘 모아둔 curation 사이트다.<br>많은 사람들이 Node.js에서 신경써야할 아키텍처와 패턴을 잘 몰라하는데 이 프로젝트는 꽤나 많은 해답을 줄 수 있을 것으로 보인다.</p>
<p>예를 들어 1.3의 “공용(common) 으로 사용하는 자바스크립트는 npm package로 만들어라” 부분 같은 것은 Node 패키지의 기본 컨셉을 담고 있고 2.1의 “에러 핸들링은 Async와 Await을 사용해라” 같은 부분도 최근 코드리뷰를 하면서 팀원들 끼리 옥신 각신 했던 부분인데 왜 그렇게 해야하는지도 잘 설명하고 있는것이 포인트.<br> (콜백 에러 핸들링이 콜백지옥으로 빠지는 것을 Async와 Await을 사용하면 잘 해결 되는 것을 이야기 하고 있음.) </p>
<h2 id="프라페-charts"><a href="#프라페-charts" class="headerlink" title="프라페 charts"></a>프라페 charts</h2><p>chartJS 가 아님. 다른 프로젝트에 디펜던시가 없는 간단한 차트 프로젝트.<br>프로젝트를 찬찬히 들여다 보면 깃헙의 히트맵과 프로그레스 바를 만들어 둔 것이 인상적이다. 관련 블로그에도 해당 내용이 적혀 있을 정도.</p>
<p>프로젝트 링크 : <a href="https://github.com/frappe/charts" target="_blank" rel="external">charts 깃헙</a><br>블로그 링크 : <a href="https://medium.com/@pratu16x7/so-we-decided-to-create-our-own-charts-a95cb5032c97" target="_blank" rel="external">so we decided to create our own charts</a> </p>
<p><img src="https://github.com/frappe/charts/raw/master/.github/example.gif" alt="chart example"></p>
<p>블로그를 읽다가 보면 c3.js를 사용하다가 스타을 새로 준다던지, 새로운 고객들의 요구에 응하려다가 자체적으로 개발하기로 한 과정들이 나와 있고 DOM을 조작하는데 SnapSVG 나 jquery 없이 만들기 위해 어떤 고려들을 했는지, CSS3 대신에 고려할 것드을 어떻게 확인했는지 등의 이야기가 재미있게 기술되어 있다.<br>( 블로그가 훨씬 흥미로운 내용이 많은 듯 .)</p>
<p>jquery를 바닐라도 대체할 때 참조할 수 있는 <a href="http://youmightnotneedjquery.com/" target="_blank" rel="external">You might not need jQuery</a><br>라는 사이트도 참조할 만하다. ( 하지만 사이트를 보다보면 jquery 없이 어떻게 개발하지? 라는 생각이 들지도…)</p>
<h2 id="luxon"><a href="#luxon" class="headerlink" title="luxon"></a>luxon</h2><p>타임스탬프 혹은 Date 라이브러리는 언제나 어렵다. 특히 MSA 같은 이기종간의 데이터를 주고 받는 요즘에 점점 중요해 지지만 매번 어렵기는 마찬가지.<br>이 문제를 해결하기 위한 가장 스마트한 방법은 그동안 모멘트 프로젝트 였는데, 오픈 소스 내부 컨트리뷰터 중에서 모멘트의 구조를 바꾸려고 하다가 프로젝트를 새로 만들었는데 사람들의 주목을 많이 받게 되어 소개할까 한다.</p>
<p>링크1: <a href="https://github.com/moment/moment" target="_blank" rel="external">모멘트 프로젝트</a></p>
<p>링크2: <a href="https://github.com/moment/luxon" target="_blank" rel="external">luxon 프로젝트</a></p>
<p><img src="/images/2017112703.png" alt="luxon"></p>
<p>몇가지 눈에 띄는 다른 점을 코드를 통해 살펴보자.</p>
<p>가장 눈에 띄는 변화는 immutable 의 적용이다.<br>(immutable 이란 객체의 값이 변경되지 않는 것을 의미 하는 것으로 map 같은 객체가 변경이 되는 코드가 들어가면 리턴 값으로 새로운 객체를 반환해 주는 특징을 가지고 있다.)<br><a href="https://facebook.github.io/immutable-js/" target="_blank" rel="external">immutable.js</a> 가 가장 대표적인 라이브러리이다.</p>
<p>일단 모멘트의 코드부터 살펴보자<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m1 = moment();</div><div class="line"><span class="keyword">var</span> m2 = m1.add(<span class="number">1</span>, <span class="string">'hours'</span>);</div><div class="line">m1.valueOf() === m2.valueOf(); <span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure></p>
<p>1시간을 더 했지만 m1 과 m2의 값이 같다니.<br>immutable 을 적용한 luxon의 코드는 다음과 같다. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var d1 = DateTime.local();</div><div class="line">var d2 = d1.plus(&#123; hours: 1 &#125;);</div><div class="line">d1.valueOf() === d2.valueOf(); //=&gt; false</div></pre></td></tr></table></figure>
<p>d2의 값이 변경되었다. 이렇게 함으로 의도적으로 다른 값을 할당하기 위한 객체의 deep copy를 수행할 필요가 없어진다.</p>
<p>그 외의 주요 변화는 다음과 같다.</p>
<ol>
<li>월(Month)의 인덱스가 1부터 시작을 한다.(Moment 와 네이티브 자바스크립트 Date 는 0부터)</li>
<li>로칼라이제이션과 타임존이 네이티브 API로 변경된다. (그 전에는 라이브러리에 포함되어 있었음.)</li>
<li>Duration과 Interval 타입을 전부 가진다.</li>
</ol>
<p>참고 : <a href="https://moment.github.io/luxon/docs/manual/faq/moment.html" target="_blank" rel="external">모멘트 개발자가 알아둬야할 부분.</a></p>
<h2 id="맺으며"><a href="#맺으며" class="headerlink" title="맺으며"></a>맺으며</h2><p>이번에 커버 되지는 않았지만 딥러닝쪽  tensorflow 와 state of art 시리즈를 볼 때 지속적으로 딥러닝 프레임워크 쪽은 들여다 볼 필요가 있을 것으로 생각이 들고 여전히 프론트 엔드쪽은 강세인데 vue.js 가 깃헙 프로젝트의 순위도 점점 평정해 가는 느낌이 강하다. 추세선으로는 react 를 조만간 뛰어넘을 기세로 보인다. 그리고 현장에서는 이미 vue가 통일을 하는 분위기로 보인다. 아직은 중요한 프로젝트들은  react로 의사 결정이 나지만 내년 하반기에는 바뀌지 않을까?</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;11월 한달간 깃헙에 올라온 프로젝트 중 많은 호응을 얻었던 프로젝트들을 정리해 보았다.&lt;br&gt;여전히 자바스크립트와 딥러닝 쪽 트렌드가 초 강세를 보이고 있다. awesome 시리즈 같은 curation 프로젝트도 여전히 최상위권에 존재하는 중.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[tip] -도커로 깃랩을 설치했을때 젠킨스 연결은 어떻게 할 것인가</title>
    <link href="http://keen.devpools.kr/2017/09/14/gitjenkinstip/"/>
    <id>http://keen.devpools.kr/2017/09/14/gitjenkinstip/</id>
    <published>2017-09-14T04:31:23.000Z</published>
    <updated>2017-09-14T07:10:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>깃랩같은 좋은 툴은 언제나 파워풀하지만, 설치가 쉽지않다. 그래서 깃랩을 설정하기가 어려운 부분은 도커가 최근에는 대신하고 있다.<br>그런데, 도커로 설치를 하다보면 CI, CD 환경을 꾸미는 것은 어떻게 해야할지 감이 오지 않을 때가 많다.</p>
<p>도커로 깃랩을 설치하는 것과 관련된 글은 검색을 하면 수십개가 나오고, 젠킨스와 깃랩을 연동하는 부분도 굉장히 많이 나오지만 도커로 설치된 깃랩과 젠킨스 연동을 위한 중요한 링크가 빠져 있다.</p>
<p>중요한 두가지 설정 포인트가 필요하다.</p>
<h3 id="1-ssh-포트-변경된-경우-git-연결"><a href="#1-ssh-포트-변경된-경우-git-연결" class="headerlink" title="1. ssh 포트 변경된 경우 git 연결"></a>1. ssh 포트 변경된 경우 git 연결</h3><p>~/.ssh/config 파일을 만든다.<br>ServerName, UserName, Port 은 프로젝트에 맞춰 준다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Host &#123;ServerName&#125;</div><div class="line">        User &#123;UserName&#125;</div><div class="line">        Port &#123;Port&#125;</div></pre></td></tr></table></figure></p>
<p>이후 git 명령어로 프로젝트를 잘 가져오는지 확인하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$git</span> <span class="built_in">clone</span> ssh://git@server:[port]/url</div></pre></td></tr></table></figure>
<h3 id="2-git-연결-주소-설정"><a href="#2-git-연결-주소-설정" class="headerlink" title="2. git 연결 주소 설정"></a>2. git 연결 주소 설정</h3><p>참고로, 퍼블릭키와 프라이빗 키는 이미 잘 설정되어 있을 거라는 전제하에 얘기한다.</p>
<p>링크 : <a href="http://egloos.zum.com/mcchae/v/11246199" target="_blank" rel="external">gitlab과 Jenkins연동</a></p>
<p>위 링크에 대해서 URL을 설정하는 부분만 아래와 같이 바꾸면 잘 해결되는 것을 확인할 수 있다.</p>
<p><img src="/images/sourcecodemgmt.png" alt="링크 주소 설정"></p>
<p>이렇게 되고 나면 깃에 자유자재로 업데이트하고 긁어올 수 있음을 알 수 있다. 나머지 CI, CD 옵션은 원하는데로 구성하면 된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;깃랩같은 좋은 툴은 언제나 파워풀하지만, 설치가 쉽지않다. 그래서 깃랩을 설정하기가 어려운 부분은 도커가 최근에는 대신하고 있다.&lt;br&gt;그런데, 도커로 설치를 하다보면 CI, CD 환경을 꾸미는 것은 어떻게 해야할지 감이 오지 않을 때가 많다.&lt;
    
    </summary>
    
    
      <category term="tip, docker, devops, git" scheme="http://keen.devpools.kr/tags/tip-docker-devops-git/"/>
    
  </entry>
  
  <entry>
    <title>[github]Node.js 기반 헤드리스 브라우저 컨트롤 API - puppeteer</title>
    <link href="http://keen.devpools.kr/2017/09/14/puppeteer/"/>
    <id>http://keen.devpools.kr/2017/09/14/puppeteer/</id>
    <published>2017-09-14T04:09:55.000Z</published>
    <updated>2017-09-14T04:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/puppeteer.jpg" alt="puppeteer"><br>프로젝트 링크 : <a href="https://github.com/GoogleChrome/puppeteer/" target="_blank" rel="external">https://github.com/GoogleChrome/puppeteer/</a><br>첫번째 프로젝트는 구글 크롬 프로젝트에서 Headless Chrome Node API 로 내 놓은 퍼펫티어다. 퍼펫이라고 하면 번역하면 인형술사이고 꼭두각시 인형을 다루는 사람을 이야기 한다. 이 프로젝트의 배경부터 이야기 하자면 올해(2017년) 4월 경 구글프로젝트에서는 크롬에 Headless 모드를 추가했다.<br>Headless 브라우저라고 하면 일반적으로 CLI환경에서 브라우저가 시각적으로 보여지지 않고 백그라운드에서 작동할 수 있는 것을 이야기 하는데, 이 전까지 가장 유명한 것은 PhantomJS라는 프로젝트였다. 크롤링을 하고 스크린 샷을 찍어서 다운로드하고 등의 일들을 할 수 있었다. 그래서 데스크탑이 아닌 서버에서 DOM을 읽어야 하는 경우 등에서 많이 사용되고는 했었다. </p>
<p>필자의 경우는 테스트 환경을 꾸밀 수 있지 않을까 하는 기대에 관련된 작업들을 진행해 보았고 관련되어 링크를 남기기도 했다.<br>링크 : 헤드리스 크롬과 selenium2의 조합을 사용해 보자 with node (<a href="http://keen.devpools.kr/2017/06/07/about-test/">http://keen.devpools.kr/2017/06/07/about-test/</a> ) </p>
<p>그런데, 8월 한달 가장 주목받은 프로젝트가 된 이 puppeteer는 Node.js에서 헤드리스 크롬을 사용할 수 있는 API들을 제공하는 것이다. Headless 모드를 발표하자마자 Phantom.JS는 더 이상 개발 안하기로 선언을 한 것과 마찬가지로 Node.js 진영에 새로운 무기가 생겨버린 셈이 되었다</p>
<h2 id="1-설치를-해보자"><a href="#1-설치를-해보자" class="headerlink" title="1. 설치를 해보자"></a>1. 설치를 해보자</h2><p>먼저 프로젝트를 한번 만들어 보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$mkdir</span> puppeteer-project &amp;&amp; <span class="built_in">cd</span> puppeteer-project</div><div class="line"><span class="variable">$yarn</span> add puppeteer</div></pre></td></tr></table></figure></p>
<p>이렇게 설치를 하고 나면 프로젝트에 index.js 파일을 만든다..</p>
<p>&lt;코드&gt;index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</div><div class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line">  <span class="keyword">await</span> page.goto(<span class="string">'http://devpools.kr'</span>);</div><div class="line">  <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'devpools.png'</span>&#125;);</div><div class="line"></div><div class="line">  browser.close();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>스크린샷을 가져 오는 코드가 작성되었다.  개발바보들 첫 페이지의 스크린 샷을 가져오는 소스 코드를 작성한 이후에 node index.js 명령어를 입력하면 다음과 같은 이미지를 가지고 오는 것을 볼 수 있다. </p>
<p>기본적으로 지정된 이미지 크기는 800*600으로 지정된 듯 하다. 보통 phantomJS 같은 경우는 스크롤을 다 잡아 가던 초반 모습에 비해 메모리 관리를 위한 것인지 이미지 해상도도 그렇게 좋은 거 같지는 않아 보인다. </p>
<p>PDF로 Export 하는 기능도 API를 통해 구현이 가능하다. </p>
<p><img src="/images/crawled_devpools.jpg" alt="개발바보들 스크린샷"></p>
<h2 id="2-크롤링을-해-보자"><a href="#2-크롤링을-해-보자" class="headerlink" title="2. 크롤링을 해 보자."></a>2. 크롤링을 해 보자.</h2><p>이번엔 find.js 라는 파일을 아래와 같이 만들어 본다. 실제로 이미지와 지금 아래 크롤링 소스는 해당 프로젝트와 내용이 거의 유사하다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line">(<span class="keyword">async</span>() =&gt; &#123;</div><div class="line"><span class="comment">//브라우저 객체와 페이지 객체를 만들고</span></div><div class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</div><div class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line"></div><div class="line"><span class="comment">// 구글 검색창 방문</span></div><div class="line"><span class="keyword">await</span> page.goto(<span class="string">'https://google.com'</span>, &#123;<span class="attr">waitUntil</span>: <span class="string">'networkidle'</span>&#125;);</div><div class="line"><span class="comment">//개발 바보들에 대한 검색어를 입력하고</span></div><div class="line"><span class="keyword">await</span> page.type(<span class="string">'devpools'</span>);</div><div class="line"><span class="comment">// 검색버튼을 누르고</span></div><div class="line"><span class="keyword">await</span> page.click(<span class="string">'input[type="submit"]'</span>);</div><div class="line"><span class="comment">//검색한 결과의 타이틀을 가져와서</span></div><div class="line"><span class="comment">// Wait for the results to show up</span></div><div class="line"><span class="keyword">await</span> page.waitForSelector(<span class="string">'h3 a'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> links = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> anchors = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'h3 a'</span>));</div><div class="line">  <span class="keyword">return</span> anchors.map(<span class="function"><span class="params">anchor</span> =&gt;</span> anchor.textContent);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//콘솔에 출력한다.</span></div><div class="line"><span class="built_in">console</span>.log(links.join(<span class="string">'\n'</span>));</div><div class="line">browser.close();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>소스 코드에 대한 설명은 주석에 달아 둔데로 브라우저 객체와 페이지 객체를 만들고 구글 검색창을 방문해서 개발 바보들에 대한 검색어를 입력하고 검색버튼을 누른 뒤 검색된 결과의 타이틀을 가져와서 콘솔에 출력한다.</p>
<p>그 결과는 다음과 같다. 이 과정 중에 어떤 브라우저의 인터렉션도 필요 없었고 (내부적으로는 크롬 헤드리스 브라우저가 작동을 했지만) 사용자의 경우는 결과만 가져올 수 있다.</p>
<p><img src="/images/searchresults.jpg" alt="devpools 검색결과"></p>
<h2 id="맺음말"><a href="#맺음말" class="headerlink" title="맺음말"></a>맺음말</h2><p>왜 구글은 이런 제품을 내놓고 있는 걸까? 워낙 혁신적인 기업이라 속내를 다 살펴볼 수는 없지만 지속적으로 API를 내놓고 있는 것은 웹의 많은 부분이 자동화로 돌아설 것이고 그 중심에 인공지능이 있지 않을까 하는 생각이 들어 잠시 한번 고민을 해 보았다. 아마도 텐서플로가 조만간 DOM 기반의 러닝 모델을 공개하는 날이 오지 않을까?</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/puppeteer.jpg&quot; alt=&quot;puppeteer&quot;&gt;&lt;br&gt;프로젝트 링크 : &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/&quot; target=&quot;_blank&quot; rel=&quot;
    
    </summary>
    
    
      <category term="github-trend, github" scheme="http://keen.devpools.kr/tags/github-trend-github/"/>
    
  </entry>
  
  <entry>
    <title>딥러닝 무식하게 정리해 보기 01</title>
    <link href="http://keen.devpools.kr/2017/09/08/deeplearning-basic01/"/>
    <id>http://keen.devpools.kr/2017/09/08/deeplearning-basic01/</id>
    <published>2017-09-08T02:44:06.000Z</published>
    <updated>2017-09-08T03:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>딥러닝, 인공지능 이야기를 하면 CNN, RNN 같은 알고리즘에 관한 글만 굉장히 많아서 조금 탑뷰에서 바라볼 수 있는 관점에서 전체 기술과 활용처를 분류하고 딥러닝 프레임워크에 대해서 알아 보았다. 딥러닝 프레임워크는 같이 프로젝트를 하고 있는 팀 로자미아 가 같이 정리를 해 주었다. Mabel, Jin, Alex 에게 감사를 드린다.</p>
<h2 id="AI-기술의-응용-분야"><a href="#AI-기술의-응용-분야" class="headerlink" title="AI 기술의 응용 분야"></a>AI 기술의 응용 분야</h2><p>딥러닝은 여러가지 알고리즘을 가지고 있지만 결국 하고자 하는 대부분의 일들이 군집(clustering)과 분류(classification) 라는 관점으로 귀결된다.<br>그에 따라 AI 기술 스택을 분류하는 방법은 여러가지가 있고 활용되는 분야도 다양하지만 아래와 같이 분류를 해보았다.<br>먼저 챗봇과 번역등에 사용되는 NLU등을 사용하는 Conversational AI.<br>두번째는 개와 고양이 구분하기 등에 많이 사용되는 Visual AI 분야.<br>마지막으로는 전통적으로 진행하던 데이타 분석을 하는 Analytic AI.</p>
<h3 id="Conversational-AI"><a href="#Conversational-AI" class="headerlink" title="Conversational AI"></a>Conversational AI</h3><p><img src="/images/playmobil-451203_640.jpg" alt="conversation goes on"></p>
<p>Conversational AI 에는 기본적으로 NLU(Naturla Language Understanding)을 그 근간으로 한다. 오픈 소스중에선 Rasa.ai 같은 프레임워크가 존재하고 오픈 서비스로는 wit.ai 와 api.ai 가 있고 제품으로 유명한 것은 IBM의 conversational 엔진이 유명하다. 일반적인 개발자들이 가장 많이 만나는 것은 페이스북을 가지고 챗봇을 한번 만들어보다가 만나게 되는 것이 NLU 와의 처음 만남이 된다고 볼 수 있다. 이 NLU 엔진은 여러가지 기능을 가지는데 기본적으로 전체의 맥락을 판단하고 키워드를 뽑아내는 게 으뜸된 기능인데 이것을 인텐트와 엔터티라는 업계 용어로 지칭한다.<br>맥락 혹은 화행에는 기본적으로 의도가 들어가 있고 감정이 들어가 있어서 이런 감성을 파악해 내는 데 word2vec doc2vec 같은 툴들이 사용된다. 한글의 경우는 영어와 다른 구조를 가지고 있기 때문에 형태소를 분석해야 하고 mecab-ko 나 은전한잎 같은 툴들이 이용된다. </p>
<p>여기까지는 일반적인 NLU에 대한 이야기만 한 것이고, 챗봇을 위해서는 다이알로그의 룰이 존재하기 마련이라 룰 매니저 혹은 다이알로그 매니저들이 존재한다. 얘룰 들면 페이스북 챗봇을 만들 때 이런 말이 들어오면 이렇게 대답해야지.. 라고 만드는 대화 구성이 그런 역할을 하는 것이다. 이런 다이알로그 개념이 들어가면 한 문장의 문맥이 아닌 전체 문맥을 파악해야하는 기능과 랭킹 시스템을 구축해야 한다.</p>
<p>조금 더 나아가면 보통 STT(Speech To Text), TTS(Text To Speech) 로 알고 있는 음성자동 시스템이랑 연결해서 사용자의 음성을 듣고 텍스트로 변환해 준 뒤에 그것을 구축해 놓은 챗봇 시스템과 연결해 구축하는 작업들이 생겨나고 있다.</p>
<h3 id="AI-for-media"><a href="#AI-for-media" class="headerlink" title="AI for media"></a>AI for media</h3><p><img src="/images/abstract-1233873_640.jpg" alt="AI for media"></p>
<p>얼굴 인식, 피플 카운팅 등에 사용되는 Face Recognition 과 딥러닝 기반의 Object Recognition 은 미디어들을 통해 사람을 인식하거나 장면등을 파악해서 시스템과 연결하는 일들을 할 때 많이 사용된다. 딥러닝 기반 객체 인식은 보통 CNN 알고리즘으로 유명한데 최근에는 여러가지 알고리즘이 더 들어간 경우가 많고 YOLO Darknet 같은 경우는 인식률과 속도에서 다른 범용 툴을 압도한다.<br>피플 카운팅을 응용하면 히트맵 히트존 등의 기술등으로 확장이 가능하다.<br>OCR 프로그램은 기존에도 존재했던 것들인 많은데, 딥러닝 기반으로 프로젝트들이 변경되고 있다. 구글 tesseract 도 LSTM 알고리즘의 4.0 버전을 테스트 중이다.</p>
<h3 id="Analytics"><a href="#Analytics" class="headerlink" title="Analytics"></a>Analytics</h3><p>기존의 데이터들을 분석하는 툴 기반이라 딥러닝 보다는 기존 스파크와 하둡 기반의 빅데이터 툴들이 더 많은 일들을 해 주는 부분들이다.</p>
<h2 id="AI-기반-기술-스택-별로-알아보자-1"><a href="#AI-기반-기술-스택-별로-알아보자-1" class="headerlink" title="AI 기반 기술 스택 별로 알아보자 (1)"></a>AI 기반 기술 스택 별로 알아보자 (1)</h2><h3 id="인공지능을-위한-프로세서의-발전"><a href="#인공지능을-위한-프로세서의-발전" class="headerlink" title="인공지능을 위한 프로세서의 발전"></a>인공지능을 위한 프로세서의 발전</h3><p><img src="/images/nvidia-1201077_640.jpg" alt="템빨은 언제나 진리"></p>
<p>딥러닝은 기본적으로 다층 레이어의 많은 학습을 요구하기 때문에 단순한 계산이 순식간에 많이 일어나는 것을 특징으로 한다. 그렇기에 병렬처리 컴퓨팅이 가장 중요한 핵심기능이 되어서 기존 CPU이외의 다른 대안들이 필요하다.<br>그런 의미에서 프로세서 유니트(코어) 각각의 성능은 떨어지지만 프로세서 유니트 수가 압도적으로 많은 GPU 가 각광을 받았다. 특히 엔비디아 CUDA (병렬컴퓨팅 플랫폼의 API모델) 의 등장은 프로세서 경쟁에 불을 붙였다.<br>참조 : <a href="http://www.epnc.co.kr/news/articleView.html?idxno=75603" target="_blank" rel="external">http://www.epnc.co.kr/news/articleView.html?idxno=75603</a> </p>
<h4 id="GPGPU-General-Purpose-GPU"><a href="#GPGPU-General-Purpose-GPU" class="headerlink" title="GPGPU - General Purpose GPU"></a>GPGPU - General Purpose GPU</h4><p>범용 GPU를 이야기 하는 것으로 AI 용으로만 사용될 때는 TPU라는 이름을 쓰기도 한다.(Tensor Processing Unit) NVIDIA의 GPGPU를 극대화 하기 위한 CUDA 기술을 공개했고 동시에 범용 GPU 기능이 주목 받기 시작했다</p>
<h4 id="GPGPU를-넘어서"><a href="#GPGPU를-넘어서" class="headerlink" title="GPGPU를 넘어서"></a>GPGPU를 넘어서</h4><p>구글의 딥러닝의 학습속도를 향상시키기 위해 자체 디자인한 반도체 칩셋(ASIC)를 적용되면서 더 각광 받기 시작함. 구글의 ASIC를 TPU(Tensor Processing Unit) 이라 부르고 GPGPU의 범주에 놓기도 한다.<br>MS는 같은 목적으로 FPGA 칩을 클라우드 데이타 센터에 탑재해 Azure 서비스에도 이용하고 있는데, FPGA는 저전력의 강점도 가지고 있다.</p>
<h4 id="Neuromorphic-Processor"><a href="#Neuromorphic-Processor" class="headerlink" title="Neuromorphic Processor"></a>Neuromorphic Processor</h4><p>신경구조와 유사한 프로세서가 차후 프로세서로 각광을 받고 있고 IBM 같은 회사들이 준비하고 있다.<br>링크 : <a href="http://www.research.ibm.com/cognitive-computing/neurosynaptic-chips.shtml#fbid=rXQq5aX-WkP" target="_blank" rel="external">http://www.research.ibm.com/cognitive-computing/neurosynaptic-chips.shtml#fbid=rXQq5aX-WkP</a></p>
<h3 id="딥러닝-서비스를-위한-인프라"><a href="#딥러닝-서비스를-위한-인프라" class="headerlink" title="딥러닝 서비스를 위한 인프라"></a>딥러닝 서비스를 위한 인프라</h3><p><img src="/images/server-2160321_640.jpg" alt="요즘엔 서버실에 갈 일이 있어야지"></p>
<p>크게 딥러닝 전용 인프라는 클라우드와 판매형 인프라로 나뉘어서 볼 수 있을 것 같은데 기존의 아마존 AWS, 마이크로소프트의 Azure, 구글 클라우드 같은 빅3는 이미 클라우드 인프라를 가지고 있다.<br>AWS의 경우는 클라우드 AMI(Amazon Machin Image)도 제공하고 있어서 굉장히 편리하게 쓸 수 있다. AMI라는 것은 미리 만들어진 이미지 같은 개념으로 볼 수 있다. NVidia 의 경우는 자사의 GPU를 이용한 클라우드 서비스를 하고 있는 것이 흥미롭다.<br>판매형 인프라는 기존의 서버 벤더들과 비슷한 형태를 취하고 있는데 웨이브 컴퓨팅은 하나의 모델을 제안하는 데 텐서플로 같은 소프트웨어에 특화되어 만들어져 있다.이에 비해 Penguin computing 은 몇가지 옵션들을 더 제공하고 있다.</p>
<h2 id="맺으며"><a href="#맺으며" class="headerlink" title="맺으며"></a>맺으며</h2><p>딥러닝, 인공지능 등을 바라볼때 탑뷰로 어떤 기술이 있는지를 알아보는 과정을 거치고 있다. 다음 번엔 개발자에게는 가장 중요한 딥러닝 프레임워크들을 다뤄보도록 하겠다. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;딥러닝, 인공지능 이야기를 하면 CNN, RNN 같은 알고리즘에 관한 글만 굉장히 많아서 조금 탑뷰에서 바라볼 수 있는 관점에서 전체 기술과 활용처를 분류하고 딥러닝 프레임워크에 대해서 알아 보았다. 딥러닝 프레임워크는 같이 프로젝트를 하고 있는
    
    </summary>
    
    
      <category term="deep learning" scheme="http://keen.devpools.kr/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>(tech-trend) 구루들이 찾는다는 테크 트렌드 - 유명 블로그와 소셜 유명인</title>
    <link href="http://keen.devpools.kr/2017/08/03/tech-trend-03/"/>
    <id>http://keen.devpools.kr/2017/08/03/tech-trend-03/</id>
    <published>2017-08-03T10:00:00.000Z</published>
    <updated>2017-08-06T07:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>이 글은 회사 기술 블로그에 올리고 있는 내용입니다. 회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기를 진행 중에 있습니다.</p>
<p>필자는 SDS Agile Core Team 에서 테크리드를 담당하고 있습니다.<br>OSGeo에서 오픈소스 활동을 하고 있습니다. 잘 모르는 기술에 대해서 낯선 사람들과 이야기 하면서 배워 나가는 것을 좋아합니다.</p>
</blockquote>
<h2 id="기술-트렌드에-관련해서-3-blog-amp-social-star"><a href="#기술-트렌드에-관련해서-3-blog-amp-social-star" class="headerlink" title="기술 트렌드에 관련해서 - 3. blog &amp; social star"></a>기술 트렌드에 관련해서 - 3. blog &amp; social star</h2><p>구루들이 찾는 다는 테크 트렌드의 마지막 시간이다. 이후에는 React 개발 때 TDD를 어떻게 적용하는 지에 대한 내용을 다뤄볼까 한다. 사실 여기에 들어갈 블로그와 소셜스타를 일일이 나열하기에는 굉장히 본인의 네트워크의 한계와 좁은 지식에 기댈 수 밖에 없어서 굉장히 조심스럽지만 처음 테크트렌드를 찾는 사람들을 위해서 조금 라이트하게 읽을 수 있는 아티클을 쓰시는 분들 혹은 개발회사 블로그 위주로 설명하겠다.</p>
<h3 id="회사-기술-블로그"><a href="#회사-기술-블로그" class="headerlink" title="회사 기술 블로그"></a>회사 기술 블로그</h3><p>좋은 기술 회사는 기본적으로 좋은 회사 기술 블로그를 가지고 있습니다. 양질의 좋은 컨텐츠를 가지고 기술의 가야할 바도 제시하고 실제 하고 있는 일들을 잠깐씩 엿볼 수 있는 좋은 기회라고 볼 수 있다. </p>
<ul>
<li><p><a href="http://woowabros.github.io/" target="_blank" rel="external">우아한 형제들</a></p>
<ul>
<li>배달의 민족으로 O2O 의 새로운 지평을 열고 있는 쪽의 개발 블로그. 최근 MSA 글이 화제가 되었다. (<a href="http://woowabros.github.io/r&amp;d/2017/06/13/apigateway.html" target="_blank" rel="external">배민 API GATEWAY - spring cloud zuul 적용기</a>) 개발자들 모두가 쓰고 있다는 착각이 들 정도로 필자가 다양한 것이 특징. 그래서 글 마다 편차는 좀 존재한다.<br><img src="/images/wooa.png" alt="배민 API GATEWAY - spring cloud zuul 적용기"></li>
</ul>
</li>
<li><p><a href="http://d2.naver.com/home" target="_blank" rel="external">네이버 d2</a></p>
<ul>
<li>네이버 개발자들의 수준을 가늠해 볼 수 있는 좋은 블로그. 필자와 필력을 관리하는 것인지 대부분의 아티클들이 양과 질에서 여타 다른 회사 기술 블로그보다 평타이상을 한다. 번역글도 가끔 올라 오는데 2012년 화제가 된 글인 <a href="http://d2.naver.com/helloworld/59361" target="_blank" rel="external">“브라우저는 어떻게 작동하는가”</a> 같은 내용은 아직도 유효하고 유익하다.<br><img src="/images/naver_d2.png" alt="브라우저는 어떻게 작동하는가"></li>
</ul>
</li>
</ul>
<p>이 외에도 <a href="http://tech.lezhin.com/" target="_blank" rel="external">레진 기술블로그</a>, <a href="http://tech.kakao.com/" target="_blank" rel="external">카카오 기술 블로그</a> 등의 찾아가 볼만한 내용들을 가진 곳들이 꽤 많이 존재한다. 전통적인 기술 창고인 <a href="https://msdn.microsoft.com/ko-kr/default.aspx" target="_blank" rel="external">MSDN</a>, <a href="https://code.facebook.com/" target="_blank" rel="external">페이스 북 코드</a> 및 [구글 개발자 사이트][<a href="https://developers.google.com/" target="_blank" rel="external">https://developers.google.com/</a>] 에서 개발 흐름을 찾아 보는 것도 굉장한 도움이 된다.</p>
<h3 id="팀-블로그-혹은-큐레이션-블로그"><a href="#팀-블로그-혹은-큐레이션-블로그" class="headerlink" title="팀 블로그 (혹은 큐레이션 블로그)"></a>팀 블로그 (혹은 큐레이션 블로그)</h3><p>개발자들끼리 모여서 블로그를 같이 진행하는 경우도 몇군데 있는데, 이런 경우는 서로의 철학과 가고자 하는 방향이 잘 맞는 사람들끼리 모여서 진행을 하고 있다. 필자가 활동하는 팝잇(popit), 개발바보들(devpools)도 그 연장선상에 있다고 볼 수 있다. 주제를 정해서 같이 연재할 수 있는 장점도 있고 서로의 발전을 도모한다는 점에서도 이로운 방향이라고 볼 수 있다.</p>
<ul>
<li><p><a href="http://blog.weirdx.io/" target="_blank" rel="external">이상한 모임</a></p>
<ul>
<li>개발자(Dev), 오프모임(OFFLINE), 코드(CODE) , IT 기기(GADGET) 등의 광범위한 관심사를 가지고 있는 사람들이 모여서 자신들의 블로그를 올리는 형태의 블로그. 오프모임도 종종 진행하고 관리자가 이벤트를 꽤나 많이 주체하는 흥미로운 사이트다.<br><img src="/images/weird.png" alt="weird"></li>
</ul>
</li>
<li><p><a href="http://www.popit.kr" target="_blank" rel="external">팝잇</a></p>
<ul>
<li>주최측이 꽤나 개발자들 사이에서는 알려진 사람들로 이루어진 사이트. 주로 개발에 관련된 이야기만 한다. 좋은 점은 양질의 글을 읽을 수 있다는 점이고 나쁜 점은 개발자들의 관심사가 꽤나 비슷비습하다는 점이다.</li>
</ul>
</li>
</ul>
<h3 id="소셜-스타-개인-블로그"><a href="#소셜-스타-개인-블로그" class="headerlink" title="소셜 스타(개인 블로그)"></a>소셜 스타(개인 블로그)</h3><p>보통 트위터나 페이스북에서 유명 개발자 혹은 IT 쪽 인플루언서들을 찾아가 보면 대부분은 블로그가 그 원동력이다. 트위터나 페이스북은 그 사람의 지속적인 관심사나 생각의 흐름을 잡아내는데 굉장히 유용하다. 지금부터 언급되는 사람들은 소셜미디어에서도 유명하지만 블로그를 지속적으로 관심을 가지고 봐도 될만한 사람이다. 이 챕터는 기술의 깊이와 넓이에 따라서 굉장히 많은 사람이 호 불호가 갈릴 수 있어서 모두가 이해할 수 있는 선에서 그 영역을 마무리 짓고자 한다.</p>
<ul>
<li><p><a href="https://twitter.com/kwang82" target="_blank" rel="external">광파리</a></p>
<ul>
<li>트위터와 블로그 둘중 무엇을 링크를 걸까 하다가 트위터를 걸어 두었다. 트위터에 페북과 블로그 주소가 모두 존재하므로 방문하는데에는 지장이 없을 듯 한다. 원래 한국 경제 신문 IT 전문 기자였다가 지금은 D캠프 센터장. 전직 기자의 안목에서 보는 트렌드를 쫒아갈 수 있어서 큰 그림을 파악하는데에는 도움이 된다.</li>
</ul>
<ul>
<li><a href="https://blog.outsider.ne.kr/" target="_blank" rel="external">아웃사이더</a></li>
</ul>
<ul>
<li>굉장히 광범위하게 기술을 건드리는 개발자. 자바 이야기는 찾아 보기 힘들지만 주로 Node.js 와 자바스크립트. AWS 등의 기술들을 접할 수 있다. 깊이 있게 다루는 것에서 자기의 삽질기 까지. 필자의 관심사항과 굉장히 유사한 부분들을 건드린다. </li>
</ul>
<ul>
<li><a href="https://twitter.com/xguru?lang=ko" target="_blank" rel="external">xguru</a></li>
</ul>
<ul>
<li>최근에는 외부 블로깅과 소셜 활동을 많이 하진 않는 듯 한데, 한번 올리는 글에 힘이 있고 많은 사람들이 관심을 가진다. 예전 KTH 관련된 내용들을 많이 엿볼 수 있었다면 최근에는 레진의 내용들을 확인할 수 있다.</li>
</ul>
<ul>
<li><a href="http://blog.benelog.net/" target="_blank" rel="external">정상혁</a></li>
</ul>
<ul>
<li>여기는 한 사람의 개발닌자를 만난 듯한 인상을 주는 블로그. 넓이 보다는 깊이를 추구하는 독자에게는 도움이 될 수 있는 심오한 내용들을 많이 블로깅하고 있다. 오피스를 쓰냐 안쓰냐에 따라 개발자 혹은 개발회사로 구분할 수 있다는 철학을 가진 개발자</li>
</ul>
<ul>
<li><a href="http://blog.doortts.com/" target="_blank" rel="external">채수원</a></li>
</ul>
<ul>
<li>국내에 TDD 에 대해서 한 사람을 꼽으라고 한다면 꼭 이야기 하고 싶은 한 사람. 하지만 그 외에도 여러가지 이야기를 쓰고 잡담도 곧잘 올라오는데 필력이 대단해서 그 잡담마저 흥미롭다.</li>
</ul>
</li>
</ul>
<p>이상 간단하게 정리해 보았는데 아마도 더 유명한 사람들이 있을 수 있고 누군가의 취향은 다를 수 있다.. 그래서 깃헙의 다음 프로젝트를 조금은 더 자세한게 설명해 볼까 한다.</p>
<h2 id="8월의-프로젝트-Awesome-Devblog"><a href="#8월의-프로젝트-Awesome-Devblog" class="headerlink" title="8월의 프로젝트 - Awesome Devblog"></a>8월의 프로젝트 - Awesome Devblog</h2><p>지난번에 한번 설명을 한 대로 깁허브(github) 에는 여러 형태의 프로젝트가 존재하는데 그 중 하나라 Awesome 으로 시작되는 북마크 프로젝트들이 존재한다. 지금 소개할 프로젝트는 한국 기준으로 먼저 작성이 된 좋은 개발자(개발 블로그) 모음이다.<br>아마도 위에 정리한 사람들 혹은 팀은 거의 대부분 이 프로젝트에 정리가 되어 있다.</p>
<p><img src="/images/devblog.png" alt="awesome devblog"></p>
<p>일단 목차는 다음과 같다.</p>
<ul>
<li><a href="https://github.com/sarojaba/awesome-devblog#%EA%B5%AD%EB%82%B4-%EA%B0%9C%EC%9D%B8-%EC%82%AC%EC%9D%B4%ED%8A%B8" target="_blank" rel="external">국내 개인 사이트</a></li>
<li><a href="https://github.com/sarojaba/awesome-devblog#%EA%B5%AD%EB%82%B4-%ED%8C%80-%EC%82%AC%EC%9D%B4%ED%8A%B8" target="_blank" rel="external">국내 팀 사이트</a></li>
<li><a href="https://github.com/sarojaba/awesome-devblog#%EA%B5%AD%EC%99%B8-%EA%B0%9C%EC%9D%B8-%EC%82%AC%EC%9D%B4%ED%8A%B8" target="_blank" rel="external">해외 개인 사이트</a></li>
<li><a href="https://github.com/sarojaba/awesome-devblog#%EA%B5%AD%EC%99%B8-%ED%8C%80-%EC%82%AC%EC%9D%B4%ED%8A%B8" target="_blank" rel="external">해외 팀 사이트</a></li>
</ul>
<p>팀 안에 회사에 대한 구분은 없이 가나다 순 알파벳 순으로 소팅을 해 둔 사이트다.<br>이 안에서 한명 한명 찾아 보면서 시간을 보내도 휴가를 재미있게 즐길 수 있다.</p>
<p>하지만 이런 것들을 내가 실시간으로 최신 트렌드를 받아볼 수는 없을까? 이런 생각을 하면 누군가는 이미 작성을 해 두었다.<br>깃헙에 RSS 프로젝트를 만들었고( 아 이런 수고를 하다니 정말 대다나다.) RSS도 공개 되어 있다.<br><a href="https://github.com/BenjaminKim/awesome-blogs" target="_blank" rel="external">깃헙 프로젝트</a><br><a href="https://awesome-blogs.petabytes.org/feeds?group=dev" target="_blank" rel="external">RSS : https://awesome-blogs.petabytes.org/feeds?group=dev</a></p>
<p><img src="/images/devblog-rss.png" alt="devblog-rss"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;이 글은 회사 기술 블로그에 올리고 있는 내용입니다. 회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기를 진행
    
    </summary>
    
    
      <category term="tech trend, social media" scheme="http://keen.devpools.kr/tags/tech-trend-social-media/"/>
    
  </entry>
  
  <entry>
    <title>ES2015 리팩토링 – 2. 빠레꽁(var let const)</title>
    <link href="http://keen.devpools.kr/2017/08/01/refactoring02/"/>
    <id>http://keen.devpools.kr/2017/08/01/refactoring02/</id>
    <published>2017-08-01T02:36:53.000Z</published>
    <updated>2017-08-04T15:12:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 는 언제나 쉽지만 또 언제나 어렵다.<br>이런 개념을 처음 갖게 된게 아마도 변수가 내가 생각하는데로 작동하지 않던 시점이었던 것으로 기억한다.<br>개념이 생기기 전에 var를 변수 선언 해도 작동이 되고 생략해도 작동이 된다는 사실에 그냥 작성하다가 어느 새<br>나의 코드가 전역 변수가 되어 팀원 모두가 고생을 겪고, 변수 선언을 위에다 했는데 아래에서 올라오는 등의 경우의<br>내 머리속의 컨셉과 다르게 동작하는 경험을 겪고 나면 정말 혼란스러워 지는데 거기다 더해 지금 이글에서 언급하게<br>될 스코프, 호이스팅 등을 읽고나면 정말로 쉽지 않다라는 사실을 겪게 된다.  </p>
<p>ES2015 부터는 변수가 두가지 더 추가가 되었다. 이번엔 그 변수들을 어떻게 이해하고 언제 사용해야 할 지에 대해서 다뤄보겠다.</p>
<h2 id="JavaScript-변수-var-에-대해서"><a href="#JavaScript-변수-var-에-대해서" class="headerlink" title="JavaScript 변수 var 에 대해서"></a>JavaScript 변수 var 에 대해서</h2><p>var 밖에 없었으니까 JavaScript 변수 var 에 대해서라고 제목을 정하고 들어가 보자.<br>몇가지 특징만 짚어 보고 넘어가겠다. JavaScript 변수에 대한 조금 더 자세한 내용은 JavaScript Definite Guide 를 추천한다.</p>
<h3 id="1-변수의-var-선언이-없으면-코드의-복잡성이-증가하게-된다"><a href="#1-변수의-var-선언이-없으면-코드의-복잡성이-증가하게-된다" class="headerlink" title="1. 변수의 var 선언이 없으면 코드의 복잡성이 증가하게 된다."></a>1. 변수의 var 선언이 없으면 코드의 복잡성이 증가하게 된다.</h3><p>일단 코드를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div><div class="line"><span class="comment">//혹은 조건문 블럭으로 진행해도 결과는 같다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">    x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript는 나름 중첩시킨 함수 임에도 불구하고 x는 4를 출력하게 되어 있다. var 선언을 하지 않고 작성하면 기본적으로<br>직전의 상위 스코프의 변수를 찾게 되어 있는데 직전에도 선언이 되어 있지 않으면 하나 더 상위를 찾아 가게 된다. 이런식으로<br>의도하지 않은 전역 변수를 만들어 내고는 한다.</p>
<p>그렇다고 해서 선언 하기 전에 마구 사용해도 되느냐 하면 그것은 또 아닌 것이 x=4 위에 사용하면 undefined 를 출력하도록<br>되어 있다.</p>
<h3 id="2-호이스팅에-대해서"><a href="#2-호이스팅에-대해서" class="headerlink" title="2. 호이스팅에 대해서"></a>2. 호이스팅에 대해서</h3><p>아래 두 코드는 위의 전역 변수에 대한 개념과 변수 스코프 끌어올림(호이스팅)에 대한 개념이 섞여 있는 예제이다.<br>두 코드의 차이점을 한 눈에 알아 볼 수 있을까?</p>
<ul>
<li><p>var 선언을 안 한 경우</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  x=<span class="number">3</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"inner"</span>,x);</div><div class="line">    x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>var 선언을 한 경우</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  x=<span class="number">3</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"inner"</span>,x);</div><div class="line">  <span class="keyword">var</span> x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>var 선언을 안 한 경우 경우는 ( inner =3 , outer = 4 ) 의 결과가, var 선언을 한 경우 경우는 inner는<br>undefined 가 outer의 경우는 3 이 떨어진다.<br>왜 그럴까. var 선언을 안 한 경우 경우 결국 x의 스코프는 inner 안에서 찾을 수 없어서 outer 까지 가서 찾아 보게 된다.<br>호이스팅이라는 어려운 말로 적혀있지만 이 “찾아보게 된다”라는 개념으로 일단 이해하고 넘어가셔도 많은 경우에는 적용이 된다.<br>조금 더 확실한 의미로는 변수 선언을 끌어올림이 더 적절한 풀이가 되겠지만.<br>이렇게 이해하고 나면 두번째의 “var 선언을 한 경우 경우”는 오히려 더 자세히 이해가 된다.<br>var 선언을 한 시점에서는 스코프는 해당 함수 블럭만 찾게 될 것이고 선언이 안된 체로 사용이 되었으니 말이다.</p>
<p>코딩 인터뷰에나 나올 만한 이 문제는 우리가 일반적으로 JavaScript를 처음 접할 때의 난해함으로 다가온다.<br>블럭이 스코프를 결정하지 않는다니. 기상 천외한 언어라고 볼 수 있다.<br>하지만 이렇게 함으로써 브라우저 상에서 사람들이 처음 HTML 스펙과 적절히 섞을 수 있도록 사용 되었고(script 태그가 여기 저기서 얼마나 많이 import 되고 있는지 생각해 보라.) 이 호이스팅과 전역변수를 활용한 팁들도 생겨나기 시작했다.</p>
<p>하지만 지금의 상황은 자바스크립트의 코드베이스가 예전과는 상상도 할 수 없을만큼 커져버렸다.<br>전역변수를 사용한다는 것은 점점 죄악시 되어가고 있고, 좋은 패턴도 아니다.</p>
<h3 id="3-비동기-함수에서의-변수-사용"><a href="#3-비동기-함수에서의-변수-사용" class="headerlink" title="3. 비동기 함수에서의 변수 사용"></a>3. 비동기 함수에서의 변수 사용</h3><p>아래의 코드를 살펴보면 비동기 함수의 경우는 변수가 내가 원하는 시점과 원하는 바가 다르게 나올 때가 있다는 것을 파악할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(numbers[i]);</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//결과는 undefined가 세번 나온다.</span></div></pre></td></tr></table></figure></p>
<p>물론 저런 코드가 프로젝트에서 사용되어질 리는 없지만 setTimeout이 아니라 AJAX 호출이라고 생각해 보자.<br>JavaScript가 눈에 익은 사람은 저 코드가 굉장히 당연하게 느껴지겠지만 콜백함수라던지 받아서 실행해야 하는 경우라면<br>코드에 대한 명확한 스펙을 알고 있더라도 실수할 수 있는 여지는 많아진다.</p>
<h2 id="let-const-에-대한-오해"><a href="#let-const-에-대한-오해" class="headerlink" title="let, const 에 대한 오해"></a>let, const 에 대한 오해</h2><p>이해도 하기 전에 오해를 이야기 하니 무슨 이야기인가 싶을 수도 있겠으나 ES2015 의 스펙이 나오면서 let 과 const 가 어떤 전역변수와 지역변수를 해결하는 전가의 보도처럼 이야기 되는 경우가 있어서 그런것 만은 아니라는 이야기를 먼저 하고 싶다.</p>
<p>여전히 ES2015에도 변수를 선언하지 않고 작업을 하면 함수 스코프를 따라 체이닝 작업(찾아보게 된다)을 통해 변수에 값을 할당하게 된다. 이것은 바꿀 수도 없고 바꿔서도 안된다고 보인다.<br>하지만 아래 코드를 보자. 위의 var로 선언한 코드에서 let 으로만 선언했을 뿐이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  x=<span class="number">3</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"inner"</span>,x);</div><div class="line">  <span class="keyword">let</span> x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>두가지의 결과가 다르게 나는데 var로 선언을 할 경우는 undefined 라는 값이 나오고( 에러가 아니다!)<br>let의 경우는 에러를 내뱉게 된다. (명시적인 에러를 뱉는 것과 undefined를 처리하는 것은 개발 차원에서 다뤄야 할 수준이 달라진다)</p>
<h3 id="let은-무엇이-다를까"><a href="#let은-무엇이-다를까" class="headerlink" title="let은 무엇이 다를까"></a>let은 무엇이 다를까</h3><p>앞서 언급했던 선언을 하지 않고 사용을 하면 에러가 나도록 설계가 되어 있다는 점이 일단 이야기가 되어지고 두번째는 반복문 안에서 비동기 동작이 다르게 작동한다.  </p>
<p>이 부분도 코드를 먼저 보자. 먼저 소개한 코드에서 var를 let으로 바꿨을 뿐이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(numbers[i]);</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>개인적으로 이 부분은 조금 더 헷갈리게 된 것 같다. 비동기의 경우 var처럼 처리 되던것을 기본으로 생각해오던 JavaScript 개발자들에게는 오히려 혼란스럽게 다가올 수 있을 것으로 보이지만 이제는 비동기 때 변수가 따로놀지 않는 상황을 let으로 작성하면 만들 수 있다는 점에서 의미가 있을 거 같다.</p>
<h3 id="const는-무엇이-다를까"><a href="#const는-무엇이-다를까" class="headerlink" title="const는 무엇이 다를까"></a>const는 무엇이 다를까</h3><p>다른 언어와 마찬가지로  const의 경우는 다시 할당하지 않는 상수의 역할을 한다. const 의 경우는 재할당 하려고 하면 에러가 난다.<br>let 과 비교하면 값을 재할당 할 수 없는 것 딱 한가지 말고는 다를 바가 없다.</p>
<h2 id="이제는-무조건-let-const다-외워라"><a href="#이제는-무조건-let-const다-외워라" class="headerlink" title="이제는 무조건 let, const다. 외워라."></a>이제는 무조건 let, const다. 외워라.</h2><p>브라우저는 지속적으로 발전하고 있고 그에 따른 성능도 올라가지만 한가지 확실한 것은 표준 스펙에 대한 성능은 언제나 일순위라는 것이다.<br>그 과정에서 let, const 는 기존의 var를 완전히 대체할 수 있는 뉴 스탠다드다. 현재는 var 가 아주 조금 (그것도 아주 조금) 성능적인 우위를 점하고 있지만 장기적으로 let, const 와의 성능은 거의 차이가 없어질 것으로 (오히려 더 나아질 것으로) 예상된다.</p>
<p>실제 진행한 것을 블로그에 포스팅한 사례도 속속 나오고 있다.</p>
<p>성능 비교 : <a href="https://gomugom.github.io/let-vs-var-performance-compare/" target="_blank" rel="external">https://gomugom.github.io/let-vs-var-performance-compare/</a></p>
<p>내용을 한 부분만 인용하면</p>
<blockquote>
<p>불과 1년 전 var와 let의 성능비교 테스트에 대한 블로그 포스팅을 읽은 적이 있는데, 당시에는 var가 let보다 압도적으로 빠르게 연산을 수행했던 것으로 기억한다. 그 1년 사이 둘의 성능은 같아졌다. 그만큼 최적화가 이루어져왔었기 때문이다. 그렇다면 앞서 확인했던 외부스코프에 대한 접근 성능 역시 점차 최적화가 될 것이라 기대한다.</p>
</blockquote>
<p>이 블로그 포스팅도 2017년 1월의 일이니 지금은 더 빨라졌을 것으로 보인다.</p>
<p>그리고 앞서 언급되어 있었던 부분 중의 하나인 에어비앤비의 사례에서도 보듯이 엔지니어링에서 표준을 따라 작업을 하는 것이 현재의 성능을 쫓아가는 것 보다 장기적으로 이득인 점도 간과할 수는 없다.</p>
<h2 id="프로젝트-리팩토링"><a href="#프로젝트-리팩토링" class="headerlink" title="프로젝트 리팩토링"></a>프로젝트 리팩토링</h2><p>이제는 standup 프로젝트를 한번 들여다 보자. ( github 페이지에 접속해서 standup 검색을 하거나 아래 URL을 클릭해서 들어가 보자. )</p>
<p><a href="https://github.com/ehrudxo/standup" target="_blank" rel="external">https://github.com/ehrudxo/standup</a></p>
<p>주소를 복사해서 git clone 명령을 통해 사용하고 있는 로칼 PC에 복사한 후에 가장 마지막 작업인 day7 을 체크아웃 받아 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$git</span> <span class="built_in">clone</span> https://github.com/ehrudxo/standup &amp; <span class="built_in">cd</span> standup &amp; git chekcout day7</div></pre></td></tr></table></figure>
<p>이후 editor 를 구동시킨 후에 탐색기를 열고 프로젝트에서 var를 검색해 보자. 다음 8개의 파일이 var로 이루어져 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">REAMDE.md</div><div class="line">src/__tests__/CloudDao.js</div><div class="line">src/actions/Article.js</div><div class="line">src/config.js</div><div class="line">src/Editor.js</div><div class="line">src/FileUtil.js</div><div class="line">src/FirebaseDao.js</div><div class="line">src/Login.js</div></pre></td></tr></table></figure>
<p>이 중 README.md 파일은 다른 파일을 설명하면서 만든 파일이므로 나머지 파일을 바꾸고 리팩토링 해 보자. 먼저 FileUtil.js를 살펴보면<br>storageRef 와 ulpoadTask 가 var 로 지정되어 있다. 그런데, storageRef 를 살펴보니 다른데서 사용하고 있지 않다.  uploadTask만 재사용 되므로 storageRef는 삭제하고 uploadTask는 다시 값이 할당되지 않으므로 const로 변경 해보자.</p>
<p>이번에는 src/actions/Article.js 를 살펴 보자. 이번에는 독자들을 위해 코드 스니펫을 가지고 와서 확인해 보도록 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArticles</span>(<span class="params">articles</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> items = [];</div><div class="line">  articles.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">article</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> item = article.val();</div><div class="line">    item[<span class="string">'key'</span>] = article.key;</div><div class="line">    items.push(item);</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">if</span>(items &amp;&amp; items.length&gt;<span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">      type : ALL,</div><div class="line">      articles : items.reverse()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>여기서 items 는 push 명령어를 통해서 지속적으로 변경이 되니까 let으로 지정을 해야 할 것 같지만 참조형은 변경이 가능하므로 const 를 사용한다.<br>그리고 item 도 다시 할당하지 않으므로 모두 const 로 변경한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArticles</span>(<span class="params">articles</span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> items = [];</div><div class="line">  articles.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">article</span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> item = article.val();</div><div class="line">    item[<span class="string">'key'</span>] = article.key;</div><div class="line">    items.push(item);</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">if</span>(items &amp;&amp; items.length&gt;<span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">      type : ALL,</div><div class="line">      articles : items.reverse()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>이 후 나머지는 독자들이 변경해 보도록 하자.<br>그리고 제대로 동작하는지 확인하려면 다음의 명령어를 실행해 보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$npm</span> install &amp; npm start</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 는 언제나 쉽지만 또 언제나 어렵다.&lt;br&gt;이런 개념을 처음 갖게 된게 아마도 변수가 내가 생각하는데로 작동하지 않던 시점이었던 것으로 기억한다.&lt;br&gt;개념이 생기기 전에 var를 변수 선언 해도 작동이 되고 생략해도 작동이 
    
    </summary>
    
    
      <category term="JavaScript, Refactoring" scheme="http://keen.devpools.kr/tags/JavaScript-Refactoring/"/>
    
  </entry>
  
  <entry>
    <title>(tech-trend) 구루들이 찾는다는 테크 트렌드 - 해커뉴스</title>
    <link href="http://keen.devpools.kr/2017/07/07/tech-trend-02/"/>
    <id>http://keen.devpools.kr/2017/07/07/tech-trend-02/</id>
    <published>2017-07-07T10:00:00.000Z</published>
    <updated>2017-08-06T07:12:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>이 글은 회사 기술 블로그에 올리고 있는 내용입니다.<br>회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기가 다음번 이야기가 될 거 같습니다.</p>
<p>필자는 SDS Agile Core Team 에서 테크리드를 담당하고 있습니다.<br>OSGeo에서 오픈소스 활동을 하고 있습니다. 잘 모르는 기술에 대해서 낯선 사람들과 이야기 하면서 배워 나가는 것을 좋아합니다.</p>
</blockquote>
<h2 id="기술-트렌드에-관련해서-2-hacker-news"><a href="#기술-트렌드에-관련해서-2-hacker-news" class="headerlink" title="기술 트렌드에 관련해서 - 2. hacker news"></a>기술 트렌드에 관련해서 - 2. hacker news</h2><h3 id="클리앙"><a href="#클리앙" class="headerlink" title="클리앙"></a>클리앙</h3><p>한국에 Tech 커뮤니티 중에 유명한 곳으로 클리앙이라는 곳이 있다. 시대를 풍미했던 소니 PDA의 제품명을 따서 그 때 활동했던 전문가들이 만든 커뮤니티 사이트인데 왠만한 개발자나 덕질 좀 하는 사람들이라면 클리앙의 모공은 가지 않더라도 새로운 뉴스는 방문하는 것으로 알고 있다. 커뮤니티에 참여한 사람들이 가지고 오는 뉴스들이 다른 포탈 보다 좋은 점은 몇가지가 있는데 그 중에서도 취향이 비슷한 사람들이 몰린다는 것과 트렌드를 정확히 반영한다는 것. 그리고 댓글들을 통해 판단할 근거들을 파악할 수 있다는 것을 뽑을 수 있을 것이다.<br><img src="/images/clien.jpg" alt="클리앙"></p>
<h3 id="폴-그레이엄"><a href="#폴-그레이엄" class="headerlink" title="폴 그레이엄"></a>폴 그레이엄</h3><p>해커뉴스는 처음 들어보았을 수도 있겠지만 IT 분야에서 일한다고 하면 폴 그레이엄이라는 사람의 이름은 많이 들어봤을 것이다. 폴 그레이엄은 투자가이면서도 SNS 상의 수퍼스타면서 “<a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B6957684739" target="_blank" rel="external">해커와 화가</a>“라는 좋은 책을 쓴 사람이기도 하다. (한빛 미디어. 번역 임백준)<br>이 폴그레이엄의 Ycombinator 에서 news 서비스를 커뮤니티를 활용해서 하고 있는데 클리앙과 매우 흡사하다. 하지만 여기는 조금 더 전문적인 영역까지 다루고 있다.<br><img src="/images/paul.jpg" alt="폴 그레이엄"></p>
<p>폴 그레이엄의 ~ 시리즈는 구글 검색만 해도 국내 언론도 굉장히 많이 언급하고 있음을 알 수 있다.</p>
<p><img src="/images/paulsays.jpg" alt="폴 그레이엄의"></p>
<h3 id="해커뉴스"><a href="#해커뉴스" class="headerlink" title="해커뉴스"></a>해커뉴스</h3><p>이 해커뉴스가 돌아가는 방식은 좋아요를 많이 받을 수록 최상위에 배치되는 것 + 날짜 의 합으로 운영이 되는데 URL을 통해 데이타를 긁어오는 방법이 한참 유행했었는데 요즘에는 Firebase 와 함께 협업해서 API를 제공해 주는 서비스까지 제공해 주고 있다. ( 긁어가는 것도 대인배. 알아들 긁어가시는데 고생하시지 말고 알아서 긁어들 가시라고. )<br><img src="/images/hackernews.jpg" alt="해커 뉴스"></p>
<p><a href="https://news.ycombinator.com/" target="_blank" rel="external">해커뉴스 - https://news.ycombinator.com/</a></p>
<p><a href="https://github.com/HackerNews/API" target="_blank" rel="external">해커뉴스 API - https://github.com/HackerNews/API</a></p>
<p>굉장히 많은 사람들이 몰리는 것과 빠른 트렌드를 반영하는 것과 더불어 모든 뉴스를 다 읽기에는 하루가 모자랄 지경이라 좋은 뉴스를 선별해서 볼 수 있도록 해주는 서비스도 많은데 이 중에서 좋은 것 하나를 선택하면 최신 트렌드가 어떻게 돌아가는지를 놓치지 않고 읽어볼 수 있다.</p>
<h4 id="1-hacker-news-twitter"><a href="#1-hacker-news-twitter" class="headerlink" title="1. hacker news twitter"></a>1. hacker news twitter</h4><p><a href="https://twitter.com/search?f=users&amp;vertical=default&amp;q=hacker%20news&amp;src=typd" target="_blank" rel="external">트위터 서비스들</a></p>
<p><img src="/images/twitters.jpg" alt="해커뉴스 트위터들"></p>
<p>이중에서 가장 처음에 올라온 것만 개인적으로 팔로우 하고 있지만 시간이 된다면 차이점을 파악해서 잘 선택하시는 것이 도움이 될 것으로 보인다.</p>
<h4 id="2-hacker-news-newsletter"><a href="#2-hacker-news-newsletter" class="headerlink" title="2. hacker news newsletter"></a>2. hacker news newsletter</h4><p>이메일로 뉴스레터로 보내주는 서비스를 하는 것도 있다.<br><a href="http://www.hackernewsletter.com/" target="_blank" rel="external">http://www.hackernewsletter.com/</a><br>이메일을 제출하면 해당 메일주소로 확인메일이 날라오고, 그 메일에 확인 버튼을 눌러 구독을 확정지을 수 있다.</p>
<h4 id="3-Mobile-apps"><a href="#3-Mobile-apps" class="headerlink" title="3. Mobile apps"></a>3. Mobile apps</h4><p>앱스토어나 구글 플레이에서 hacker news 라고 검색을 하면 해당 앱이 스크롤을 다 채울만큼 나오는 것을 확인할 수 있다.</p>
<h3 id="영알못이라구요"><a href="#영알못이라구요" class="headerlink" title="영알못이라구요?"></a>영알못이라구요?</h3><p>언어적인 어려움이 당연히 존재를 하는데, 이런 경우는 국내에서 트렌드 서비스를 하고 있는 몇몇 블로거들을 통해서 관련 내용들을 얻을 수 있는데, 유명한 기술 트렌드를 서비스 해주는 사람으로는 outsider 와 nolboo 가 유명하다. 국내에서 트렌드 서비스를 해 주는 경우는 다음번에 알아보도록 하겠다.</p>
<h2 id="7월의-프로젝트-Best-websites-a-programmer-should-visit"><a href="#7월의-프로젝트-Best-websites-a-programmer-should-visit" class="headerlink" title="7월의 프로젝트 - Best-websites-a-programmer-should-visit"></a>7월의 프로젝트 - Best-websites-a-programmer-should-visit</h2><p>7월 7일 현재 한달동안(6/8부터) 가장 Star(좋아요)를 가장 많이 받은 프로젝트는 <a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit" target="_blank" rel="external">“Best-websites-a-programmer-should-visit”</a> 이다. </p>
<p><img src="/images/bestwww.jpg" alt="best"></p>
<p>작년 한해 동안은 awesome 시리즈가 유명했는데 awesome 시리즈는 예를 들어 tensorflow와 관련해서 괜찮은 사이트나 문서를 모아놓은 markdown 파일을 만들어 놓고 링크를 걸어 놓고 찾아가기 좋은 즐겨찾기를 하는 형식이다.<br>ex) <a href="https://github.com/jtoy/awesome-tensorflow" target="_blank" rel="external">awesome tensorflow</a><br>awesome tensorflow 만해도 8000개의 star를 받았다. </p>
<p>올해는 약간 네이밍에 질려하는 분위기인 것 같지만 즐겨찾기는 언제나 도움이 되니까 다들 star 버튼을 누르는게 즐겨 찾기용으로 사용되는 것을 알 수 있다.</p>
<p>처음 시작은 when you get stuck 섹션으로 시작한다. 한국말로 해석하면 “~을 하다가 막혔을때” 라는 것보다 더 적절한 해석이 없을 거 같은데 Stack Overflow 와 Quora 는 당연히 소개가 되어 있고 나머지 세군데는 한번 살펴 보는 것도 괜찮아 보인다.</p>
<p>두번째는 뉴스인데 당연히 처음부터 Hacker news 가 나온다. 관련된 사이트만도 두개가 더 있다. </p>
<p><img src="/images/bestnews.jpg" alt="bestnews"></p>
<p>이렇게 프로젝트를 잘 정리해 놓은 사이트는 늘 깃헙의 베스트 단골 메뉴인데 적어도 한달 단위로 올라오는 트렌딩에서는 참조할 만하다. 개발자들이 꼭 참조해야할 사이트가 이렇게 많았다는 것도 놀랍지만 이제는 이런 사이트에서 공통으로 나오는 이야기들을 잘 모아서 보여주는 서비스를 한번 기획해 보는 것도 굉장히 유익해 보인다.<br>혹시 같이 할 사람 있다면 언제든지 연락주면 같이 해 보고 싶다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;이 글은 회사 기술 블로그에 올리고 있는 내용입니다.&lt;br&gt;회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기가
    
    </summary>
    
    
      <category term="tech trend, hacker news" scheme="http://keen.devpools.kr/tags/tech-trend-hacker-news/"/>
    
  </entry>
  
  <entry>
    <title>feedwordpress를 설치하다</title>
    <link href="http://keen.devpools.kr/2017/06/09/feedwordpress/"/>
    <id>http://keen.devpools.kr/2017/06/09/feedwordpress/</id>
    <published>2017-06-09T12:34:46.000Z</published>
    <updated>2017-06-09T12:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>atom, rss 를 지원해 주는 feedwrodpress 를 설치했다.<br>잘 활용될 수 있으면 좋을 듯하다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;atom, rss 를 지원해 주는 feedwrodpress 를 설치했다.&lt;br&gt;잘 활용될 수 있으면 좋을 듯하다.&lt;/p&gt;

    
    </summary>
    
    
      <category term="atom,rss" scheme="http://keen.devpools.kr/tags/atom-rss/"/>
    
  </entry>
  
  <entry>
    <title>헤드리스 크롬과 selenium2의 조합을 사용해 보자 with node</title>
    <link href="http://keen.devpools.kr/2017/06/07/about-test/"/>
    <id>http://keen.devpools.kr/2017/06/07/about-test/</id>
    <published>2017-06-07T04:31:34.000Z</published>
    <updated>2017-06-08T06:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>최근에 headless chrome 이 나름 화제가 되어서 돌았는데 이 headless 라는 의미가 어떻게 쓰이는지 잘 모르는 사람들을 위해 이야기를 하고 넘어갈까 한다.</p>
<h2 id="headless-browser"><a href="#headless-browser" class="headerlink" title="headless browser"></a>headless browser</h2><p>headless browser는 기본적으로 GUI 없는 웹 브라우저를 의미한다.  </p>
<blockquote>
<p>“A headless browser is a web browser without a graphical user interface.”<br>출처 : <a href="http://blog.arhg.net/2009/10/what-is-headless-browser.html" target="_blank" rel="external">What is a headless browser?</a></p>
</blockquote>
<p>즉 CLI(Command Line interface)에서만 다루는 브라우저를 이야기 한다.유명한 헤드리스 브라우저로는  phantomJS 가 있다.  </p>
<p>헤드리스 브라우저가 사용되는 예는 여러가지가 있는데 좋은 예로는 테스트 자동화를 할 수 있고 데이타를 긁어오기(scraping) 하는 데 사용되고 스크린샷을 뜨는데에도 손쉽게 사용된다. 웹페이지 반응을 자동으로 스크립팅할 수 있는 부분도 존재한다.나쁜 예로는 DDOS 공격을 하는데 사용되기도 하고, 자동화를 좋지 않은데에 쓰이기도 한다는 것이다.</p>
<h2 id="selenium은-어떻게-다른가"><a href="#selenium은-어떻게-다른가" class="headerlink" title="selenium은 어떻게 다른가"></a>selenium은 어떻게 다른가</h2><p>셀레니엄은 태생 자체가 다르다고 보면 된다. 헤드리스 브라우저는 범용적인 목적에 따라 CLI환경에서 브라우저 환경을 에뮬레이션 하는 것이라고 하면 selenium은 브라우저 플러그인을 넣고 테스트를 실행시킨다. 서버 사이드에서 테스트에 관련된 실행을 시킬 수 있는 리모트 컨트롤러가 존재하고 다양한 브라우저를 지원하기 위해 드라이버들을 제공하는데 webdriver 라고 불려진다. 이후 버전이 업데이트 되었다.  </p>
<p>클라이언트 서버 구조로 서버 사이드와 RC(Remote Control)로 구성되어 있던 것을 webdriver와 결합하면서 현재의 selenium2가 된 것이다.</p>
<p><img src="/images/seleniumhq.jpg" alt="selenium1 + webdriver = selenium2"></p>
<p>즉 CLI 툴로 사용할 수 있는 헤드리스 크롬의 경우는 다양한 브라우저를 테스트의 목적으로 사용해야 하는 범용 테스트 목적 보다는 다른 용도로 많이 사용될 것으로 보인다. <del>DDOS machine?</del></p>
<h2 id="자-그러면-node-환경에서-selenium2를-사용해-보자"><a href="#자-그러면-node-환경에서-selenium2를-사용해-보자" class="headerlink" title="자 그러면 node 환경에서 selenium2를 사용해 보자."></a>자 그러면 node 환경에서 selenium2를 사용해 보자.</h2><p>nightwatch 혹은 webdriverio는 node 환경에서 selenium2를 사용할 수 있게 해 준다. 옵션과 홈페이지, 구글 트렌드를 생각하면 nightwatch를 이용해야겠지만 일단 간단하게 사용하기 위해 webdriver로 실행을 해 보자.(robotframework도 같이 고려)</p>
<p>전역 옵션으로 webdriverio를 아래와 같이 설치한다.(nightwatch의 경우도 같이 진행할 수 있음.)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;npm install -g webdriverio</div></pre></td></tr></table></figure></p>
<p>selenium2는 다음과 같은 명령으로 내려받을 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;curl -O http://selenium-release.storage.googleapis.com/3.0/selenium-server-standalone-3.4.0.jar</div></pre></td></tr></table></figure></p>
<p>크롬용 웹드라이버 -chromedriver를 받아서 압축을 풀고 PATH에 적용 시켜 준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;curl -O https://chromedriver.storage.googleapis.com/index.html?path=2.29/chromedriver_mac64.zip</div></pre></td></tr></table></figure></p>
<h2 id="headless-chrome-을-설치-한다"><a href="#headless-chrome-을-설치-한다" class="headerlink" title="headless chrome 을 설치 한다."></a>headless chrome 을 설치 한다.</h2><p>이 경우는 며칠전만 해도 canary를 쓴다고 했지만 지금은 크롬 최신버전이면 다음의 옵션만으로 실행할 수 있다.(MacOS 의 경우)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; chrome --headless --disable-gpu --screenshot &quot;http://devpools.kr&quot;</div></pre></td></tr></table></figure></p>
<h2 id="테스트-코드-작성"><a href="#테스트-코드-작성" class="headerlink" title="테스트 코드 작성"></a>테스트 코드 작성</h2><p>아래와 같이 테스트 코드를 작성하고 나면 일단은 selenium2 기반의 테스트 프레임워크의 시작을 했다고 보면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//test.js</span></div><div class="line"><span class="keyword">var</span> webdriverio = <span class="built_in">require</span>(<span class="string">'webdriverio'</span>);</div><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">    desiredCapabilities: &#123;</div><div class="line">        browserName: <span class="string">'chrome'</span>,</div><div class="line">        chromeOptions: &#123;</div><div class="line">            args: [</div><div class="line">                   <span class="string">'headless'</span>,</div><div class="line">                   <span class="string">'disable-gpu'</span>,</div><div class="line">               ],</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">webdriverio</div><div class="line">    .remote(options)</div><div class="line">    .init()</div><div class="line">    .url(<span class="string">'http://www.devpools.kr'</span>)</div><div class="line">    .getTitle().then(<span class="function"><span class="keyword">function</span>(<span class="params">title</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Title was: '</span> + title);</div><div class="line">    &#125;)</div><div class="line">    .end();</div></pre></td></tr></table></figure>
<p>결과는 다음과 같다.</p>
<p><img src="/images/headlessscraping.jpg" alt="개발바보들의 타이틀을 긁어왔다"></p>
<p>해당 소스는 깃헙의 다음 링크에서 받아볼 수 있다.<br><a href="https://github.com/ehrudxo/headlesssample" target="_blank" rel="external">https://github.com/ehrudxo/headlesssample</a></p>
<p>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;최근에 headless chrome 이 나름 화제가 되어서 돌았는데 이 headless 라는 의미가 어떻게 쓰이는지 잘 모르는 사람들을 위해 이야기를 하고 넘어갈까 한다.&lt;/p&gt;
&lt;h2 id=&quot;headless-browser&quot;&gt;&lt;a href=&quot;#h
    
    </summary>
    
    
      <category term="web test, test suite, headless chrome, selenium" scheme="http://keen.devpools.kr/tags/web-test-test-suite-headless-chrome-selenium/"/>
    
  </entry>
  
  <entry>
    <title>(tech-trend) 기술트렌드에 대한 블로깅을 시작하며</title>
    <link href="http://keen.devpools.kr/2017/05/31/tech-trend-01/"/>
    <id>http://keen.devpools.kr/2017/05/31/tech-trend-01/</id>
    <published>2017-05-31T07:04:04.000Z</published>
    <updated>2017-08-06T07:12:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>이 글은 회사 기술 블로그에 올리고 있는 내용입니다.회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기가 다음번 이야기가 될 거 같습니다.</p>
<p>필자는 Agile Core Team 에서 테크리드를 담당하고 있습니다.<br>OSGeo에서 오픈소스 활동을 하고 있습니다. 잘 모르는 기술에 대해서 낯선 사람들과 이야기 하면서 배워 나가는 것을 좋아합니다.</p>
</blockquote>
<h2 id="기술-트렌드에-관련해서-1-github"><a href="#기술-트렌드에-관련해서-1-github" class="headerlink" title="기술 트렌드에 관련해서 - 1. github"></a>기술 트렌드에 관련해서 - 1. github</h2><p>개발자들이 기술 트렌드를 얻는 루트는 생각보다 많지는 않다. 소셜 미디어에서 유명한 개발자들을 팔로우 하거나 그룹에 가입하는 방법들이 많은데, <u><strong>필자가 주로 기술 트렌드를 얻는 되는 루트는 github 과 hacker news다</strong></u>. 물론 기술 트렌드를 얻는 방법은 여러가지다. 오늘은 먼저 github 에서 어떻게 기술 트렌드를 따라갈 수 있는지에 대해서 이야기를 잠깐 언급하고 현재 핫한 프로젝트 하나를 소개하고자 한다.</p>
<p>이 글을 읽게 될 대부분의 독자들은 아마도 github를 잘 알고 있으리라고 생각이 든다.  하지만, 그럼에도 불구하고 윤석찬 님이 정의하신 깃허브에 대해서 다시 한번 상기 하고자 한다</p>
<blockquote>
<p>“gitHub는 한마디로 ‘소셜 소스 코드 공유’를 모토로 한 분산형 협업 개발 호스팅 서비스 입니다. 생소한 개념 같지만 한마디로 ‘오픈 소스 개발 모델’에다가 요즘 한창 유행인 ‘소셜 네트웍’을 접목했다고 보시면 됩니다.”</p>
</blockquote>
<ul>
<li>출처 : <a href="http://channy.creation.net/blog/626#.WS_iOBPyib8" target="_blank" rel="external">http://channy.creation.net/blog/626#.WS_iOBPyib8</a></li>
</ul>
<p>현재 유명한 오픈 소스는 거의 대부분 이 github 안에 서식하고 있다고 보면 될 정도로 압도적인 곳이다. 이 곳에서 우리는 많은 개발자들이 어떤 프로젝트를 좋아하고 팔로우 하는지를 알아 볼 수 있는데 지금은 첫 메뉴에서 링크로 보이지는 않지만 내가 주로 찾는 URL은 아래와 같다.</p>
<ul>
<li>깃헙 트렌드 : <a href="https://github.com/trending" target="_blank" rel="external">https://github.com/trending</a></li>
</ul>
<p>한번에 25개 정도의 결과를 지금 핫한 프로젝트와 개발자를 리스팅해서 보여준다.</p>
<p><img src="/images/github.jpg" alt="깃허브 메인 페이지"></p>
<p>오른쪽 콤보 박스를 이용해서 일간, 주간, 월간 결과를 나누어서 확인할 수 있다.<br>필자는 이런 내용이 너무 좋아서 팀원들과 <a href="https://github.com/TeamSEGO/github-trend-kr" target="_blank" rel="external">https://github.com/TeamSEGO/github-trend-kr</a> 같은 페이지를 운영했던 적이 있다. 그리고 <a href="https://techstory.shma.so/" target="_blank" rel="external">https://techstory.shma.so/</a> 에 한참동안 <strong>매일 깃헙</strong> 이라는 형태의 블로깅을 하곤 했었다. 이런 활동들이 주는 유익한 점은 개인적으로 개발 트렌드를 파악하는 데에 굉장한 도움을 주고 다음에 무엇을 준비할 지 알 수 있는 자양분이 되었다.</p>
<p>굳이 이런 활동을 하지 않아도 이런 내용을 확인할 수 있는 방법들이 있다.  <a href="https://github.com/trending" target="_blank" rel="external">https://github.com/trending</a> 페이지를 직접 방문하거나 아니면 구글 플레이나 앱스토어에 github 이라고 치면 트렌트를 확인할 수 있는 앱들이 굉장히 많다.</p>
<p><img src="/images/mgithub.png" alt="깃헙 관련 앱들"></p>
<p><u>25개나 되는 프로젝트에서 무엇을 보면 좋을까.</u><br>필자의 경험 상으로는 시작할 때는 다음의 원칙을 지키면 유익했던 것 같다. <strong>먼저 daily와 weekly 는 보지 않을 것.</strong> 매일 좋아요(깃허브에서는 스타)를 많이 받는 프로젝트는 굉장히 많이 바뀐다. 하지만 하루 반짝하는 프로젝트는 굉장히 많다. 이런 것들은 과감히 보지 않고 <strong>monthly를 선택하고 리스트를 주욱 훑어 보는 것이 첫번째다.</strong> 두번째는 본인이 아는 회사나 그룹의 프로젝트만 챙겨본다. 예를 들어 google, facebook, spring 같은 애들이 오면 꼼꼼하게 챙겨본다. 마지막으로 본인이 아는 언어를 사용한 프로젝트를 챙겨본다. 모든 언어를 다 섭렵할 수는 없는 노릇이고 내가 익숙한 내용들부터 챙겨봐도 다 보기가 쉽지 않다. 오늘 소개할 prepack이라는 프로젝트는 위의 순으로 내가 선택한 프로젝트다. (차후 설명)</p>
<p>선택하고 나면 (클릭해서 해당 페이지로 이동) 프로젝트 메인 페이지로 들어갈 수 있다. 깃헙 프로젝트 메인페이지는 기본적으로 프로젝트의 파일 리스트와 소개로 크게 나뉘어져 있다. 파일 리스트는 일반적으로 master 브랜치에 담긴 파일들을 보여준다. 소개는 리드미(Readme) 파일로 작성이 되어 있고 깃허브에서 기본적으로 리드미 파일은 마크다운 형식을 따른다.</p>
<p><u>리드미 파일에 대한 소개는 art of readme를 번역해서 소개한 부분을 인용한다.</u></p>
<ul>
<li>이름 — 이름이 무엇보다 중요합니다. react-router라는 이름은 이름만으로 무슨 프로젝트인지 알 수 있으니까요</li>
<li>한줄 요약 — 이름이 중요한 것 처럼 한줄로 이 프로젝트의 정체성을 나타내 주는 것이 좋습니다</li>
<li>사용법 — API 문서로 바로 가는 것보다 사용법을 설명해 주는 것이 좋습니다.</li>
<li>API — 이름, 설명, 사용법이 보여지고 나면 API의 상세함이 프로젝트의 품격을 결정합니다</li>
<li>설치방법 — 자, 이제 전체를 읽어봤으니 어떻게 설치할 지를 알 수 있어야 사용자가 마지막 결정을할 수 있습니다.</li>
<li>라이센스 — 이 프로젝트를 내가 사용할 수 있는지에 대한 중요한 정보를 담고 있죠.  </li>
</ul>
<p>art of readme 링크 : <a href="https://github.com/noffle/art-of-readme" target="_blank" rel="external">https://github.com/noffle/art-of-readme</a><br>소개 링크 : <a href="https://techstory.shma.so/art-of-readme-cd19f86b0456" target="_blank" rel="external">https://techstory.shma.so/art-of-readme-cd19f86b0456</a>  </p>
<p>이렇게 프로젝트들을 매일 매일 정복해 나가다 보면 최신 개발 트렌드를 파악하기에 매우 유용하다. 이 방법은 의외로 시간을 많이 소모하는 방법이기 때문에 시간을 절약하기 위해서 사용하는 다른 몇가지 방법들을 다음번에 이야기 하도록 하고 오늘은 새로운 프로젝트를 하나 소개하려고 한다.</p>
<h2 id="6월의-첫-프로젝트-prepack"><a href="#6월의-첫-프로젝트-prepack" class="headerlink" title="6월의 첫 프로젝트 - prepack"></a>6월의 첫 프로젝트 - prepack</h2><p><img src="/images/prepack01.png" alt="prepack"><br>깃허브 링크 : <a href="https://github.com/facebook/prepack" target="_blank" rel="external">https://github.com/facebook/prepack</a><br>홈페이지 링크 : <a href="https://prepack.io/" target="_blank" rel="external">https://prepack.io/</a>  </p>
<p>facebook에서 최근에 prepack이라는 프로젝트를 공개했다.<br>이 프로젝트는 JavaScript를 작성하고 나면 최적화한 소스 코드로 변경시켜주는 역할을 할 것을 목표로 지금 개발 중에 있으며 이미 어느 정도의 코드는 변경이 가능하고 시연도 가능한 형태로 공개가 되어 있다.</p>
<p>예를 들어 보면 다음 처럼 코드를 작성해 보자<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'hello'</span>; &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">world</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'world'</span>; &#125;</div><div class="line">  global.s = hello() + <span class="string">' '</span> + world();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>hello world를 출력하는 소스지만 조금 비효율 적으로 보인다. prepack이 어떻게 변환하는지를 살펴보자.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  s = <span class="string">"hello world"</span>;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>우리가 원하는 것처럼 간결하게 줄여준다!  </p>
<h4 id="기술적-배경-설명"><a href="#기술적-배경-설명" class="headerlink" title="기술적 배경 설명"></a>기술적 배경 설명</h4><p>최근에 소스코드를 변경해주는 작업들을 하는 오픈 소스들이 많다. 예를 들어 타입스크립트라던지, ES2015를 브라우저에 맞춰 변경해 준다던지 등의 compile 혹은 transpile 로 대변되기도 하지만 꼭 하나의 용어로만은 꼬집어 말할 수 없는 일련의 작업들이 JavaScript에서는 일어나고 있다. 기존 JavaScript가 어려운 것도 하나의 이유지만 개발자들의 소스코드가 일정 품질에 도달하지 못하는 것도 그 원인 중에 하나라고 보여진다.</p>
<p><img src="/images/babel01.png" alt="babel"></p>
<p>가장 주목을 받았던 프로젝트는 Babel 이라는 프로젝트인데 이 프로젝트는 보통 ES2015로 코드를 짜면 기존 ES5의 JavaScript로 변환해 주는 일들에 많이 사용되었다. 이유는 브라우저 호환성 때문인데 구형 브라우저에서 이해하지 못하는 최신 JavaScript 문법에 맞춰서 코드를 구형 브라우저에서 이해하도록 바꿔주는 역할 들을 했다. 이 Babel 에서 사용하는 AST(Abstract Syntax Tree) 기술을 이용해서 자바스크립트를 이해(parsing)하고 소스코드를 만들어 내었다.</p>
<p>아래 코드를 보자.<br>출처 : <a href="http://resources.jointjs.com/demos/javascript-ast" target="_blank" rel="external">http://resources.jointjs.com/demos/javascript-ast</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">5</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addA</span>(<span class="params">d</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> a + d;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = addA(<span class="number">2</span>) + b;</div></pre></td></tr></table></figure>
<p>이렇게 만들어진 코드를 AST 로 변환을 하면 아래 형태 처럼 만들어진다.  </p>
<p><img src="/images/AST01.png" alt="AST"></p>
<p><code>이 visualization 을 위해서는 Esprima 와 JointJS를 사용했다.</code></p>
<h4 id="어떻게-사용할-것인가"><a href="#어떻게-사용할-것인가" class="headerlink" title="어떻게 사용할 것인가"></a>어떻게 사용할 것인가</h4><p>설치는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;npm install -g prepack</div></pre></td></tr></table></figure>
<p>소스 코드를  helloprepack.js 라고 작성했을 경우는 아래와 같이 실행한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;prepack helloprepack.js</div></pre></td></tr></table></figure></p>
<p>다른 코드로 변경하기 위해서는 아래와 같이 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;prepack helloprepack.js --out helloprepack_new.js</div></pre></td></tr></table></figure></p>
<h3 id="어떤-의미가-있을까"><a href="#어떤-의미가-있을까" class="headerlink" title="어떤 의미가 있을까"></a>어떤 의미가 있을까</h3><p>Babel 의 경우는 사용된 분야가 아무래도 JavaScript가 빠르게 스펙이 올라가는 것을 쫓아가기에 주요하게 사용되었다고 하면 JavaScript VM이 이해하기 더 빠른 코드로 변경하는 역할을 장기적으로 목표로 가지고 작업할 수 있을 것 같다.</p>
<blockquote>
<p>이런 비슷한 일을 하고 있는 코드중에 하나가 asm.js 와 WebAssembly 가 있는데 기계어에 가깝게 코드가 짜여질 수록 브라우저에서 더 빠른 성능을 위한 또 하나의 로드맵으로 보여진다.</p>
</blockquote>
<ul>
<li>링크 : <a href="http://devpools.kr/2017/01/21/webassembly-binaryen-emscripten/" target="_blank" rel="external">WebAssembly – hello world 어셈블리를 브라우저에 올려보자</a></li>
</ul>
<p>사이트의 중간 로드맵에서도 같은 이야기를 하고 있다.<br>최종 목표로는 플랫폼처럼 사용하고 싶고 분석과 자동 테스트 코드 작성까지 보고 있다.  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;이 글은 회사 기술 블로그에 올리고 있는 내용입니다.회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기가 다음번
    
    </summary>
    
    
      <category term="chatbot, experience" scheme="http://keen.devpools.kr/tags/chatbot-experience/"/>
    
  </entry>
  
  <entry>
    <title>챗봇 프로젝트를 진행하면서 알게 된 사실들</title>
    <link href="http://keen.devpools.kr/2017/05/30/%5B2017-05-30%2023:19:43%5D%E1%84%8E%E1%85%A2%E1%86%BA%E1%84%87%E1%85%A9%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%92%E1%85%A2%E1%86%BC%E1%84%92%E1%85%A1%E1%84%86%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A5%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A6%20%E1%84%83%E1%85%AC%E1%86%AB%20%E1%84%89%E1%85%A1%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%B3%E1%86%AF/"/>
    <id>http://keen.devpools.kr/2017/05/30/[2017-05-30 23:19:43]챗봇 프로젝트를 진행하면서 알게 된 사실들/</id>
    <published>2017-05-30T14:19:43.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/0*cUkbr04Um53uekAF.jpg" alt="AI vs Human Brain"></p>
<p>AI vs Human Brain<br>최근 급하게 프로젝트에 두달간 투입이 되면서 블로그 포스팅을 할 여유가 전혀 없었다.<br>좀 반성하는 차에 진행한 프로젝트에서 얻은 인사이트를 공유하고자 한다.</p>
<h4 id="챗봇을-위한-디자인-원칙들이-속속-나오고-있다"><a href="#챗봇을-위한-디자인-원칙들이-속속-나오고-있다" class="headerlink" title="챗봇을 위한 디자인 원칙들이 속속 나오고 있다."></a>챗봇을 위한 디자인 원칙들이 속속 나오고 있다.</h4><p>어떤 절대적인 가이드라인은 사실 없기 때문에 마음대로 만들 수는 있고 마음대로 기획할 수는 있지만 많은 경우에 지금 활용할 수 있는 가이드라인들은 존재한다. 이른바 먼저 가본 사람들이 적어 놓은 가이드 라인들이 있다.</p>
<p>여기 가장 유명한 두개의 가이드라인만 소개를 할까 한다.</p>
<ol>
<li><a href="https://medium.muz.li/the-ultimate-guide-to-chatbots-why-theyre-disrupting-ux-and-best-practices-for-building-345e2150b682" target="_blank" rel="external">궁극가이드 — 9가지 원칙이라고 국내에는 알려져 있는…</a></li>
</ol>
<ul>
<li>사용자에게 거짓말하지 않는다 (봇이라고 알려라!)</li>
<li>대화를 유도하라</li>
<li>사용자의 감성을 고려해 디자인한다</li>
<li>대화에 제한을 두지 않는다(지속적으로 개선하라!)</li>
<li>경계를 만든다 (사람들이 몰입할 수 있는 경계를 쳐 주라)</li>
<li>사람들을 실망시킬 때는 조심하라</li>
<li>모든 인터랙션은 의미가 있다.(사용자가 이탈하는 부분을 정확히 트래킹하라)</li>
<li>사용자를 잘 도와줘야 시스템이 도움을 받는다.</li>
<li>사용자의 감정을 확인하고 감정을 목표점으로 한다.</li>
</ul>
<ol>
<li><a href="http://refreshstudio.tistory.com/entry/%EB%B4%87-%EB%94%94%EC%9E%90%EC%9D%B8bot-design%EC%9D%98-8%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99" target="_blank" rel="external">디자인 8원칙</a></li>
</ol>
<ul>
<li><strong>인간인 척 하지 말기</strong></li>
<li>단순함을 극도로 유지하기</li>
<li>채팅이라는 표현수단 이해하기</li>
<li>최종 사용자에게 맞추기</li>
<li>간단하게 응답하기</li>
<li>봇으로 안될 경우를 대비할 것</li>
<li>가능하면 구조적인 입력을 만들것</li>
<li>모두가 같은 것을 볼 것 (응답이 제각각이지 않을 것)</li>
</ul>
<p>이 중에서 가장 첫번째 원칙인 인간인척 하지 않는 것. 즉 사용자에게 사람인척 하지 않는 것이 중요한데 사람은 챗봇이라고 생각할 때와 사람이라고 생각할 때에 다르게 행동(입력)하고 기대하는 바도 매우 다르기 때문이다. 그래서 사람이 아닌 챗봇이라 버튼을 활용한다던지 다른 인터페이스에 대한 디자인을 하는 것은 무척이나 중요하다.</p>
<h4 id="인공지능에-대한-이해-보다-중요한-게-있다"><a href="#인공지능에-대한-이해-보다-중요한-게-있다" class="headerlink" title="인공지능에 대한 이해 보다 중요한 게 있다."></a>인공지능에 대한 이해 보다 중요한 게 있다.</h4><p><img src="/images/0*rYIrAKa51Aw1PBte.jpg" alt="사람"></p>
<p>사람<br>디자인 원칙에서 보았듯이 가장 중요한 원칙은 사람에 대한 이해다.<br>사용자가 어떻게 챗봇을 활용할 지를 이해하지 못하면 서비스가 제대로 쓸모 없는 서비스를 하게 마련이다. 그런 의미에서 아직은 인공지능과 사람의 인터페이스는 투박하다.<br>사용자가 어떻게 챗봇을 쓸 것인지를 정의하려면 내가 하려는 서비스가 어떤 것인지를 명확하게 정의해야 하고 어떤 기능을 대체를 하려는지를 기획자 혹은 개발자 스스로가 알고 있어야 한다.</p>
<h4 id="챗봇에-대한-기대는-굉장히-천차-만별이다"><a href="#챗봇에-대한-기대는-굉장히-천차-만별이다" class="headerlink" title="챗봇에 대한 기대는 굉장히 천차 만별이다."></a>챗봇에 대한 기대는 굉장히 천차 만별이다.</h4><p>사용자들과 인터뷰를 하다보면 정작 사용할 사용자들은 챗봇에게 큰 기대를 하지 않는다. 마치 우리가 시리와 빅스비에게 심드렁한 것 처럼. 하지만 기획단계에서의 기획자와 발안자들은 굉장히 많은 기대를 가지고 프로젝트에 접근한다.</p>
<p><strong>심지어 챗봇을 위한 디자인 원칙들을 읽어 보지도 않고 말이다.</strong> 챗봇들이 무엇인가 세상을 바꿀 것 처럼 굉장히 멋진 장표들과 아키텍처들을 보고 있지만 정작 이것이 어떤 문제를 해결할 지 알고 있는 사람은 없다.</p>
<p>개발을 진행하면서 이 프로젝트들이 꽤나 많은 분야의 인력에 대한 감축을 전제로 하고 그런 미래가 바로 닥쳐 있다는 사실을 부정할 수는 없지만 굉장한 청사진 또한 동의할 수 없다. 그래서 현실적이지 않은 요구사항들을 사용자 인터뷰와 가이드라인을 기준으로 다 잘라내고 있지만 의사 결정자들 마저도 굉장한 기대감을 가지고 있다는 사실은 어떻게 보면 슬픈 일이다.</p>
<p>하지만 심지어 페이스북과 같이 작업을 했던 항공 티케팅 분야의 챗봇 담당자는 이렇게 이야기 한다<br>“아무도 챗봇으로 티켓을 사려고 하지는 않아요.”</p>
<h4 id="개발의-대부분은-인공지능과-관련이-없다"><a href="#개발의-대부분은-인공지능과-관련이-없다" class="headerlink" title="개발의 대부분은 인공지능과 관련이 없다."></a>개발의 대부분은 인공지능과 관련이 없다.</h4><p>우리는 구글이 아니다. 이걸 인정하면 마음은 굉장히 편해지지만 대부분의 어른들(?)은 그걸 인정하기가 아들 딸 성적표보다 어려운 모양이다. 하지만 우리에게도 희망은 있다. 챗봇의 아키텍처에서 인공지능이 차지하는 부분은 우리가 기대하는 부분보다 굉장히 작다. 오히려 룰을 어떻게 만들고 어떻게 처리할 것인가 하는 부분이 훨씬 중요한 문제로 다가오게 된다.</p>
<h4 id="개발자는-그래서-또-너무나-중요하다"><a href="#개발자는-그래서-또-너무나-중요하다" class="headerlink" title="개발자는 그래서 또 너무나 중요하다."></a>개발자는 그래서 또 너무나 중요하다.</h4><p>위의 주제의 연속이다. 챗봇의 대부분은 소프트웨어 엔지니어의 영역이다. 그래서 챗봇 엔진을 잘 만들기 위해서는 좋은 엔지니어와 좋은 아키텍트가 당연히 필요하다. 물론 NLU라던지 딥러닝을 잘 하면 할 수록 더욱 좋다. 하지만 좋은 개발만큼 중요한 부분은 없다.</p>
<p>좋은 개발자는 여러가지 복잡하게 얽혀있는 챗봇의 어려움들을 풀어줄 시작과 마지막이다. 점점 인공지능의 세상이 오면 올 수록 사용자의 입장에서 이해하는 개발자가 더 중요해 질 것이다.</p>
<h4 id="우리는-기존의-레거시를-대체해야-한다"><a href="#우리는-기존의-레거시를-대체해야-한다" class="headerlink" title="우리는 기존의 레거시를 대체해야 한다."></a>우리는 기존의 레거시를 대체해야 한다.</h4><p><img src="/images/0*5vgnyq-ln8SBEbYO.jpg" alt="이렇게 죽어있는 레거시는 곤란하다"></p>
<p>이렇게 죽어있는 레거시는 곤란하다</p>
<p>상담이라던지, 견적이라던지 모든 챗봇이 풀고자 하는 문제들은 기존의 시스템이 자리잡고 있다. 그럼 이 레거시들을 어떻게 유기적으로 풀고 어떻게 서비스를 대체할 수 있을까? 마이크로 서비스 아키텍처는 그 중의 좋은 대답이 될 수 있다. 하지만 이것은 만병통치약은 아니다. 가장 중요한 것은 기존 레거시 함수를 묶어주는 표준을 만들어 주는 것이고 그 레거시를 어떻게 접근할지에 대한 해답은 챗봇이 가지고 있어야 한다.</p>
<p>그렇다면 사용자의 자연어와 레거시간의 연계는 어떻게 이루어 질 것인가. 여기에는 기존에 없던 인공지능 분야의 기술이 필요하다.</p>
<h4 id="과소-평가해서도-곤란하다"><a href="#과소-평가해서도-곤란하다" class="headerlink" title="과소 평가해서도 곤란하다."></a>과소 평가해서도 곤란하다.</h4><p><img src="/images/0*EHAkE0QhpD2tOPTZ.jp" alt="stay tuned"></p>
<p>stay tuned<br>이 쪽은 지속적으로 계속 발전할 것이다. 그렇다는 것은 지금 발을 들이기에 무척이나 좋은 시기라는 것이다.<br>아무래도 발전에 대한 틀은 대부분이 갖춰지는 것 같다.<br>누군가가 기가막힌 사용자 인터페이스를 제시할 것이고 그 때 쯤이면 아직까지는 기대할 것 없는 챗봇 분야의 인공지능도 수준이 많이 올라갈 것이다.<br>언제나 관심을 기울이고 있어야 한다는 이야기다.</p>
<hr>
<p><em>Originally published at </em><a href="http://devpools.kr/2017/05/30/%ec%b1%97%eb%b4%87-%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8%eb%a5%bc-%ec%a7%84%ed%96%89%ed%95%98%eb%a9%b4%ec%84%9c-%ec%95%8c%ea%b2%8c-%eb%90%9c-%ec%82%ac%ec%8b%a4%eb%93%a4/" target="_blank" rel="external"><em>개발바보들</em></a><em>.</em></p>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/179d67a9e2af" target="_blank" rel="external">May 30, 2017</a>.</p>
<p>Exported from <a href="https://medium.com" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/0*cUkbr04Um53uekAF.jpg&quot; alt=&quot;AI vs Human Brain&quot;&gt;&lt;/p&gt;
&lt;p&gt;AI vs Human Brain&lt;br&gt;최근 급하게 프로젝트에 두달간 투입이 되면서 블로그 포스팅을 할 여유가 전혀
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>챗봇 프로젝트를 진행하면서 알게 된 사실들</title>
    <link href="http://keen.devpools.kr/2017/05/30/20170530/"/>
    <id>http://keen.devpools.kr/2017/05/30/20170530/</id>
    <published>2017-05-30T07:04:04.000Z</published>
    <updated>2017-06-01T01:43:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ai001.jpg" alt="AI vs Human Brain"><br>최근 급하게 프로젝트에 두달간 투입이 되면서 블로그 포스팅을 할 여유가 전혀 없었다.<br>좀 반성하는 차에 진행한 프로젝트에서 얻은 인사이트를 공유하고자 한다.</p>
<h3 id="챗봇을-위한-디자인-원칙들이-속속-나오고-있다"><a href="#챗봇을-위한-디자인-원칙들이-속속-나오고-있다" class="headerlink" title="챗봇을 위한 디자인 원칙들이 속속 나오고 있다."></a>챗봇을 위한 디자인 원칙들이 속속 나오고 있다.</h3><p>어떤 절대적인 가이드라인은 사실 없기 때문에 누구나 마음대로 만들 수 있고 누구나 마음대로 기획할 수 있다.<br>하지만 지금 유용하게 활용할 수 있는 가이드라인들은 이미 존재한다. 먼저 진행해 본 사람들이 적어놓은 가이드 라인들이 있다.</p>
<p>여기 가장 유명한 두개의 가이드라인만 소개를 할까 한다.</p>
<ol>
<li><a href="https://medium.muz.li/the-ultimate-guide-to-chatbots-why-theyre-disrupting-ux-and-best-practices-for-building-345e2150b682" target="_blank" rel="external">궁극가이드 - 9가지 원칙이라고 국내에는 알려져 있는…</a><ul>
<li>사용자에게 거짓말하지 않는다 (<strong>봇이라고 알려라!</strong>)</li>
<li>대화를 유도하라</li>
<li>사용자의 감성을 고려해 디자인한다</li>
<li>대화에 제한을 두지 않는다(지속적으로 개선하라!)</li>
<li>경계를 만든다 (사람들이 몰입할 수 있는 경계를 쳐 주라)</li>
<li>사람들을 실망시킬 때는 조심하라</li>
<li>모든 인터랙션은 의미가 있다.(사용자가 이탈하는 부분을 정확히 트래킹하라)</li>
<li>사용자를 잘 도와줘야 시스템이 도움을 받는다.</li>
<li>사용자의 감정을 확인하고 감정을 목표점으로 한다.</li>
</ul>
</li>
<li><a href="http://refreshstudio.tistory.com/entry/%EB%B4%87-%EB%94%94%EC%9E%90%EC%9D%B8bot-design%EC%9D%98-8%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99" target="_blank" rel="external">디자인 8원칙</a><ul>
<li><strong>인간인 척 하지 말기</strong></li>
<li>단순함을 극도로 유지하기</li>
<li>채팅이라는 표현수단 이해하기</li>
<li>최종 사용자에게 맞추기</li>
<li>간단하게 응답하기</li>
<li>봇으로 안될 경우를 대비할 것</li>
<li>가능하면 구조적인 입력을 만들것</li>
<li>모두가 같은 것을 볼 것 (응답이 제각각이지 않을 것)</li>
</ul>
</li>
</ol>
<p>이 중에서 가장 첫번째 원칙인 인간인척 하지 않는 것(봇이라고 알려라). -사용자에게 사람인척 하지 않는 것- 이 다른 무엇보다 중요하다.<br>사용자는 챗봇이라고 생각할 때와 사람이라고 생각할 때에 다르게 행동(입력)하고 기대하는 바도 매우 다르기 때문이다.<br>그래서 사람이 아닌 챗봇이라고 생각하는 사용자를 위해서 버튼을 입력 도구로 활용한다 거나 또 다른 유용한 인터페이스를 활용한 소프트웨어 디자인을 하는 것은 무척이나 중요하다.</p>
<h3 id="인공지능에-대한-이해-보다-중요한-게-있다"><a href="#인공지능에-대한-이해-보다-중요한-게-있다" class="headerlink" title="인공지능에 대한 이해 보다 중요한 게 있다."></a>인공지능에 대한 이해 보다 중요한 게 있다.</h3><p><img src="/images/ai002.jpg" alt="사람"></p>
<p>앞서 기술한 디자인 원칙에서 보았듯이 가장 중요한 원칙은 사람에 대한 이해다.<br>사용자가 어떻게 챗봇을 이해하는 지와 사용할 지를 이해하지 못하면 서비스의 방향을 못찾고 방황하기 마련이다. 그런 의미에서 아직까지 나온 챗봇 서비스들의 인공지능과 사람간의 인터페이스는 투박하게만 보인다.<br><strong>사용자가 어떻게 챗봇을 쓸 것인지를 정의하려면</strong> 내가 만들고 있는 제품이 어떤 것인지를 명확하게 정의해야 하는 것이 첫번째고 어떤 pain point가 있어서 구체적으로 어떤 기능을 챗봇으로 대체 하려는 지를 기획자 혹은 개발자 스스로가 알고 있어야 한다.</p>
<p><strong>기존의 어떤 무언가를 대체하지 않고 새로운 시장을 창조하려는 경우도</strong> 그게 왜 필요하고 사용자에게 어떻게 전달되어 질 지를 모르면 제대로 된 제품을 만들 수는 없을 것은 자명한 일이다.</p>
<h3 id="챗봇에-대한-기대는-굉장히-천차-만별이다"><a href="#챗봇에-대한-기대는-굉장히-천차-만별이다" class="headerlink" title="챗봇에 대한 기대는 굉장히 천차 만별이다."></a>챗봇에 대한 기대는 굉장히 천차 만별이다.</h3><p><img src="/images/ai004.jpg" alt="정말 다른 기대"></p>
<p>사용자들과 인터뷰를 진행 하다보면 정작 사용자들은 챗봇에게 큰 기대를 하지 않는다. 마치 우리가 시리와 빅스비에게 심드렁한 것 처럼. 하지만 기획단계에서의 기획자와 발안자들은 굉장히 많은 기대를 가지고 프로젝트에 접근한다.( 이런 간극은 어떻게 존재하는 걸까. )</p>
<p><strong>심지어 챗봇을 위한 디자인 원칙들을 읽어 보지도 않고 말이다.</strong> 챗봇들이 무엇인가 세상을 바꿀 것 처럼 굉장히 멋진 장표들과 아키텍처들을 보고 있지만 정작 이것이 어떤 문제를 해결할 지 알고 있는 사람은 없다.</p>
<p>개발을 진행하면서 챗봇 프로젝트들을 바라보든 사람들의 시각과 시장의 수요는 굉장히 많은 분야의 광범위한 인력 감축을 전제로 하기도 하고 챗봇이 모든 것을 해결해 줄 것 같은 분위기와 어쩌면 그런 미래가 바로 우리 앞에 닥쳐 있다는 사실을 부정할 수는 없다. 하지만 장표에 그려진 무지개 빛 청사진 또한 기술적으로 동의할 수는 없어 보인다. 그래서 항당 무게한 요구사항들을 사용자 인터뷰와 가이드라인을 기준으로 다 잘라내고 있는 것이 현실이다. 하지만 잘라도 잘라도 프로젝트는 가벼워지지 않고 프로젝트의 미래를 좌우하는 의사 결정자들 마저도 이상한 기대감을 가지고 있다는 사실은 어떻게 보면 슬픈 일이다.</p>
<p>페이스북과 같이 작업을 했던 스카이 스캐너 분야의 챗봇 담당자는 이렇게 이야기 한다<br>“아무도 챗봇으로 티켓을 사려고 하지는 않아요.”</p>
<h3 id="개발의-대부분은-인공지능과-관련이-없다"><a href="#개발의-대부분은-인공지능과-관련이-없다" class="headerlink" title="개발의 대부분은 인공지능과 관련이 없다."></a>개발의 대부분은 인공지능과 관련이 없다.</h3><p>우리는 구글이 아니다. 이걸 인정하면 몸도 마음도 굉장히 편해지지만 대부분의 어른들(?)은 그걸 인정하기가 아들 딸 성적표를 받아들이기 보다 어려운 모양이다. 하지만 어쩌면 우리에게도 희망은 있다. 챗봇의 아키텍처에서 인공지능이 차지하는 부분은 우리가 기대하는 부분보다 굉장히 작다. 오히려 <strong>룰을 어떻게 만들고 어떻게 처리할 것인가</strong> 하는 부분이 훨씬 실제적이면서도 중요한 문제로 다가오곤 한다.</p>
<h3 id="개발자는-그래서-또-너무나-중요하다"><a href="#개발자는-그래서-또-너무나-중요하다" class="headerlink" title="개발자는 그래서 또 너무나 중요하다."></a>개발자는 그래서 또 너무나 중요하다.</h3><p>위의 주제의 연속이다. 챗봇의 대부분은 소프트웨어 엔지니어의 영역이다. 그래서 챗봇 엔진을 잘 만들기 위해서는 좋은 엔지니어와 좋은 아키텍트가 당연히 필요하다. 물론 NLU라던지 딥러닝을 잘 하면 할 수록 더욱 좋다. 하지만 좋은 개발만큼 중요한 부분은 없다.</p>
<p>좋은 개발자는 여러가지 복잡하게 얽혀있는 챗봇의 어려움들을 풀어줄 시작과 마지막이다. 점점 인공지능의 세상이 오면 올 수록 사용자의 입장에서 이해하는 개발자가 더 중요해 질 것이다. 능숙하고 영민한 개발자를 잘 찾아서 서비스의 전방에 배치하는 것이 인공지능 전문가를 구하는 것보다 ROI가 훨씬 높다.</p>
<h3 id="우리는-기존의-레거시를-대체해야-한다"><a href="#우리는-기존의-레거시를-대체해야-한다" class="headerlink" title="우리는 기존의 레거시를 대체해야 한다."></a>우리는 기존의 레거시를 대체해야 한다.</h3><p><img src="/images/ai-legacy.jpg" alt="이렇게 죽어있는 레거시는 곤란하다"></p>
<p>언제나 챗봇이 있는 곳에는 상담이라던지, 견적같은 - 모든 챗봇이 풀고자 하는 문제들- 에는 기존의 시스템이 유령처럼 자리잡고 있다. 그럼 이 레거시들을 어떻게 유기적으로 풀고 어떻게 서비스를 대체할 수 있을까? 마이크로 서비스 아키텍처는 그 중의 좋은 대답이 될 수 있다. 하지만 이것이 만병통치약은 아니다. 가장 중요한 것은 기존 레거시 함수를 묶어주는 표준을 만들어 주는 것이고 그 레거시를 어떻게 접근할지에 대한 해답은 챗봇이 가지고 있어야 한다. 이런 부분에서는 기존 레거시를 잘 알고 있는 개발자는 도움이 된다.</p>
<p>그렇다면 사용자의 자연어와 레거시간의 연계는 어떻게 이루어 질 것인가. <strong>여기에 기존에 없던 인공지능 분야의 기술이 필요하다.</strong></p>
<h3 id="과소-평가해서도-곤란하다"><a href="#과소-평가해서도-곤란하다" class="headerlink" title="과소 평가해서도 곤란하다."></a>과소 평가해서도 곤란하다.</h3><p><img src="/images/ai003.jpg" alt="stay tuned"></p>
<p>이 쪽은 지속적으로 계속 발전할 것이다. 그렇다는 것은 지금 발을 들이기에 무척이나 좋은 시기라는 것이다.<br>아무래도 발전에 대한 틀은 대부분이 갖춰지는 것 같다.<br>누군가가 기가막힌 사용자 인터페이스를 제시할 것이고 그 때 쯤이면 아직까지는 기대할 것 없는 챗봇 분야의 인공지능도 수준이 많이 올라갈 것이다.<br>언제나 관심을 기울이고 있어야 한다는 이야기다.</p>
<h3 id="어떻게-준비할-것인가"><a href="#어떻게-준비할-것인가" class="headerlink" title="어떻게 준비할 것인가"></a>어떻게 준비할 것인가</h3><p>일단 개발자들은 하던 일들을 열심히 하면서 인공지능에 대한 트렌드는 지속적으로 팔로우업 해야한다.<br>어렵지만 생존을 위한 일이라면 해볼 만한 일이다. 그리고 생각보다 재미 있는 분야다.<br>구글이 모바일 퍼스트에서 드디어 AI퍼스트를 선언한 지금 우리가 맞이할 미래는 모바일이 인터페이스였던 시대를 인공지능이 대체할 것이고 이 인터페이스는 IoT와 맞물려 우리 주위 어디에서든지 우리에게 시도 때도 없이 간섭을 시작할 것이다.<br>가장 처음 이야기 했던 <strong>사람의 이해</strong> - 사람을 이해하는 것은 다시 한번 개발자들에게는 중요한 화두로 던져질 것이라는 데 나의 행보를 던져본다.<br>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ai001.jpg&quot; alt=&quot;AI vs Human Brain&quot;&gt;&lt;br&gt;최근 급하게 프로젝트에 두달간 투입이 되면서 블로그 포스팅을 할 여유가 전혀 없었다.&lt;br&gt;좀 반성하는 차에 진행한 프로젝트에서 얻은 인사이트를
    
    </summary>
    
    
      <category term="chatbot, experience" scheme="http://keen.devpools.kr/tags/chatbot-experience/"/>
    
  </entry>
  
  <entry>
    <title>first-post</title>
    <link href="http://keen.devpools.kr/2017/05/15/first-post/"/>
    <id>http://keen.devpools.kr/2017/05/15/first-post/</id>
    <published>2017-05-15T07:04:04.000Z</published>
    <updated>2017-05-30T13:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo-를-이용한-github-page-블로그-서비스"><a href="#hexo-를-이용한-github-page-블로그-서비스" class="headerlink" title="hexo 를 이용한 github page 블로그 서비스"></a>hexo 를 이용한 github page 블로그 서비스</h1><p>개인 블로그 URL을 운영하다가 도메인이 너무 비싸져서 깃헙 기반으로 옮겨 탔습니다. hexo 는 아직 손에 익숙하지는 않지만 어느순간 손에 익었다 싶으면 다 이쪽으로 가지고 와서 작성을 할까 싶습니다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo-를-이용한-github-page-블로그-서비스&quot;&gt;&lt;a href=&quot;#hexo-를-이용한-github-page-블로그-서비스&quot; class=&quot;headerlink&quot; title=&quot;hexo 를 이용한 github page 블로그 서비스&quot;&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>패턴인식 개요</title>
    <link href="http://keen.devpools.kr/2017/03/18/%5B2017-03-18%2014:56:34%5D%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%89%E1%85%B5%E1%86%A8%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/"/>
    <id>http://keen.devpools.kr/2017/03/18/[2017-03-18 14:56:34]패턴인식 개요/</id>
    <published>2017-03-18T05:56:34.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="패턴-인식"><a href="#패턴-인식" class="headerlink" title="패턴 인식"></a>패턴 인식</h3><p>주어진 데이터의 집합에 대해 입력값을 바탕으로 하는 Classification. MNIST 처럼 이미지에서 숫자를 도출하는 것도 좋은 예</p>
<ul>
<li>구조적 방법 : 1은 하나의 직선에 가깝고 8은 원 두개.</li>
<li>템플릿 매칭 : 패턴의 원형을 저장해 두고 데이타간의 거리를 계산</li>
<li>기계학습</li>
</ul>
<h4 id="패턴-인식과-관련된-개념"><a href="#패턴-인식과-관련된-개념" class="headerlink" title="패턴 인식과 관련된 개념"></a>패턴 인식과 관련된 개념</h4><h4 id="1-분류와-군집화"><a href="#1-분류와-군집화" class="headerlink" title="1. 분류와 군집화"></a>1. 분류와 군집화</h4><p><strong>분류( Classification ) : MNIST로 숫자를 맞추는 형태</strong></p>
<ul>
<li>베이지안 분류기, K 근접 이웃, 다층 퍼셉트(MLP), 서포트 벡터 머신</li>
<li>지도학습</li>
</ul>
<p><strong>군집화( Clustering ) : 특성 고객층을 하나의 기준으로 분류하기 보다는 여러가지 기준이지만 뭉뚱그리는 것</strong></p>
<ul>
<li>K 편균 클러스터링, 계층적 군집화, 자기조직화 특징맵(SOM)</li>
<li>비지도 학습</li>
</ul>
<h4 id="2-데이터와-데이터-분포"><a href="#2-데이터와-데이터-분포" class="headerlink" title="2. 데이터와 데이터 분포"></a>2. 데이터와 데이터 분포</h4><blockquote>
<p>여러가지 데이터들은 결국 컴퓨터에서 다루어질 수 있게 수치로 표현 되어야 한다. 이 숫자들을 1차원으로 나열하면 벡터, 차원이 높아지면 행렬이 되는데 이런 모임을 Tensorflow에서는 tensor 라고 지칭하고 딥러닝의 과정이 이 tensor가 움직이면서 나타나서 Tensorflow 를 이루게 된다.</p>
</blockquote>
<ul>
<li>표본집합 추출</li>
<li>특징추출</li>
<li>분류와 결정경계</li>
</ul>
<h4 id="분류율과-오차"><a href="#분류율과-오차" class="headerlink" title="분류율과 오차"></a>분류율과 오차</h4><p>학습 오차 : 학습데이타에 대하여 분류 오차를 계산한 것</p>
<p>테스트 오차 : 실제 데이타의 오차</p>
<p>일반화 오차 : 확률분포함수를 이용한 분포에 따른 평균 오차값. 테스트 오차가 절대값 수치 미적용에 따른 왜곡을 가질 수 있으므로 사용한다</p>
<p>교차검증법을 통해 오차값을 얻어내기도 한다</p>
<h4 id="3-과다-적합-overfitting"><a href="#3-과다-적합-overfitting" class="headerlink" title="3. 과다 적합(overfitting)"></a>3. 과다 적합(overfitting)</h4><ul>
<li>Classifier가 학습데이타에 대해서만 지나치게 적합한 형태로 결정경계를 형성하는 경우. train데이타의 범주를 벗어나는 경우는 제대로 분류하지 못하는 경우.</li>
<li><a href="http://sanghyukchun.github.io/59/" target="_blank" rel="external">Machine Learning 스터디 (3) Overfitting</a></li>
</ul>
<p><img src="/images/0*G9gNynok0IWGFWsX" alt=""></p>
<h4 id="4-활용분야"><a href="#4-활용분야" class="headerlink" title="4. 활용분야"></a>4. 활용분야</h4><ul>
<li>문자 인식</li>
<li>생체인식</li>
<li>금융데이터</li>
<li>생물정보</li>
<li>뇌 신호 처리</li>
<li>영상처리</li>
<li>뇌 신호 처리</li>
</ul>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/81a1fd6ca86a" target="_blank" rel="external">March 18, 2017</a>.</p>
<p>Exported from <a href="https://medium.com" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;패턴-인식&quot;&gt;&lt;a href=&quot;#패턴-인식&quot; class=&quot;headerlink&quot; title=&quot;패턴 인식&quot;&gt;&lt;/a&gt;패턴 인식&lt;/h3&gt;&lt;p&gt;주어진 데이터의 집합에 대해 입력값을 바탕으로 하는 Classification. MNIST 처럼 이미지에
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>딥러닝을 위한 수학 1</title>
    <link href="http://keen.devpools.kr/2017/03/13/%5B2017-03-13%2018:26:57%5D%E1%84%83%E1%85%B5%E1%86%B8%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%201/"/>
    <id>http://keen.devpools.kr/2017/03/13/[2017-03-13 18:26:57]딥러닝을 위한 수학 1/</id>
    <published>2017-03-13T09:26:57.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>원문은 아래에 지속적으로 업데이트</p>
<p><a href="https://github.com/ehrudxo/til" title="https://github.com/ehrudxo/til" target="_blank" rel="external"><strong>ehrudxo/til</strong><br>_til - today I learned. 오늘 공부한것을 위키 형식으로 적기시작 해봄._github.com</a><a href="https://github.com/ehrudxo/til" target="_blank" rel="external"></a></p>
<p>수학은 워낙 넓으니까 선형대수를 다 다시 공부할 수도 없고… 주로 나오는 것만 위주로 나열하기로 함.</p>
<p>딥러닝에 왜 이런 여러가지가 나오는지를 먼저 이해하는 것이 중요함. 다른 대부분의 강의나 튜토리얼은 그런 설명없이 바로 수식을 전개함. 너무 간단해서 언급을 안하는 거 같은데, 나 같은 더미를 위해서 이야기 하면 딥러닝을 통해 머신이 내리는 결정은 대부분이 통계와 수학식을 통해 전개됨.</p>
<p>통계를 위해서는 확률을 알아야 하고 이 결정을 위한 확률의 기본이 베이즈 이론이라고 보면 됨. 이후 여러가지 알고리즘과 방법들이 나오는 것도 결국 이 확률이론이 토대가 된다.</p>
<p>뉴럴 네트워크가 들어가는 경우는 부분에 쓰이는 수학은 변수와 모델의 통제라는 측면에서 미분 그 중에서도 편미분이 중요하고 레이어의 계산이 한꺼번에 이루어지는 관점에서는 행렬식이 너무나 중요하다. 정도로만 개념을 잡고 (일단은) 넘어가면 된다.</p>
<p>결국은 문제를 어떻게 정의하는가가 핵심이고 그 문제를 푸는 방법으로써의 딥러닝이 각광을 받고 있다고 보면 내가 가지고 있는 해결해야 하는 문제들을 수학적으로 어떻게 정의하는지를 알아야 하는 것이 첫번째, 그리고 그것을 해결하는 다양한 방법들을 배우는 것을 두번째라고 생각하면 된다.</p>
<p>일단 확률에 대해서 알아보자.</p>
<h3 id="조건부-확률"><a href="#조건부-확률" class="headerlink" title="조건부 확률"></a>조건부 확률</h3><ul>
<li>P(Y=y|X=x) : 구름(X)이 꼈을때(true) 비(Y)가 올 확률을 의미함. — 출처 <a href="https://ko.wikipedia.org/wiki/%EC%A1%B0%EA%B1%B4%EB%B6%80_%ED%99%95%EB%A5%A0" target="_blank" rel="external">위키피디아 : 조건부 확률</a></li>
<li>P(E|F) = P(E and F)/P(F)</li>
<li>곱셈 정리 : P(E and F) = P(E|F) * P(F)</li>
<li>치환 정리 : P(E|F) * P(F) = P(F|E) * P(E)</li>
</ul>
<h4 id="한-개의-주사위를-두-번-던질-때-합이-3이-나올-확률-vs-두-개의-주사위를-던져서-합이-3이-나올-확률"><a href="#한-개의-주사위를-두-번-던질-때-합이-3이-나올-확률-vs-두-개의-주사위를-던져서-합이-3이-나올-확률" class="headerlink" title="한 개의 주사위를 두 번 던질 때 합이 3이 나올 확률 vs 두 개의 주사위를 던져서 합이 3이 나올 확률 :"></a>한 개의 주사위를 두 번 던질 때 합이 3이 나올 확률 vs 두 개의 주사위를 던져서 합이 3이 나올 확률 :</h4><ul>
<li>(1/6*1/6)/1/6 = 1/6 vs 2/36 = 1/18</li>
<li>표본 공간이 바뀌었다(축소 표본 공간)</li>
</ul>
<h4 id="1개의-주사위를-네번-굴려서-6이-한번-나오는-경우-vs-2개의-주사위를-24번-굴려서-동시에-6이-한번-나오는-경우-드-메레-문제"><a href="#1개의-주사위를-네번-굴려서-6이-한번-나오는-경우-vs-2개의-주사위를-24번-굴려서-동시에-6이-한번-나오는-경우-드-메레-문제" class="headerlink" title="1개의 주사위를 네번 굴려서 6이 한번 나오는 경우 vs 2개의 주사위를 24번 굴려서 동시에 6이 한번 나오는 경우 ( 드 메레 문제 )"></a>1개의 주사위를 네번 굴려서 6이 한번 나오는 경우 vs 2개의 주사위를 24번 굴려서 동시에 6이 한번 나오는 경우 ( 드 메레 문제 )</h4><ul>
<li>여사건 정의(1-P(E))를 통해서 풀어야 하는데 그 이유는 처음에 6이 나오면 표본공간 자체가 필요없어지기 때문에 절대 안나오는 확률을 기준으로 계산을 한 다음에 여사건 정의로 푼다 1-(5/6)⁴ = 0.518 : 같은 방법.</li>
<li>표본공간을 확보하는 것이 관건</li>
<li>2개의 주사위를 굴려서 동시에 안 나오는 경우는 1 -(35/36)²⁴ = 0.491 — “세상에서 가장 재미있는 통계학”</li>
</ul>
<h3 id="베이즈-정리"><a href="#베이즈-정리" class="headerlink" title="베이즈 정리"></a>베이즈 정리</h3><ul>
<li>개요 : 베이즈 정리는 1740년대의 영국의 목사인 토머스 베이즈(Thomas Bayes)가 정립한, 조건부 확률에 대한 수학적 정리이다. 사건 A가 있고 사건 B가 있을 때 사건 B가 일어난 것을 전제로 한 사건 A의 조건부 확률을 구하고 싶다. 그런데 지금 알고 있는 것은 사건 A가 일어난 것을 전제로 한 사건 B의 조건부 확률, A의 확률, B의 확률뿐이다. 그럴 때 다음과 같이 구할 수가 있다. 출처 : <a href="https://namu.wiki/w/%EB%B2%A0%EC%9D%B4%EC%A6%88%20%EC%A0%95%EB%A6%AC" target="_blank" rel="external">나무위키</a> .</li>
<li>조금 더 수식으로 풀어 쓰면</li>
</ul>
<p><img src="/images/0*s9FyujgqEUU8HAKf.jp" alt="">출처 <a href="https://namu.wiki/w/%EB%B2%A0%EC%9D%B4%EC%A6%88%20%EC%A0%95%EB%A6%AC" target="_blank" rel="external">나무 위키 베이즈 정리</a></p>
<ul>
<li>인구 1000명당 한 명꼴로 걸리는 희귀병. 병에 걸린 사람의 경우는 90% 양성, 건강한 사람의 2% 가 양성 -> 양성반응을 보인 사람의 병에 걸릴 확률은?</li>
<li>즉, 인간의 사고는 처음에는 아무 정보가 없던 상태에서 <strong>새로운 정보를 받아들이고, 이를 통해 자신이 가지고 있던 일종의 사전 확률 체계를 업데이트시켜 세상을 해석하거나 판단을 내리고 의사결정을 하는 방향으로 발전되어 왔다는 것이다</strong>. 그리고 이렇게 발전된 사후 확률 체계는 새로운 사전 확률이 되어, 새로운 정보가 유입될 때마다 업데이트를 반복해간다. — 나무위키 인지과학 및 인공지능에서의 베이즈 정리</li>
</ul>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/c5e1cb31a7ca" target="_blank" rel="external">March 13, 2017</a>.</p>
<p>Exported from <a href="https://medium.com" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;원문은 아래에 지속적으로 업데이트&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ehrudxo/til&quot; title=&quot;https://github.com/ehrudxo/til&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>딥러닝 생초짜를 위한 로드맵을 짜주마</title>
    <link href="http://keen.devpools.kr/2017/03/11/%5B2017-03-11%2018:22:15%5D%E1%84%83%E1%85%B5%E1%86%B8%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%8E%E1%85%A9%E1%84%8D%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3%E1%84%86%E1%85%A2%E1%86%B8%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8D%E1%85%A1%E1%84%8C%E1%85%AE%E1%84%86%E1%85%A1/"/>
    <id>http://keen.devpools.kr/2017/03/11/[2017-03-11 18:22:15]딥러닝 생초짜를 위한 로드맵을 짜주마/</id>
    <published>2017-03-11T09:22:15.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Today I Summarized라는 프로젝트를 깃헙에 만들었다.</p>
<p><a href="https://github.com/ehrudxo/tis" title="https://github.com/ehrudxo/tis" target="_blank" rel="external"><strong>ehrudxo/tis</strong><br>_tis - Today I Summarized. 오늘 요약한 것을 위키 형식으로 적기. 시작 해봄._github.com</a><a href="https://github.com/ehrudxo/tis" target="_blank" rel="external"></a></p>
<p>매일 발표나 스터디 요약을 위해 정리하는 자리인데 아무래도 나야말로 딥러닝 생초짜이기 때문에 꼭 정확한 방법이라고 할 수는 없지만 이 프로젝트에는 지속적으로 전체 큰그림을 구조화 하고 상세화 해서 누구나 읽을 수 있도록 업로드 하도록 하겠다. 그러면서 매일 매일의 내용은 같이 스터디 하는 팀에 공유 하도록 하겠다.</p>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/c295bf9e565c" target="_blank" rel="external">March 11, 2017</a>.</p>
<p>Exported from <a href="https://medium.co" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Today I Summarized라는 프로젝트를 깃헙에 만들었다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ehrudxo/tis&quot; title=&quot;https://github.com/ehrudxo/tis&quot; target=&quot;_blan
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
</feed>
