<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>keen blog</title>
  <subtitle>keen&#39;s tech blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://keen.devpools.kr/"/>
  <updated>2017-09-14T06:57:55.000Z</updated>
  <id>http://keen.devpools.kr/</id>
  
  <author>
    <name>ehrudxo@gmail.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[tip] -도커로 깃랩을 설치했을때 젠킨스 연결은 어떻게 할 것인가</title>
    <link href="http://keen.devpools.kr/2017/09/14/gitjenkinstip/"/>
    <id>http://keen.devpools.kr/2017/09/14/gitjenkinstip/</id>
    <published>2017-09-14T04:31:23.000Z</published>
    <updated>2017-09-14T06:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>깃랩같은 좋은 툴은 언제나 파워풀하지만, 설치가 쉽지않다. 그래서 깃랩을 설정하기가 어려운 부분은 도커가 최근에는 대신하고 있다.<br>그런데, 도커로 설치를 하다보면 CI, CD 환경을 꾸미는 것은 어떻게 해야할지 감이 오지 않을 때가 많다.</p>
<p>도커로 깃랩을 설치하는 것과 관련된 글은 검색을 하면 수십개가 나오고, 젠킨스와 깃랩을 연동하는 부분도 굉장히 많이 나오지만 도커로 설치된 깃랩과 젠킨스 연동을 위한 중요한 링크가 빠져 있다.</p>
<p>중요한 두가지 설정 포인트가 필요하다.</p>
<h3 id="1-ssh-포트-변경된-경우-git-연결"><a href="#1-ssh-포트-변경된-경우-git-연결" class="headerlink" title="1. ssh 포트 변경된 경우 git 연결"></a>1. ssh 포트 변경된 경우 git 연결</h3><p>~/.ssh/config 파일을 만든다.<br>ServerName, UserName, Port 은 프로젝트에 맞춰 준다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Host &#123;ServerName&#125;</div><div class="line">        User &#123;UserName&#125;</div><div class="line">        Port &#123;Port&#125;</div></pre></td></tr></table></figure></p>
<p>이후 git 명령어로 프로젝트를 잘 가져오는지 확인하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$git</span> <span class="built_in">clone</span> ssh://git@server:[port]/url </div><div class="line">`</div></pre></td></tr></table></figure>
<h3 id="2-git-연결-주소-설정"><a href="#2-git-연결-주소-설정" class="headerlink" title="2. git 연결 주소 설정"></a>2. git 연결 주소 설정</h3><p>참고로, 퍼블릭키와 프라이빗 키는 이미 잘 설정되어 있을 거라는 전제하에 얘기한다.</p>
<p>링크 : <a href="http://egloos.zum.com/mcchae/v/11246199" target="_blank" rel="external">gitlab과 Jenkins연동</a></p>
<p>위 링크에 대해서 URL을 설정하는 부분만 아래와 같이 바꾸면 잘 해결되는 것을 확인할 수 있다.</p>
<p><img src="/images/sourcecodemgmt.png" alt="링크 주소 설정"></p>
<p>이렇게 되고 나면 깃에 자유자재로 업데이트하고 긁어올 수 있음을 알 수 있다. 나머지 CI, CD 옵션은 원하는데로 구성하면 된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;깃랩같은 좋은 툴은 언제나 파워풀하지만, 설치가 쉽지않다. 그래서 깃랩을 설정하기가 어려운 부분은 도커가 최근에는 대신하고 있다.&lt;br&gt;그런데, 도커로 설치를 하다보면 CI, CD 환경을 꾸미는 것은 어떻게 해야할지 감이 오지 않을 때가 많다.&lt;
    
    </summary>
    
    
      <category term="tip, docker, devops, git" scheme="http://keen.devpools.kr/tags/tip-docker-devops-git/"/>
    
  </entry>
  
  <entry>
    <title>[github]Node.js 기반 헤드리스 브라우저 컨트롤 API - puppeteer</title>
    <link href="http://keen.devpools.kr/2017/09/14/puppeteer/"/>
    <id>http://keen.devpools.kr/2017/09/14/puppeteer/</id>
    <published>2017-09-14T04:09:55.000Z</published>
    <updated>2017-09-14T04:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/puppeteer.jpg" alt="puppeteer"><br>프로젝트 링크 : <a href="https://github.com/GoogleChrome/puppeteer/" target="_blank" rel="external">https://github.com/GoogleChrome/puppeteer/</a><br>첫번째 프로젝트는 구글 크롬 프로젝트에서 Headless Chrome Node API 로 내 놓은 퍼펫티어다. 퍼펫이라고 하면 번역하면 인형술사이고 꼭두각시 인형을 다루는 사람을 이야기 한다. 이 프로젝트의 배경부터 이야기 하자면 올해(2017년) 4월 경 구글프로젝트에서는 크롬에 Headless 모드를 추가했다.<br>Headless 브라우저라고 하면 일반적으로 CLI환경에서 브라우저가 시각적으로 보여지지 않고 백그라운드에서 작동할 수 있는 것을 이야기 하는데, 이 전까지 가장 유명한 것은 PhantomJS라는 프로젝트였다. 크롤링을 하고 스크린 샷을 찍어서 다운로드하고 등의 일들을 할 수 있었다. 그래서 데스크탑이 아닌 서버에서 DOM을 읽어야 하는 경우 등에서 많이 사용되고는 했었다. </p>
<p>필자의 경우는 테스트 환경을 꾸밀 수 있지 않을까 하는 기대에 관련된 작업들을 진행해 보았고 관련되어 링크를 남기기도 했다.<br>링크 : 헤드리스 크롬과 selenium2의 조합을 사용해 보자 with node (<a href="http://keen.devpools.kr/2017/06/07/about-test/">http://keen.devpools.kr/2017/06/07/about-test/</a> ) </p>
<p>그런데, 8월 한달 가장 주목받은 프로젝트가 된 이 puppeteer는 Node.js에서 헤드리스 크롬을 사용할 수 있는 API들을 제공하는 것이다. Headless 모드를 발표하자마자 Phantom.JS는 더 이상 개발 안하기로 선언을 한 것과 마찬가지로 Node.js 진영에 새로운 무기가 생겨버린 셈이 되었다</p>
<h2 id="1-설치를-해보자"><a href="#1-설치를-해보자" class="headerlink" title="1. 설치를 해보자"></a>1. 설치를 해보자</h2><p>먼저 프로젝트를 한번 만들어 보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$mkdir</span> puppeteer-project &amp;&amp; <span class="built_in">cd</span> puppeteer-project</div><div class="line"><span class="variable">$yarn</span> add puppeteer</div></pre></td></tr></table></figure></p>
<p>이렇게 설치를 하고 나면 프로젝트에 index.js 파일을 만든다..</p>
<p>&lt;코드&gt;index.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line">(<span class="keyword">async</span> () =&gt; &#123;</div><div class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</div><div class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line">  <span class="keyword">await</span> page.goto(<span class="string">'http://devpools.kr'</span>);</div><div class="line">  <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'devpools.png'</span>&#125;);</div><div class="line"></div><div class="line">  browser.close();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>스크린샷을 가져 오는 코드가 작성되었다.  개발바보들 첫 페이지의 스크린 샷을 가져오는 소스 코드를 작성한 이후에 node index.js 명령어를 입력하면 다음과 같은 이미지를 가지고 오는 것을 볼 수 있다. </p>
<p>기본적으로 지정된 이미지 크기는 800*600으로 지정된 듯 하다. 보통 phantomJS 같은 경우는 스크롤을 다 잡아 가던 초반 모습에 비해 메모리 관리를 위한 것인지 이미지 해상도도 그렇게 좋은 거 같지는 않아 보인다. </p>
<p>PDF로 Export 하는 기능도 API를 통해 구현이 가능하다. </p>
<p><img src="/images/crawled_devpools.jpg" alt="개발바보들 스크린샷"></p>
<h2 id="2-크롤링을-해-보자"><a href="#2-크롤링을-해-보자" class="headerlink" title="2. 크롤링을 해 보자."></a>2. 크롤링을 해 보자.</h2><p>이번엔 find.js 라는 파일을 아래와 같이 만들어 본다. 실제로 이미지와 지금 아래 크롤링 소스는 해당 프로젝트와 내용이 거의 유사하다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</div><div class="line"></div><div class="line">(<span class="keyword">async</span>() =&gt; &#123;</div><div class="line"><span class="comment">//브라우저 객체와 페이지 객체를 만들고</span></div><div class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</div><div class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</div><div class="line"></div><div class="line"><span class="comment">// 구글 검색창 방문</span></div><div class="line"><span class="keyword">await</span> page.goto(<span class="string">'https://google.com'</span>, &#123;<span class="attr">waitUntil</span>: <span class="string">'networkidle'</span>&#125;);</div><div class="line"><span class="comment">//개발 바보들에 대한 검색어를 입력하고</span></div><div class="line"><span class="keyword">await</span> page.type(<span class="string">'devpools'</span>);</div><div class="line"><span class="comment">// 검색버튼을 누르고</span></div><div class="line"><span class="keyword">await</span> page.click(<span class="string">'input[type="submit"]'</span>);</div><div class="line"><span class="comment">//검색한 결과의 타이틀을 가져와서</span></div><div class="line"><span class="comment">// Wait for the results to show up</span></div><div class="line"><span class="keyword">await</span> page.waitForSelector(<span class="string">'h3 a'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> links = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> anchors = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(<span class="string">'h3 a'</span>));</div><div class="line">  <span class="keyword">return</span> anchors.map(<span class="function"><span class="params">anchor</span> =&gt;</span> anchor.textContent);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//콘솔에 출력한다.</span></div><div class="line"><span class="built_in">console</span>.log(links.join(<span class="string">'\n'</span>));</div><div class="line">browser.close();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>소스 코드에 대한 설명은 주석에 달아 둔데로 브라우저 객체와 페이지 객체를 만들고 구글 검색창을 방문해서 개발 바보들에 대한 검색어를 입력하고 검색버튼을 누른 뒤 검색된 결과의 타이틀을 가져와서 콘솔에 출력한다.</p>
<p>그 결과는 다음과 같다. 이 과정 중에 어떤 브라우저의 인터렉션도 필요 없었고 (내부적으로는 크롬 헤드리스 브라우저가 작동을 했지만) 사용자의 경우는 결과만 가져올 수 있다.</p>
<p><img src="/images/searchresults.jpg" alt="devpools 검색결과"></p>
<h2 id="맺음말"><a href="#맺음말" class="headerlink" title="맺음말"></a>맺음말</h2><p>왜 구글은 이런 제품을 내놓고 있는 걸까? 워낙 혁신적인 기업이라 속내를 다 살펴볼 수는 없지만 지속적으로 API를 내놓고 있는 것은 웹의 많은 부분이 자동화로 돌아설 것이고 그 중심에 인공지능이 있지 않을까 하는 생각이 들어 잠시 한번 고민을 해 보았다. 아마도 텐서플로가 조만간 DOM 기반의 러닝 모델을 공개하는 날이 오지 않을까?</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/puppeteer.jpg&quot; alt=&quot;puppeteer&quot;&gt;&lt;br&gt;프로젝트 링크 : &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer/&quot; target=&quot;_blank&quot; rel=&quot;
    
    </summary>
    
    
      <category term="github-trend, github" scheme="http://keen.devpools.kr/tags/github-trend-github/"/>
    
  </entry>
  
  <entry>
    <title>딥러닝 무식하게 정리해 보기 01</title>
    <link href="http://keen.devpools.kr/2017/09/08/deeplearning-basic01/"/>
    <id>http://keen.devpools.kr/2017/09/08/deeplearning-basic01/</id>
    <published>2017-09-08T02:44:06.000Z</published>
    <updated>2017-09-08T03:23:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>딥러닝, 인공지능 이야기를 하면 CNN, RNN 같은 알고리즘에 관한 글만 굉장히 많아서 조금 탑뷰에서 바라볼 수 있는 관점에서 전체 기술과 활용처를 분류하고 딥러닝 프레임워크에 대해서 알아 보았다. 딥러닝 프레임워크는 같이 프로젝트를 하고 있는 팀 로자미아 가 같이 정리를 해 주었다. Mabel, Jin, Alex 에게 감사를 드린다.</p>
<h2 id="AI-기술의-응용-분야"><a href="#AI-기술의-응용-분야" class="headerlink" title="AI 기술의 응용 분야"></a>AI 기술의 응용 분야</h2><p>딥러닝은 여러가지 알고리즘을 가지고 있지만 결국 하고자 하는 대부분의 일들이 군집(clustering)과 분류(classification) 라는 관점으로 귀결된다.<br>그에 따라 AI 기술 스택을 분류하는 방법은 여러가지가 있고 활용되는 분야도 다양하지만 아래와 같이 분류를 해보았다.<br>먼저 챗봇과 번역등에 사용되는 NLU등을 사용하는 Conversational AI.<br>두번째는 개와 고양이 구분하기 등에 많이 사용되는 Visual AI 분야.<br>마지막으로는 전통적으로 진행하던 데이타 분석을 하는 Analytic AI.</p>
<h3 id="Conversational-AI"><a href="#Conversational-AI" class="headerlink" title="Conversational AI"></a>Conversational AI</h3><p><img src="/images/playmobil-451203_640.jpg" alt="conversation goes on"></p>
<p>Conversational AI 에는 기본적으로 NLU(Naturla Language Understanding)을 그 근간으로 한다. 오픈 소스중에선 Rasa.ai 같은 프레임워크가 존재하고 오픈 서비스로는 wit.ai 와 api.ai 가 있고 제품으로 유명한 것은 IBM의 conversational 엔진이 유명하다. 일반적인 개발자들이 가장 많이 만나는 것은 페이스북을 가지고 챗봇을 한번 만들어보다가 만나게 되는 것이 NLU 와의 처음 만남이 된다고 볼 수 있다. 이 NLU 엔진은 여러가지 기능을 가지는데 기본적으로 전체의 맥락을 판단하고 키워드를 뽑아내는 게 으뜸된 기능인데 이것을 인텐트와 엔터티라는 업계 용어로 지칭한다.<br>맥락 혹은 화행에는 기본적으로 의도가 들어가 있고 감정이 들어가 있어서 이런 감성을 파악해 내는 데 word2vec doc2vec 같은 툴들이 사용된다. 한글의 경우는 영어와 다른 구조를 가지고 있기 때문에 형태소를 분석해야 하고 mecab-ko 나 은전한잎 같은 툴들이 이용된다. </p>
<p>여기까지는 일반적인 NLU에 대한 이야기만 한 것이고, 챗봇을 위해서는 다이알로그의 룰이 존재하기 마련이라 룰 매니저 혹은 다이알로그 매니저들이 존재한다. 얘룰 들면 페이스북 챗봇을 만들 때 이런 말이 들어오면 이렇게 대답해야지.. 라고 만드는 대화 구성이 그런 역할을 하는 것이다. 이런 다이알로그 개념이 들어가면 한 문장의 문맥이 아닌 전체 문맥을 파악해야하는 기능과 랭킹 시스템을 구축해야 한다.</p>
<p>조금 더 나아가면 보통 STT(Speech To Text), TTS(Text To Speech) 로 알고 있는 음성자동 시스템이랑 연결해서 사용자의 음성을 듣고 텍스트로 변환해 준 뒤에 그것을 구축해 놓은 챗봇 시스템과 연결해 구축하는 작업들이 생겨나고 있다.</p>
<h3 id="AI-for-media"><a href="#AI-for-media" class="headerlink" title="AI for media"></a>AI for media</h3><p><img src="/images/abstract-1233873_640.jpg" alt="AI for media"></p>
<p>얼굴 인식, 피플 카운팅 등에 사용되는 Face Recognition 과 딥러닝 기반의 Object Recognition 은 미디어들을 통해 사람을 인식하거나 장면등을 파악해서 시스템과 연결하는 일들을 할 때 많이 사용된다. 딥러닝 기반 객체 인식은 보통 CNN 알고리즘으로 유명한데 최근에는 여러가지 알고리즘이 더 들어간 경우가 많고 YOLO Darknet 같은 경우는 인식률과 속도에서 다른 범용 툴을 압도한다.<br>피플 카운팅을 응용하면 히트맵 히트존 등의 기술등으로 확장이 가능하다.<br>OCR 프로그램은 기존에도 존재했던 것들인 많은데, 딥러닝 기반으로 프로젝트들이 변경되고 있다. 구글 tesseract 도 LSTM 알고리즘의 4.0 버전을 테스트 중이다.</p>
<h3 id="Analytics"><a href="#Analytics" class="headerlink" title="Analytics"></a>Analytics</h3><p>기존의 데이터들을 분석하는 툴 기반이라 딥러닝 보다는 기존 스파크와 하둡 기반의 빅데이터 툴들이 더 많은 일들을 해 주는 부분들이다.</p>
<h2 id="AI-기반-기술-스택-별로-알아보자-1"><a href="#AI-기반-기술-스택-별로-알아보자-1" class="headerlink" title="AI 기반 기술 스택 별로 알아보자 (1)"></a>AI 기반 기술 스택 별로 알아보자 (1)</h2><h3 id="인공지능을-위한-프로세서의-발전"><a href="#인공지능을-위한-프로세서의-발전" class="headerlink" title="인공지능을 위한 프로세서의 발전"></a>인공지능을 위한 프로세서의 발전</h3><p><img src="/images/nvidia-1201077_640.jpg" alt="템빨은 언제나 진리"></p>
<p>딥러닝은 기본적으로 다층 레이어의 많은 학습을 요구하기 때문에 단순한 계산이 순식간에 많이 일어나는 것을 특징으로 한다. 그렇기에 병렬처리 컴퓨팅이 가장 중요한 핵심기능이 되어서 기존 CPU이외의 다른 대안들이 필요하다.<br>그런 의미에서 프로세서 유니트(코어) 각각의 성능은 떨어지지만 프로세서 유니트 수가 압도적으로 많은 GPU 가 각광을 받았다. 특히 엔비디아 CUDA (병렬컴퓨팅 플랫폼의 API모델) 의 등장은 프로세서 경쟁에 불을 붙였다.<br>참조 : <a href="http://www.epnc.co.kr/news/articleView.html?idxno=75603" target="_blank" rel="external">http://www.epnc.co.kr/news/articleView.html?idxno=75603</a> </p>
<h4 id="GPGPU-General-Purpose-GPU"><a href="#GPGPU-General-Purpose-GPU" class="headerlink" title="GPGPU - General Purpose GPU"></a>GPGPU - General Purpose GPU</h4><p>범용 GPU를 이야기 하는 것으로 AI 용으로만 사용될 때는 TPU라는 이름을 쓰기도 한다.(Tensor Processing Unit) NVIDIA의 GPGPU를 극대화 하기 위한 CUDA 기술을 공개했고 동시에 범용 GPU 기능이 주목 받기 시작했다</p>
<h4 id="GPGPU를-넘어서"><a href="#GPGPU를-넘어서" class="headerlink" title="GPGPU를 넘어서"></a>GPGPU를 넘어서</h4><p>구글의 딥러닝의 학습속도를 향상시키기 위해 자체 디자인한 반도체 칩셋(ASIC)를 적용되면서 더 각광 받기 시작함. 구글의 ASIC를 TPU(Tensor Processing Unit) 이라 부르고 GPGPU의 범주에 놓기도 한다.<br>MS는 같은 목적으로 FPGA 칩을 클라우드 데이타 센터에 탑재해 Azure 서비스에도 이용하고 있는데, FPGA는 저전력의 강점도 가지고 있다.</p>
<h4 id="Neuromorphic-Processor"><a href="#Neuromorphic-Processor" class="headerlink" title="Neuromorphic Processor"></a>Neuromorphic Processor</h4><p>신경구조와 유사한 프로세서가 차후 프로세서로 각광을 받고 있고 IBM 같은 회사들이 준비하고 있다.<br>링크 : <a href="http://www.research.ibm.com/cognitive-computing/neurosynaptic-chips.shtml#fbid=rXQq5aX-WkP" target="_blank" rel="external">http://www.research.ibm.com/cognitive-computing/neurosynaptic-chips.shtml#fbid=rXQq5aX-WkP</a></p>
<h3 id="딥러닝-서비스를-위한-인프라"><a href="#딥러닝-서비스를-위한-인프라" class="headerlink" title="딥러닝 서비스를 위한 인프라"></a>딥러닝 서비스를 위한 인프라</h3><p><img src="/images/server-2160321_640.jpg" alt="요즘엔 서버실에 갈 일이 있어야지"></p>
<p>크게 딥러닝 전용 인프라는 클라우드와 판매형 인프라로 나뉘어서 볼 수 있을 것 같은데 기존의 아마존 AWS, 마이크로소프트의 Azure, 구글 클라우드 같은 빅3는 이미 클라우드 인프라를 가지고 있다.<br>AWS의 경우는 클라우드 AMI(Amazon Machin Image)도 제공하고 있어서 굉장히 편리하게 쓸 수 있다. AMI라는 것은 미리 만들어진 이미지 같은 개념으로 볼 수 있다. NVidia 의 경우는 자사의 GPU를 이용한 클라우드 서비스를 하고 있는 것이 흥미롭다.<br>판매형 인프라는 기존의 서버 벤더들과 비슷한 형태를 취하고 있는데 웨이브 컴퓨팅은 하나의 모델을 제안하는 데 텐서플로 같은 소프트웨어에 특화되어 만들어져 있다.이에 비해 Penguin computing 은 몇가지 옵션들을 더 제공하고 있다.</p>
<h2 id="맺으며"><a href="#맺으며" class="headerlink" title="맺으며"></a>맺으며</h2><p>딥러닝, 인공지능 등을 바라볼때 탑뷰로 어떤 기술이 있는지를 알아보는 과정을 거치고 있다. 다음 번엔 개발자에게는 가장 중요한 딥러닝 프레임워크들을 다뤄보도록 하겠다. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;딥러닝, 인공지능 이야기를 하면 CNN, RNN 같은 알고리즘에 관한 글만 굉장히 많아서 조금 탑뷰에서 바라볼 수 있는 관점에서 전체 기술과 활용처를 분류하고 딥러닝 프레임워크에 대해서 알아 보았다. 딥러닝 프레임워크는 같이 프로젝트를 하고 있는
    
    </summary>
    
    
      <category term="deep learning" scheme="http://keen.devpools.kr/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>(tech-trend) 구루들이 찾는다는 테크 트렌드 - 유명 블로그와 소셜 유명인</title>
    <link href="http://keen.devpools.kr/2017/08/03/tech-trend-03/"/>
    <id>http://keen.devpools.kr/2017/08/03/tech-trend-03/</id>
    <published>2017-08-03T10:00:00.000Z</published>
    <updated>2017-08-06T07:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>이 글은 회사 기술 블로그에 올리고 있는 내용입니다. 회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기를 진행 중에 있습니다.</p>
<p>필자는 SDS Agile Core Team 에서 테크리드를 담당하고 있습니다.<br>OSGeo에서 오픈소스 활동을 하고 있습니다. 잘 모르는 기술에 대해서 낯선 사람들과 이야기 하면서 배워 나가는 것을 좋아합니다.</p>
</blockquote>
<h2 id="기술-트렌드에-관련해서-3-blog-amp-social-star"><a href="#기술-트렌드에-관련해서-3-blog-amp-social-star" class="headerlink" title="기술 트렌드에 관련해서 - 3. blog &amp; social star"></a>기술 트렌드에 관련해서 - 3. blog &amp; social star</h2><p>구루들이 찾는 다는 테크 트렌드의 마지막 시간이다. 이후에는 React 개발 때 TDD를 어떻게 적용하는 지에 대한 내용을 다뤄볼까 한다. 사실 여기에 들어갈 블로그와 소셜스타를 일일이 나열하기에는 굉장히 본인의 네트워크의 한계와 좁은 지식에 기댈 수 밖에 없어서 굉장히 조심스럽지만 처음 테크트렌드를 찾는 사람들을 위해서 조금 라이트하게 읽을 수 있는 아티클을 쓰시는 분들 혹은 개발회사 블로그 위주로 설명하겠다.</p>
<h3 id="회사-기술-블로그"><a href="#회사-기술-블로그" class="headerlink" title="회사 기술 블로그"></a>회사 기술 블로그</h3><p>좋은 기술 회사는 기본적으로 좋은 회사 기술 블로그를 가지고 있습니다. 양질의 좋은 컨텐츠를 가지고 기술의 가야할 바도 제시하고 실제 하고 있는 일들을 잠깐씩 엿볼 수 있는 좋은 기회라고 볼 수 있다. </p>
<ul>
<li><p><a href="http://woowabros.github.io/" target="_blank" rel="external">우아한 형제들</a></p>
<ul>
<li>배달의 민족으로 O2O 의 새로운 지평을 열고 있는 쪽의 개발 블로그. 최근 MSA 글이 화제가 되었다. (<a href="http://woowabros.github.io/r&amp;d/2017/06/13/apigateway.html" target="_blank" rel="external">배민 API GATEWAY - spring cloud zuul 적용기</a>) 개발자들 모두가 쓰고 있다는 착각이 들 정도로 필자가 다양한 것이 특징. 그래서 글 마다 편차는 좀 존재한다.<br><img src="/images/wooa.png" alt="배민 API GATEWAY - spring cloud zuul 적용기"></li>
</ul>
</li>
<li><p><a href="http://d2.naver.com/home" target="_blank" rel="external">네이버 d2</a></p>
<ul>
<li>네이버 개발자들의 수준을 가늠해 볼 수 있는 좋은 블로그. 필자와 필력을 관리하는 것인지 대부분의 아티클들이 양과 질에서 여타 다른 회사 기술 블로그보다 평타이상을 한다. 번역글도 가끔 올라 오는데 2012년 화제가 된 글인 <a href="http://d2.naver.com/helloworld/59361" target="_blank" rel="external">“브라우저는 어떻게 작동하는가”</a> 같은 내용은 아직도 유효하고 유익하다.<br><img src="/images/naver_d2.png" alt="브라우저는 어떻게 작동하는가"></li>
</ul>
</li>
</ul>
<p>이 외에도 <a href="http://tech.lezhin.com/" target="_blank" rel="external">레진 기술블로그</a>, <a href="http://tech.kakao.com/" target="_blank" rel="external">카카오 기술 블로그</a> 등의 찾아가 볼만한 내용들을 가진 곳들이 꽤 많이 존재한다. 전통적인 기술 창고인 <a href="https://msdn.microsoft.com/ko-kr/default.aspx" target="_blank" rel="external">MSDN</a>, <a href="https://code.facebook.com/" target="_blank" rel="external">페이스 북 코드</a> 및 [구글 개발자 사이트][<a href="https://developers.google.com/" target="_blank" rel="external">https://developers.google.com/</a>] 에서 개발 흐름을 찾아 보는 것도 굉장한 도움이 된다.</p>
<h3 id="팀-블로그-혹은-큐레이션-블로그"><a href="#팀-블로그-혹은-큐레이션-블로그" class="headerlink" title="팀 블로그 (혹은 큐레이션 블로그)"></a>팀 블로그 (혹은 큐레이션 블로그)</h3><p>개발자들끼리 모여서 블로그를 같이 진행하는 경우도 몇군데 있는데, 이런 경우는 서로의 철학과 가고자 하는 방향이 잘 맞는 사람들끼리 모여서 진행을 하고 있다. 필자가 활동하는 팝잇(popit), 개발바보들(devpools)도 그 연장선상에 있다고 볼 수 있다. 주제를 정해서 같이 연재할 수 있는 장점도 있고 서로의 발전을 도모한다는 점에서도 이로운 방향이라고 볼 수 있다.</p>
<ul>
<li><p><a href="http://blog.weirdx.io/" target="_blank" rel="external">이상한 모임</a></p>
<ul>
<li>개발자(Dev), 오프모임(OFFLINE), 코드(CODE) , IT 기기(GADGET) 등의 광범위한 관심사를 가지고 있는 사람들이 모여서 자신들의 블로그를 올리는 형태의 블로그. 오프모임도 종종 진행하고 관리자가 이벤트를 꽤나 많이 주체하는 흥미로운 사이트다.<br><img src="/images/weird.png" alt="weird"></li>
</ul>
</li>
<li><p><a href="http://www.popit.kr" target="_blank" rel="external">팝잇</a></p>
<ul>
<li>주최측이 꽤나 개발자들 사이에서는 알려진 사람들로 이루어진 사이트. 주로 개발에 관련된 이야기만 한다. 좋은 점은 양질의 글을 읽을 수 있다는 점이고 나쁜 점은 개발자들의 관심사가 꽤나 비슷비습하다는 점이다.</li>
</ul>
</li>
</ul>
<h3 id="소셜-스타-개인-블로그"><a href="#소셜-스타-개인-블로그" class="headerlink" title="소셜 스타(개인 블로그)"></a>소셜 스타(개인 블로그)</h3><p>보통 트위터나 페이스북에서 유명 개발자 혹은 IT 쪽 인플루언서들을 찾아가 보면 대부분은 블로그가 그 원동력이다. 트위터나 페이스북은 그 사람의 지속적인 관심사나 생각의 흐름을 잡아내는데 굉장히 유용하다. 지금부터 언급되는 사람들은 소셜미디어에서도 유명하지만 블로그를 지속적으로 관심을 가지고 봐도 될만한 사람이다. 이 챕터는 기술의 깊이와 넓이에 따라서 굉장히 많은 사람이 호 불호가 갈릴 수 있어서 모두가 이해할 수 있는 선에서 그 영역을 마무리 짓고자 한다.</p>
<ul>
<li><p><a href="https://twitter.com/kwang82" target="_blank" rel="external">광파리</a></p>
<ul>
<li>트위터와 블로그 둘중 무엇을 링크를 걸까 하다가 트위터를 걸어 두었다. 트위터에 페북과 블로그 주소가 모두 존재하므로 방문하는데에는 지장이 없을 듯 한다. 원래 한국 경제 신문 IT 전문 기자였다가 지금은 D캠프 센터장. 전직 기자의 안목에서 보는 트렌드를 쫒아갈 수 있어서 큰 그림을 파악하는데에는 도움이 된다.</li>
</ul>
<ul>
<li><a href="https://blog.outsider.ne.kr/" target="_blank" rel="external">아웃사이더</a></li>
</ul>
<ul>
<li>굉장히 광범위하게 기술을 건드리는 개발자. 자바 이야기는 찾아 보기 힘들지만 주로 Node.js 와 자바스크립트. AWS 등의 기술들을 접할 수 있다. 깊이 있게 다루는 것에서 자기의 삽질기 까지. 필자의 관심사항과 굉장히 유사한 부분들을 건드린다. </li>
</ul>
<ul>
<li><a href="https://twitter.com/xguru?lang=ko" target="_blank" rel="external">xguru</a></li>
</ul>
<ul>
<li>최근에는 외부 블로깅과 소셜 활동을 많이 하진 않는 듯 한데, 한번 올리는 글에 힘이 있고 많은 사람들이 관심을 가진다. 예전 KTH 관련된 내용들을 많이 엿볼 수 있었다면 최근에는 레진의 내용들을 확인할 수 있다.</li>
</ul>
<ul>
<li><a href="http://blog.benelog.net/" target="_blank" rel="external">정상혁</a></li>
</ul>
<ul>
<li>여기는 한 사람의 개발닌자를 만난 듯한 인상을 주는 블로그. 넓이 보다는 깊이를 추구하는 독자에게는 도움이 될 수 있는 심오한 내용들을 많이 블로깅하고 있다. 오피스를 쓰냐 안쓰냐에 따라 개발자 혹은 개발회사로 구분할 수 있다는 철학을 가진 개발자</li>
</ul>
<ul>
<li><a href="http://blog.doortts.com/" target="_blank" rel="external">채수원</a></li>
</ul>
<ul>
<li>국내에 TDD 에 대해서 한 사람을 꼽으라고 한다면 꼭 이야기 하고 싶은 한 사람. 하지만 그 외에도 여러가지 이야기를 쓰고 잡담도 곧잘 올라오는데 필력이 대단해서 그 잡담마저 흥미롭다.</li>
</ul>
</li>
</ul>
<p>이상 간단하게 정리해 보았는데 아마도 더 유명한 사람들이 있을 수 있고 누군가의 취향은 다를 수 있다.. 그래서 깃헙의 다음 프로젝트를 조금은 더 자세한게 설명해 볼까 한다.</p>
<h2 id="8월의-프로젝트-Awesome-Devblog"><a href="#8월의-프로젝트-Awesome-Devblog" class="headerlink" title="8월의 프로젝트 - Awesome Devblog"></a>8월의 프로젝트 - Awesome Devblog</h2><p>지난번에 한번 설명을 한 대로 깁허브(github) 에는 여러 형태의 프로젝트가 존재하는데 그 중 하나라 Awesome 으로 시작되는 북마크 프로젝트들이 존재한다. 지금 소개할 프로젝트는 한국 기준으로 먼저 작성이 된 좋은 개발자(개발 블로그) 모음이다.<br>아마도 위에 정리한 사람들 혹은 팀은 거의 대부분 이 프로젝트에 정리가 되어 있다.</p>
<p><img src="/images/devblog.png" alt="awesome devblog"></p>
<p>일단 목차는 다음과 같다.</p>
<ul>
<li><a href="https://github.com/sarojaba/awesome-devblog#%EA%B5%AD%EB%82%B4-%EA%B0%9C%EC%9D%B8-%EC%82%AC%EC%9D%B4%ED%8A%B8" target="_blank" rel="external">국내 개인 사이트</a></li>
<li><a href="https://github.com/sarojaba/awesome-devblog#%EA%B5%AD%EB%82%B4-%ED%8C%80-%EC%82%AC%EC%9D%B4%ED%8A%B8" target="_blank" rel="external">국내 팀 사이트</a></li>
<li><a href="https://github.com/sarojaba/awesome-devblog#%EA%B5%AD%EC%99%B8-%EA%B0%9C%EC%9D%B8-%EC%82%AC%EC%9D%B4%ED%8A%B8" target="_blank" rel="external">해외 개인 사이트</a></li>
<li><a href="https://github.com/sarojaba/awesome-devblog#%EA%B5%AD%EC%99%B8-%ED%8C%80-%EC%82%AC%EC%9D%B4%ED%8A%B8" target="_blank" rel="external">해외 팀 사이트</a></li>
</ul>
<p>팀 안에 회사에 대한 구분은 없이 가나다 순 알파벳 순으로 소팅을 해 둔 사이트다.<br>이 안에서 한명 한명 찾아 보면서 시간을 보내도 휴가를 재미있게 즐길 수 있다.</p>
<p>하지만 이런 것들을 내가 실시간으로 최신 트렌드를 받아볼 수는 없을까? 이런 생각을 하면 누군가는 이미 작성을 해 두었다.<br>깃헙에 RSS 프로젝트를 만들었고( 아 이런 수고를 하다니 정말 대다나다.) RSS도 공개 되어 있다.<br><a href="https://github.com/BenjaminKim/awesome-blogs" target="_blank" rel="external">깃헙 프로젝트</a><br><a href="https://awesome-blogs.petabytes.org/feeds?group=dev" target="_blank" rel="external">RSS : https://awesome-blogs.petabytes.org/feeds?group=dev</a></p>
<p><img src="/images/devblog-rss.png" alt="devblog-rss"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;이 글은 회사 기술 블로그에 올리고 있는 내용입니다. 회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기를 진행
    
    </summary>
    
    
      <category term="tech trend, social media" scheme="http://keen.devpools.kr/tags/tech-trend-social-media/"/>
    
  </entry>
  
  <entry>
    <title>ES2015 리팩토링 – 2. 빠레꽁(var let const)</title>
    <link href="http://keen.devpools.kr/2017/08/01/refactoring02/"/>
    <id>http://keen.devpools.kr/2017/08/01/refactoring02/</id>
    <published>2017-08-01T02:36:53.000Z</published>
    <updated>2017-08-04T15:12:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 는 언제나 쉽지만 또 언제나 어렵다.<br>이런 개념을 처음 갖게 된게 아마도 변수가 내가 생각하는데로 작동하지 않던 시점이었던 것으로 기억한다.<br>개념이 생기기 전에 var를 변수 선언 해도 작동이 되고 생략해도 작동이 된다는 사실에 그냥 작성하다가 어느 새<br>나의 코드가 전역 변수가 되어 팀원 모두가 고생을 겪고, 변수 선언을 위에다 했는데 아래에서 올라오는 등의 경우의<br>내 머리속의 컨셉과 다르게 동작하는 경험을 겪고 나면 정말 혼란스러워 지는데 거기다 더해 지금 이글에서 언급하게<br>될 스코프, 호이스팅 등을 읽고나면 정말로 쉽지 않다라는 사실을 겪게 된다.  </p>
<p>ES2015 부터는 변수가 두가지 더 추가가 되었다. 이번엔 그 변수들을 어떻게 이해하고 언제 사용해야 할 지에 대해서 다뤄보겠다.</p>
<h2 id="JavaScript-변수-var-에-대해서"><a href="#JavaScript-변수-var-에-대해서" class="headerlink" title="JavaScript 변수 var 에 대해서"></a>JavaScript 변수 var 에 대해서</h2><p>var 밖에 없었으니까 JavaScript 변수 var 에 대해서라고 제목을 정하고 들어가 보자.<br>몇가지 특징만 짚어 보고 넘어가겠다. JavaScript 변수에 대한 조금 더 자세한 내용은 JavaScript Definite Guide 를 추천한다.</p>
<h3 id="1-변수의-var-선언이-없으면-코드의-복잡성이-증가하게-된다"><a href="#1-변수의-var-선언이-없으면-코드의-복잡성이-증가하게-된다" class="headerlink" title="1. 변수의 var 선언이 없으면 코드의 복잡성이 증가하게 된다."></a>1. 변수의 var 선언이 없으면 코드의 복잡성이 증가하게 된다.</h3><p>일단 코드를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div><div class="line"><span class="comment">//혹은 조건문 블럭으로 진행해도 결과는 같다.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">    x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JavaScript는 나름 중첩시킨 함수 임에도 불구하고 x는 4를 출력하게 되어 있다. var 선언을 하지 않고 작성하면 기본적으로<br>직전의 상위 스코프의 변수를 찾게 되어 있는데 직전에도 선언이 되어 있지 않으면 하나 더 상위를 찾아 가게 된다. 이런식으로<br>의도하지 않은 전역 변수를 만들어 내고는 한다.</p>
<p>그렇다고 해서 선언 하기 전에 마구 사용해도 되느냐 하면 그것은 또 아닌 것이 x=4 위에 사용하면 undefined 를 출력하도록<br>되어 있다.</p>
<h3 id="2-호이스팅에-대해서"><a href="#2-호이스팅에-대해서" class="headerlink" title="2. 호이스팅에 대해서"></a>2. 호이스팅에 대해서</h3><p>아래 두 코드는 위의 전역 변수에 대한 개념과 변수 스코프 끌어올림(호이스팅)에 대한 개념이 섞여 있는 예제이다.<br>두 코드의 차이점을 한 눈에 알아 볼 수 있을까?</p>
<ul>
<li><p>var 선언을 안 한 경우</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  x=<span class="number">3</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"inner"</span>,x);</div><div class="line">    x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>var 선언을 한 경우</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  x=<span class="number">3</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"inner"</span>,x);</div><div class="line">  <span class="keyword">var</span> x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>var 선언을 안 한 경우 경우는 ( inner =3 , outer = 4 ) 의 결과가, var 선언을 한 경우 경우는 inner는<br>undefined 가 outer의 경우는 3 이 떨어진다.<br>왜 그럴까. var 선언을 안 한 경우 경우 결국 x의 스코프는 inner 안에서 찾을 수 없어서 outer 까지 가서 찾아 보게 된다.<br>호이스팅이라는 어려운 말로 적혀있지만 이 “찾아보게 된다”라는 개념으로 일단 이해하고 넘어가셔도 많은 경우에는 적용이 된다.<br>조금 더 확실한 의미로는 변수 선언을 끌어올림이 더 적절한 풀이가 되겠지만.<br>이렇게 이해하고 나면 두번째의 “var 선언을 한 경우 경우”는 오히려 더 자세히 이해가 된다.<br>var 선언을 한 시점에서는 스코프는 해당 함수 블럭만 찾게 될 것이고 선언이 안된 체로 사용이 되었으니 말이다.</p>
<p>코딩 인터뷰에나 나올 만한 이 문제는 우리가 일반적으로 JavaScript를 처음 접할 때의 난해함으로 다가온다.<br>블럭이 스코프를 결정하지 않는다니. 기상 천외한 언어라고 볼 수 있다.<br>하지만 이렇게 함으로써 브라우저 상에서 사람들이 처음 HTML 스펙과 적절히 섞을 수 있도록 사용 되었고(script 태그가 여기 저기서 얼마나 많이 import 되고 있는지 생각해 보라.) 이 호이스팅과 전역변수를 활용한 팁들도 생겨나기 시작했다.</p>
<p>하지만 지금의 상황은 자바스크립트의 코드베이스가 예전과는 상상도 할 수 없을만큼 커져버렸다.<br>전역변수를 사용한다는 것은 점점 죄악시 되어가고 있고, 좋은 패턴도 아니다.</p>
<h3 id="3-비동기-함수에서의-변수-사용"><a href="#3-비동기-함수에서의-변수-사용" class="headerlink" title="3. 비동기 함수에서의 변수 사용"></a>3. 비동기 함수에서의 변수 사용</h3><p>아래의 코드를 살펴보면 비동기 함수의 경우는 변수가 내가 원하는 시점과 원하는 바가 다르게 나올 때가 있다는 것을 파악할 수 있다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(numbers[i]);</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//결과는 undefined가 세번 나온다.</span></div></pre></td></tr></table></figure></p>
<p>물론 저런 코드가 프로젝트에서 사용되어질 리는 없지만 setTimeout이 아니라 AJAX 호출이라고 생각해 보자.<br>JavaScript가 눈에 익은 사람은 저 코드가 굉장히 당연하게 느껴지겠지만 콜백함수라던지 받아서 실행해야 하는 경우라면<br>코드에 대한 명확한 스펙을 알고 있더라도 실수할 수 있는 여지는 많아진다.</p>
<h2 id="let-const-에-대한-오해"><a href="#let-const-에-대한-오해" class="headerlink" title="let, const 에 대한 오해"></a>let, const 에 대한 오해</h2><p>이해도 하기 전에 오해를 이야기 하니 무슨 이야기인가 싶을 수도 있겠으나 ES2015 의 스펙이 나오면서 let 과 const 가 어떤 전역변수와 지역변수를 해결하는 전가의 보도처럼 이야기 되는 경우가 있어서 그런것 만은 아니라는 이야기를 먼저 하고 싶다.</p>
<p>여전히 ES2015에도 변수를 선언하지 않고 작업을 하면 함수 스코프를 따라 체이닝 작업(찾아보게 된다)을 통해 변수에 값을 할당하게 된다. 이것은 바꿀 수도 없고 바꿔서도 안된다고 보인다.<br>하지만 아래 코드를 보자. 위의 var로 선언한 코드에서 let 으로만 선언했을 뿐이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  x=<span class="number">3</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"inner"</span>,x);</div><div class="line">  <span class="keyword">let</span> x=<span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line">  inner();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"outer"</span>,x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>두가지의 결과가 다르게 나는데 var로 선언을 할 경우는 undefined 라는 값이 나오고( 에러가 아니다!)<br>let의 경우는 에러를 내뱉게 된다. (명시적인 에러를 뱉는 것과 undefined를 처리하는 것은 개발 차원에서 다뤄야 할 수준이 달라진다)</p>
<h3 id="let은-무엇이-다를까"><a href="#let은-무엇이-다를까" class="headerlink" title="let은 무엇이 다를까"></a>let은 무엇이 다를까</h3><p>앞서 언급했던 선언을 하지 않고 사용을 하면 에러가 나도록 설계가 되어 있다는 점이 일단 이야기가 되어지고 두번째는 반복문 안에서 비동기 동작이 다르게 작동한다.  </p>
<p>이 부분도 코드를 먼저 보자. 먼저 소개한 코드에서 var를 let으로 바꿨을 뿐이다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(numbers[i]);</div><div class="line">  &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>개인적으로 이 부분은 조금 더 헷갈리게 된 것 같다. 비동기의 경우 var처럼 처리 되던것을 기본으로 생각해오던 JavaScript 개발자들에게는 오히려 혼란스럽게 다가올 수 있을 것으로 보이지만 이제는 비동기 때 변수가 따로놀지 않는 상황을 let으로 작성하면 만들 수 있다는 점에서 의미가 있을 거 같다.</p>
<h3 id="const는-무엇이-다를까"><a href="#const는-무엇이-다를까" class="headerlink" title="const는 무엇이 다를까"></a>const는 무엇이 다를까</h3><p>다른 언어와 마찬가지로  const의 경우는 다시 할당하지 않는 상수의 역할을 한다. const 의 경우는 재할당 하려고 하면 에러가 난다.<br>let 과 비교하면 값을 재할당 할 수 없는 것 딱 한가지 말고는 다를 바가 없다.</p>
<h2 id="이제는-무조건-let-const다-외워라"><a href="#이제는-무조건-let-const다-외워라" class="headerlink" title="이제는 무조건 let, const다. 외워라."></a>이제는 무조건 let, const다. 외워라.</h2><p>브라우저는 지속적으로 발전하고 있고 그에 따른 성능도 올라가지만 한가지 확실한 것은 표준 스펙에 대한 성능은 언제나 일순위라는 것이다.<br>그 과정에서 let, const 는 기존의 var를 완전히 대체할 수 있는 뉴 스탠다드다. 현재는 var 가 아주 조금 (그것도 아주 조금) 성능적인 우위를 점하고 있지만 장기적으로 let, const 와의 성능은 거의 차이가 없어질 것으로 (오히려 더 나아질 것으로) 예상된다.</p>
<p>실제 진행한 것을 블로그에 포스팅한 사례도 속속 나오고 있다.</p>
<p>성능 비교 : <a href="https://gomugom.github.io/let-vs-var-performance-compare/" target="_blank" rel="external">https://gomugom.github.io/let-vs-var-performance-compare/</a></p>
<p>내용을 한 부분만 인용하면</p>
<blockquote>
<p>불과 1년 전 var와 let의 성능비교 테스트에 대한 블로그 포스팅을 읽은 적이 있는데, 당시에는 var가 let보다 압도적으로 빠르게 연산을 수행했던 것으로 기억한다. 그 1년 사이 둘의 성능은 같아졌다. 그만큼 최적화가 이루어져왔었기 때문이다. 그렇다면 앞서 확인했던 외부스코프에 대한 접근 성능 역시 점차 최적화가 될 것이라 기대한다.</p>
</blockquote>
<p>이 블로그 포스팅도 2017년 1월의 일이니 지금은 더 빨라졌을 것으로 보인다.</p>
<p>그리고 앞서 언급되어 있었던 부분 중의 하나인 에어비앤비의 사례에서도 보듯이 엔지니어링에서 표준을 따라 작업을 하는 것이 현재의 성능을 쫓아가는 것 보다 장기적으로 이득인 점도 간과할 수는 없다.</p>
<h2 id="프로젝트-리팩토링"><a href="#프로젝트-리팩토링" class="headerlink" title="프로젝트 리팩토링"></a>프로젝트 리팩토링</h2><p>이제는 standup 프로젝트를 한번 들여다 보자. ( github 페이지에 접속해서 standup 검색을 하거나 아래 URL을 클릭해서 들어가 보자. )</p>
<p><a href="https://github.com/ehrudxo/standup" target="_blank" rel="external">https://github.com/ehrudxo/standup</a></p>
<p>주소를 복사해서 git clone 명령을 통해 사용하고 있는 로칼 PC에 복사한 후에 가장 마지막 작업인 day7 을 체크아웃 받아 보자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$git</span> <span class="built_in">clone</span> https://github.com/ehrudxo/standup &amp; <span class="built_in">cd</span> standup &amp; git chekcout day7</div></pre></td></tr></table></figure>
<p>이후 editor 를 구동시킨 후에 탐색기를 열고 프로젝트에서 var를 검색해 보자. 다음 8개의 파일이 var로 이루어져 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">REAMDE.md</div><div class="line">src/__tests__/CloudDao.js</div><div class="line">src/actions/Article.js</div><div class="line">src/config.js</div><div class="line">src/Editor.js</div><div class="line">src/FileUtil.js</div><div class="line">src/FirebaseDao.js</div><div class="line">src/Login.js</div></pre></td></tr></table></figure>
<p>이 중 README.md 파일은 다른 파일을 설명하면서 만든 파일이므로 나머지 파일을 바꾸고 리팩토링 해 보자. 먼저 FileUtil.js를 살펴보면<br>storageRef 와 ulpoadTask 가 var 로 지정되어 있다. 그런데, storageRef 를 살펴보니 다른데서 사용하고 있지 않다.  uploadTask만 재사용 되므로 storageRef는 삭제하고 uploadTask는 다시 값이 할당되지 않으므로 const로 변경 해보자.</p>
<p>이번에는 src/actions/Article.js 를 살펴 보자. 이번에는 독자들을 위해 코드 스니펫을 가지고 와서 확인해 보도록 한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArticles</span>(<span class="params">articles</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> items = [];</div><div class="line">  articles.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">article</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> item = article.val();</div><div class="line">    item[<span class="string">'key'</span>] = article.key;</div><div class="line">    items.push(item);</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">if</span>(items &amp;&amp; items.length&gt;<span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">      type : ALL,</div><div class="line">      articles : items.reverse()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>여기서 items 는 push 명령어를 통해서 지속적으로 변경이 되니까 let으로 지정을 해야 할 것 같지만 참조형은 변경이 가능하므로 const 를 사용한다.<br>그리고 item 도 다시 할당하지 않으므로 모두 const 로 변경한다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getArticles</span>(<span class="params">articles</span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> items = [];</div><div class="line">  articles.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">article</span>)</span>&#123;</div><div class="line">    <span class="keyword">const</span> item = article.val();</div><div class="line">    item[<span class="string">'key'</span>] = article.key;</div><div class="line">    items.push(item);</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">if</span>(items &amp;&amp; items.length&gt;<span class="number">0</span>)&#123;</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">      type : ALL,</div><div class="line">      articles : items.reverse()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>이 후 나머지는 독자들이 변경해 보도록 하자.<br>그리고 제대로 동작하는지 확인하려면 다음의 명령어를 실행해 보자.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$npm</span> install &amp; npm start</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 는 언제나 쉽지만 또 언제나 어렵다.&lt;br&gt;이런 개념을 처음 갖게 된게 아마도 변수가 내가 생각하는데로 작동하지 않던 시점이었던 것으로 기억한다.&lt;br&gt;개념이 생기기 전에 var를 변수 선언 해도 작동이 되고 생략해도 작동이 
    
    </summary>
    
    
      <category term="JavaScript, Refactoring" scheme="http://keen.devpools.kr/tags/JavaScript-Refactoring/"/>
    
  </entry>
  
  <entry>
    <title>(tech-trend) 구루들이 찾는다는 테크 트렌드 - 해커뉴스</title>
    <link href="http://keen.devpools.kr/2017/07/07/tech-trend-02/"/>
    <id>http://keen.devpools.kr/2017/07/07/tech-trend-02/</id>
    <published>2017-07-07T10:00:00.000Z</published>
    <updated>2017-08-06T07:12:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>이 글은 회사 기술 블로그에 올리고 있는 내용입니다.<br>회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기가 다음번 이야기가 될 거 같습니다.</p>
<p>필자는 SDS Agile Core Team 에서 테크리드를 담당하고 있습니다.<br>OSGeo에서 오픈소스 활동을 하고 있습니다. 잘 모르는 기술에 대해서 낯선 사람들과 이야기 하면서 배워 나가는 것을 좋아합니다.</p>
</blockquote>
<h2 id="기술-트렌드에-관련해서-2-hacker-news"><a href="#기술-트렌드에-관련해서-2-hacker-news" class="headerlink" title="기술 트렌드에 관련해서 - 2. hacker news"></a>기술 트렌드에 관련해서 - 2. hacker news</h2><h3 id="클리앙"><a href="#클리앙" class="headerlink" title="클리앙"></a>클리앙</h3><p>한국에 Tech 커뮤니티 중에 유명한 곳으로 클리앙이라는 곳이 있다. 시대를 풍미했던 소니 PDA의 제품명을 따서 그 때 활동했던 전문가들이 만든 커뮤니티 사이트인데 왠만한 개발자나 덕질 좀 하는 사람들이라면 클리앙의 모공은 가지 않더라도 새로운 뉴스는 방문하는 것으로 알고 있다. 커뮤니티에 참여한 사람들이 가지고 오는 뉴스들이 다른 포탈 보다 좋은 점은 몇가지가 있는데 그 중에서도 취향이 비슷한 사람들이 몰린다는 것과 트렌드를 정확히 반영한다는 것. 그리고 댓글들을 통해 판단할 근거들을 파악할 수 있다는 것을 뽑을 수 있을 것이다.<br><img src="/images/clien.jpg" alt="클리앙"></p>
<h3 id="폴-그레이엄"><a href="#폴-그레이엄" class="headerlink" title="폴 그레이엄"></a>폴 그레이엄</h3><p>해커뉴스는 처음 들어보았을 수도 있겠지만 IT 분야에서 일한다고 하면 폴 그레이엄이라는 사람의 이름은 많이 들어봤을 것이다. 폴 그레이엄은 투자가이면서도 SNS 상의 수퍼스타면서 “<a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B6957684739" target="_blank" rel="external">해커와 화가</a>“라는 좋은 책을 쓴 사람이기도 하다. (한빛 미디어. 번역 임백준)<br>이 폴그레이엄의 Ycombinator 에서 news 서비스를 커뮤니티를 활용해서 하고 있는데 클리앙과 매우 흡사하다. 하지만 여기는 조금 더 전문적인 영역까지 다루고 있다.<br><img src="/images/paul.jpg" alt="폴 그레이엄"></p>
<p>폴 그레이엄의 ~ 시리즈는 구글 검색만 해도 국내 언론도 굉장히 많이 언급하고 있음을 알 수 있다.</p>
<p><img src="/images/paulsays.jpg" alt="폴 그레이엄의"></p>
<h3 id="해커뉴스"><a href="#해커뉴스" class="headerlink" title="해커뉴스"></a>해커뉴스</h3><p>이 해커뉴스가 돌아가는 방식은 좋아요를 많이 받을 수록 최상위에 배치되는 것 + 날짜 의 합으로 운영이 되는데 URL을 통해 데이타를 긁어오는 방법이 한참 유행했었는데 요즘에는 Firebase 와 함께 협업해서 API를 제공해 주는 서비스까지 제공해 주고 있다. ( 긁어가는 것도 대인배. 알아들 긁어가시는데 고생하시지 말고 알아서 긁어들 가시라고. )<br><img src="/images/hackernews.jpg" alt="해커 뉴스"></p>
<p><a href="https://news.ycombinator.com/" target="_blank" rel="external">해커뉴스 - https://news.ycombinator.com/</a></p>
<p><a href="https://github.com/HackerNews/API" target="_blank" rel="external">해커뉴스 API - https://github.com/HackerNews/API</a></p>
<p>굉장히 많은 사람들이 몰리는 것과 빠른 트렌드를 반영하는 것과 더불어 모든 뉴스를 다 읽기에는 하루가 모자랄 지경이라 좋은 뉴스를 선별해서 볼 수 있도록 해주는 서비스도 많은데 이 중에서 좋은 것 하나를 선택하면 최신 트렌드가 어떻게 돌아가는지를 놓치지 않고 읽어볼 수 있다.</p>
<h4 id="1-hacker-news-twitter"><a href="#1-hacker-news-twitter" class="headerlink" title="1. hacker news twitter"></a>1. hacker news twitter</h4><p><a href="https://twitter.com/search?f=users&amp;vertical=default&amp;q=hacker%20news&amp;src=typd" target="_blank" rel="external">트위터 서비스들</a></p>
<p><img src="/images/twitters.jpg" alt="해커뉴스 트위터들"></p>
<p>이중에서 가장 처음에 올라온 것만 개인적으로 팔로우 하고 있지만 시간이 된다면 차이점을 파악해서 잘 선택하시는 것이 도움이 될 것으로 보인다.</p>
<h4 id="2-hacker-news-newsletter"><a href="#2-hacker-news-newsletter" class="headerlink" title="2. hacker news newsletter"></a>2. hacker news newsletter</h4><p>이메일로 뉴스레터로 보내주는 서비스를 하는 것도 있다.<br><a href="http://www.hackernewsletter.com/" target="_blank" rel="external">http://www.hackernewsletter.com/</a><br>이메일을 제출하면 해당 메일주소로 확인메일이 날라오고, 그 메일에 확인 버튼을 눌러 구독을 확정지을 수 있다.</p>
<h4 id="3-Mobile-apps"><a href="#3-Mobile-apps" class="headerlink" title="3. Mobile apps"></a>3. Mobile apps</h4><p>앱스토어나 구글 플레이에서 hacker news 라고 검색을 하면 해당 앱이 스크롤을 다 채울만큼 나오는 것을 확인할 수 있다.</p>
<h3 id="영알못이라구요"><a href="#영알못이라구요" class="headerlink" title="영알못이라구요?"></a>영알못이라구요?</h3><p>언어적인 어려움이 당연히 존재를 하는데, 이런 경우는 국내에서 트렌드 서비스를 하고 있는 몇몇 블로거들을 통해서 관련 내용들을 얻을 수 있는데, 유명한 기술 트렌드를 서비스 해주는 사람으로는 outsider 와 nolboo 가 유명하다. 국내에서 트렌드 서비스를 해 주는 경우는 다음번에 알아보도록 하겠다.</p>
<h2 id="7월의-프로젝트-Best-websites-a-programmer-should-visit"><a href="#7월의-프로젝트-Best-websites-a-programmer-should-visit" class="headerlink" title="7월의 프로젝트 - Best-websites-a-programmer-should-visit"></a>7월의 프로젝트 - Best-websites-a-programmer-should-visit</h2><p>7월 7일 현재 한달동안(6/8부터) 가장 Star(좋아요)를 가장 많이 받은 프로젝트는 <a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit" target="_blank" rel="external">“Best-websites-a-programmer-should-visit”</a> 이다. </p>
<p><img src="/images/bestwww.jpg" alt="best"></p>
<p>작년 한해 동안은 awesome 시리즈가 유명했는데 awesome 시리즈는 예를 들어 tensorflow와 관련해서 괜찮은 사이트나 문서를 모아놓은 markdown 파일을 만들어 놓고 링크를 걸어 놓고 찾아가기 좋은 즐겨찾기를 하는 형식이다.<br>ex) <a href="https://github.com/jtoy/awesome-tensorflow" target="_blank" rel="external">awesome tensorflow</a><br>awesome tensorflow 만해도 8000개의 star를 받았다. </p>
<p>올해는 약간 네이밍에 질려하는 분위기인 것 같지만 즐겨찾기는 언제나 도움이 되니까 다들 star 버튼을 누르는게 즐겨 찾기용으로 사용되는 것을 알 수 있다.</p>
<p>처음 시작은 when you get stuck 섹션으로 시작한다. 한국말로 해석하면 “~을 하다가 막혔을때” 라는 것보다 더 적절한 해석이 없을 거 같은데 Stack Overflow 와 Quora 는 당연히 소개가 되어 있고 나머지 세군데는 한번 살펴 보는 것도 괜찮아 보인다.</p>
<p>두번째는 뉴스인데 당연히 처음부터 Hacker news 가 나온다. 관련된 사이트만도 두개가 더 있다. </p>
<p><img src="/images/bestnews.jpg" alt="bestnews"></p>
<p>이렇게 프로젝트를 잘 정리해 놓은 사이트는 늘 깃헙의 베스트 단골 메뉴인데 적어도 한달 단위로 올라오는 트렌딩에서는 참조할 만하다. 개발자들이 꼭 참조해야할 사이트가 이렇게 많았다는 것도 놀랍지만 이제는 이런 사이트에서 공통으로 나오는 이야기들을 잘 모아서 보여주는 서비스를 한번 기획해 보는 것도 굉장히 유익해 보인다.<br>혹시 같이 할 사람 있다면 언제든지 연락주면 같이 해 보고 싶다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;이 글은 회사 기술 블로그에 올리고 있는 내용입니다.&lt;br&gt;회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기가
    
    </summary>
    
    
      <category term="tech trend, hacker news" scheme="http://keen.devpools.kr/tags/tech-trend-hacker-news/"/>
    
  </entry>
  
  <entry>
    <title>feedwordpress를 설치하다</title>
    <link href="http://keen.devpools.kr/2017/06/09/feedwordpress/"/>
    <id>http://keen.devpools.kr/2017/06/09/feedwordpress/</id>
    <published>2017-06-09T12:34:46.000Z</published>
    <updated>2017-06-09T12:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>atom, rss 를 지원해 주는 feedwrodpress 를 설치했다.<br>잘 활용될 수 있으면 좋을 듯하다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;atom, rss 를 지원해 주는 feedwrodpress 를 설치했다.&lt;br&gt;잘 활용될 수 있으면 좋을 듯하다.&lt;/p&gt;

    
    </summary>
    
    
      <category term="atom,rss" scheme="http://keen.devpools.kr/tags/atom-rss/"/>
    
  </entry>
  
  <entry>
    <title>헤드리스 크롬과 selenium2의 조합을 사용해 보자 with node</title>
    <link href="http://keen.devpools.kr/2017/06/07/about-test/"/>
    <id>http://keen.devpools.kr/2017/06/07/about-test/</id>
    <published>2017-06-07T04:31:34.000Z</published>
    <updated>2017-06-08T06:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>최근에 headless chrome 이 나름 화제가 되어서 돌았는데 이 headless 라는 의미가 어떻게 쓰이는지 잘 모르는 사람들을 위해 이야기를 하고 넘어갈까 한다.</p>
<h2 id="headless-browser"><a href="#headless-browser" class="headerlink" title="headless browser"></a>headless browser</h2><p>headless browser는 기본적으로 GUI 없는 웹 브라우저를 의미한다.  </p>
<blockquote>
<p>“A headless browser is a web browser without a graphical user interface.”<br>출처 : <a href="http://blog.arhg.net/2009/10/what-is-headless-browser.html" target="_blank" rel="external">What is a headless browser?</a></p>
</blockquote>
<p>즉 CLI(Command Line interface)에서만 다루는 브라우저를 이야기 한다.유명한 헤드리스 브라우저로는  phantomJS 가 있다.  </p>
<p>헤드리스 브라우저가 사용되는 예는 여러가지가 있는데 좋은 예로는 테스트 자동화를 할 수 있고 데이타를 긁어오기(scraping) 하는 데 사용되고 스크린샷을 뜨는데에도 손쉽게 사용된다. 웹페이지 반응을 자동으로 스크립팅할 수 있는 부분도 존재한다.나쁜 예로는 DDOS 공격을 하는데 사용되기도 하고, 자동화를 좋지 않은데에 쓰이기도 한다는 것이다.</p>
<h2 id="selenium은-어떻게-다른가"><a href="#selenium은-어떻게-다른가" class="headerlink" title="selenium은 어떻게 다른가"></a>selenium은 어떻게 다른가</h2><p>셀레니엄은 태생 자체가 다르다고 보면 된다. 헤드리스 브라우저는 범용적인 목적에 따라 CLI환경에서 브라우저 환경을 에뮬레이션 하는 것이라고 하면 selenium은 브라우저 플러그인을 넣고 테스트를 실행시킨다. 서버 사이드에서 테스트에 관련된 실행을 시킬 수 있는 리모트 컨트롤러가 존재하고 다양한 브라우저를 지원하기 위해 드라이버들을 제공하는데 webdriver 라고 불려진다. 이후 버전이 업데이트 되었다.  </p>
<p>클라이언트 서버 구조로 서버 사이드와 RC(Remote Control)로 구성되어 있던 것을 webdriver와 결합하면서 현재의 selenium2가 된 것이다.</p>
<p><img src="/images/seleniumhq.jpg" alt="selenium1 + webdriver = selenium2"></p>
<p>즉 CLI 툴로 사용할 수 있는 헤드리스 크롬의 경우는 다양한 브라우저를 테스트의 목적으로 사용해야 하는 범용 테스트 목적 보다는 다른 용도로 많이 사용될 것으로 보인다. <del>DDOS machine?</del></p>
<h2 id="자-그러면-node-환경에서-selenium2를-사용해-보자"><a href="#자-그러면-node-환경에서-selenium2를-사용해-보자" class="headerlink" title="자 그러면 node 환경에서 selenium2를 사용해 보자."></a>자 그러면 node 환경에서 selenium2를 사용해 보자.</h2><p>nightwatch 혹은 webdriverio는 node 환경에서 selenium2를 사용할 수 있게 해 준다. 옵션과 홈페이지, 구글 트렌드를 생각하면 nightwatch를 이용해야겠지만 일단 간단하게 사용하기 위해 webdriver로 실행을 해 보자.(robotframework도 같이 고려)</p>
<p>전역 옵션으로 webdriverio를 아래와 같이 설치한다.(nightwatch의 경우도 같이 진행할 수 있음.)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;npm install -g webdriverio</div></pre></td></tr></table></figure></p>
<p>selenium2는 다음과 같은 명령으로 내려받을 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;curl -O http://selenium-release.storage.googleapis.com/3.0/selenium-server-standalone-3.4.0.jar</div></pre></td></tr></table></figure></p>
<p>크롬용 웹드라이버 -chromedriver를 받아서 압축을 풀고 PATH에 적용 시켜 준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;curl -O https://chromedriver.storage.googleapis.com/index.html?path=2.29/chromedriver_mac64.zip</div></pre></td></tr></table></figure></p>
<h2 id="headless-chrome-을-설치-한다"><a href="#headless-chrome-을-설치-한다" class="headerlink" title="headless chrome 을 설치 한다."></a>headless chrome 을 설치 한다.</h2><p>이 경우는 며칠전만 해도 canary를 쓴다고 했지만 지금은 크롬 최신버전이면 다음의 옵션만으로 실행할 수 있다.(MacOS 의 경우)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; chrome --headless --disable-gpu --screenshot &quot;http://devpools.kr&quot;</div></pre></td></tr></table></figure></p>
<h2 id="테스트-코드-작성"><a href="#테스트-코드-작성" class="headerlink" title="테스트 코드 작성"></a>테스트 코드 작성</h2><p>아래와 같이 테스트 코드를 작성하고 나면 일단은 selenium2 기반의 테스트 프레임워크의 시작을 했다고 보면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//test.js</span></div><div class="line"><span class="keyword">var</span> webdriverio = <span class="built_in">require</span>(<span class="string">'webdriverio'</span>);</div><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">    desiredCapabilities: &#123;</div><div class="line">        browserName: <span class="string">'chrome'</span>,</div><div class="line">        chromeOptions: &#123;</div><div class="line">            args: [</div><div class="line">                   <span class="string">'headless'</span>,</div><div class="line">                   <span class="string">'disable-gpu'</span>,</div><div class="line">               ],</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">webdriverio</div><div class="line">    .remote(options)</div><div class="line">    .init()</div><div class="line">    .url(<span class="string">'http://www.devpools.kr'</span>)</div><div class="line">    .getTitle().then(<span class="function"><span class="keyword">function</span>(<span class="params">title</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Title was: '</span> + title);</div><div class="line">    &#125;)</div><div class="line">    .end();</div></pre></td></tr></table></figure>
<p>결과는 다음과 같다.</p>
<p><img src="/images/headlessscraping.jpg" alt="개발바보들의 타이틀을 긁어왔다"></p>
<p>해당 소스는 깃헙의 다음 링크에서 받아볼 수 있다.<br><a href="https://github.com/ehrudxo/headlesssample" target="_blank" rel="external">https://github.com/ehrudxo/headlesssample</a></p>
<p>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;최근에 headless chrome 이 나름 화제가 되어서 돌았는데 이 headless 라는 의미가 어떻게 쓰이는지 잘 모르는 사람들을 위해 이야기를 하고 넘어갈까 한다.&lt;/p&gt;
&lt;h2 id=&quot;headless-browser&quot;&gt;&lt;a href=&quot;#h
    
    </summary>
    
    
      <category term="web test, test suite, headless chrome, selenium" scheme="http://keen.devpools.kr/tags/web-test-test-suite-headless-chrome-selenium/"/>
    
  </entry>
  
  <entry>
    <title>(tech-trend) 기술트렌드에 대한 블로깅을 시작하며</title>
    <link href="http://keen.devpools.kr/2017/05/31/tech-trend-01/"/>
    <id>http://keen.devpools.kr/2017/05/31/tech-trend-01/</id>
    <published>2017-05-31T07:04:04.000Z</published>
    <updated>2017-08-06T07:12:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>이 글은 회사 기술 블로그에 올리고 있는 내용입니다.회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기가 다음번 이야기가 될 거 같습니다.</p>
<p>필자는 Agile Core Team 에서 테크리드를 담당하고 있습니다.<br>OSGeo에서 오픈소스 활동을 하고 있습니다. 잘 모르는 기술에 대해서 낯선 사람들과 이야기 하면서 배워 나가는 것을 좋아합니다.</p>
</blockquote>
<h2 id="기술-트렌드에-관련해서-1-github"><a href="#기술-트렌드에-관련해서-1-github" class="headerlink" title="기술 트렌드에 관련해서 - 1. github"></a>기술 트렌드에 관련해서 - 1. github</h2><p>개발자들이 기술 트렌드를 얻는 루트는 생각보다 많지는 않다. 소셜 미디어에서 유명한 개발자들을 팔로우 하거나 그룹에 가입하는 방법들이 많은데, <u><strong>필자가 주로 기술 트렌드를 얻는 되는 루트는 github 과 hacker news다</strong></u>. 물론 기술 트렌드를 얻는 방법은 여러가지다. 오늘은 먼저 github 에서 어떻게 기술 트렌드를 따라갈 수 있는지에 대해서 이야기를 잠깐 언급하고 현재 핫한 프로젝트 하나를 소개하고자 한다.</p>
<p>이 글을 읽게 될 대부분의 독자들은 아마도 github를 잘 알고 있으리라고 생각이 든다.  하지만, 그럼에도 불구하고 윤석찬 님이 정의하신 깃허브에 대해서 다시 한번 상기 하고자 한다</p>
<blockquote>
<p>“gitHub는 한마디로 ‘소셜 소스 코드 공유’를 모토로 한 분산형 협업 개발 호스팅 서비스 입니다. 생소한 개념 같지만 한마디로 ‘오픈 소스 개발 모델’에다가 요즘 한창 유행인 ‘소셜 네트웍’을 접목했다고 보시면 됩니다.”</p>
</blockquote>
<ul>
<li>출처 : <a href="http://channy.creation.net/blog/626#.WS_iOBPyib8" target="_blank" rel="external">http://channy.creation.net/blog/626#.WS_iOBPyib8</a></li>
</ul>
<p>현재 유명한 오픈 소스는 거의 대부분 이 github 안에 서식하고 있다고 보면 될 정도로 압도적인 곳이다. 이 곳에서 우리는 많은 개발자들이 어떤 프로젝트를 좋아하고 팔로우 하는지를 알아 볼 수 있는데 지금은 첫 메뉴에서 링크로 보이지는 않지만 내가 주로 찾는 URL은 아래와 같다.</p>
<ul>
<li>깃헙 트렌드 : <a href="https://github.com/trending" target="_blank" rel="external">https://github.com/trending</a></li>
</ul>
<p>한번에 25개 정도의 결과를 지금 핫한 프로젝트와 개발자를 리스팅해서 보여준다.</p>
<p><img src="/images/github.jpg" alt="깃허브 메인 페이지"></p>
<p>오른쪽 콤보 박스를 이용해서 일간, 주간, 월간 결과를 나누어서 확인할 수 있다.<br>필자는 이런 내용이 너무 좋아서 팀원들과 <a href="https://github.com/TeamSEGO/github-trend-kr" target="_blank" rel="external">https://github.com/TeamSEGO/github-trend-kr</a> 같은 페이지를 운영했던 적이 있다. 그리고 <a href="https://techstory.shma.so/" target="_blank" rel="external">https://techstory.shma.so/</a> 에 한참동안 <strong>매일 깃헙</strong> 이라는 형태의 블로깅을 하곤 했었다. 이런 활동들이 주는 유익한 점은 개인적으로 개발 트렌드를 파악하는 데에 굉장한 도움을 주고 다음에 무엇을 준비할 지 알 수 있는 자양분이 되었다.</p>
<p>굳이 이런 활동을 하지 않아도 이런 내용을 확인할 수 있는 방법들이 있다.  <a href="https://github.com/trending" target="_blank" rel="external">https://github.com/trending</a> 페이지를 직접 방문하거나 아니면 구글 플레이나 앱스토어에 github 이라고 치면 트렌트를 확인할 수 있는 앱들이 굉장히 많다.</p>
<p><img src="/images/mgithub.png" alt="깃헙 관련 앱들"></p>
<p><u>25개나 되는 프로젝트에서 무엇을 보면 좋을까.</u><br>필자의 경험 상으로는 시작할 때는 다음의 원칙을 지키면 유익했던 것 같다. <strong>먼저 daily와 weekly 는 보지 않을 것.</strong> 매일 좋아요(깃허브에서는 스타)를 많이 받는 프로젝트는 굉장히 많이 바뀐다. 하지만 하루 반짝하는 프로젝트는 굉장히 많다. 이런 것들은 과감히 보지 않고 <strong>monthly를 선택하고 리스트를 주욱 훑어 보는 것이 첫번째다.</strong> 두번째는 본인이 아는 회사나 그룹의 프로젝트만 챙겨본다. 예를 들어 google, facebook, spring 같은 애들이 오면 꼼꼼하게 챙겨본다. 마지막으로 본인이 아는 언어를 사용한 프로젝트를 챙겨본다. 모든 언어를 다 섭렵할 수는 없는 노릇이고 내가 익숙한 내용들부터 챙겨봐도 다 보기가 쉽지 않다. 오늘 소개할 prepack이라는 프로젝트는 위의 순으로 내가 선택한 프로젝트다. (차후 설명)</p>
<p>선택하고 나면 (클릭해서 해당 페이지로 이동) 프로젝트 메인 페이지로 들어갈 수 있다. 깃헙 프로젝트 메인페이지는 기본적으로 프로젝트의 파일 리스트와 소개로 크게 나뉘어져 있다. 파일 리스트는 일반적으로 master 브랜치에 담긴 파일들을 보여준다. 소개는 리드미(Readme) 파일로 작성이 되어 있고 깃허브에서 기본적으로 리드미 파일은 마크다운 형식을 따른다.</p>
<p><u>리드미 파일에 대한 소개는 art of readme를 번역해서 소개한 부분을 인용한다.</u></p>
<ul>
<li>이름 — 이름이 무엇보다 중요합니다. react-router라는 이름은 이름만으로 무슨 프로젝트인지 알 수 있으니까요</li>
<li>한줄 요약 — 이름이 중요한 것 처럼 한줄로 이 프로젝트의 정체성을 나타내 주는 것이 좋습니다</li>
<li>사용법 — API 문서로 바로 가는 것보다 사용법을 설명해 주는 것이 좋습니다.</li>
<li>API — 이름, 설명, 사용법이 보여지고 나면 API의 상세함이 프로젝트의 품격을 결정합니다</li>
<li>설치방법 — 자, 이제 전체를 읽어봤으니 어떻게 설치할 지를 알 수 있어야 사용자가 마지막 결정을할 수 있습니다.</li>
<li>라이센스 — 이 프로젝트를 내가 사용할 수 있는지에 대한 중요한 정보를 담고 있죠.  </li>
</ul>
<p>art of readme 링크 : <a href="https://github.com/noffle/art-of-readme" target="_blank" rel="external">https://github.com/noffle/art-of-readme</a><br>소개 링크 : <a href="https://techstory.shma.so/art-of-readme-cd19f86b0456" target="_blank" rel="external">https://techstory.shma.so/art-of-readme-cd19f86b0456</a>  </p>
<p>이렇게 프로젝트들을 매일 매일 정복해 나가다 보면 최신 개발 트렌드를 파악하기에 매우 유용하다. 이 방법은 의외로 시간을 많이 소모하는 방법이기 때문에 시간을 절약하기 위해서 사용하는 다른 몇가지 방법들을 다음번에 이야기 하도록 하고 오늘은 새로운 프로젝트를 하나 소개하려고 한다.</p>
<h2 id="6월의-첫-프로젝트-prepack"><a href="#6월의-첫-프로젝트-prepack" class="headerlink" title="6월의 첫 프로젝트 - prepack"></a>6월의 첫 프로젝트 - prepack</h2><p><img src="/images/prepack01.png" alt="prepack"><br>깃허브 링크 : <a href="https://github.com/facebook/prepack" target="_blank" rel="external">https://github.com/facebook/prepack</a><br>홈페이지 링크 : <a href="https://prepack.io/" target="_blank" rel="external">https://prepack.io/</a>  </p>
<p>facebook에서 최근에 prepack이라는 프로젝트를 공개했다.<br>이 프로젝트는 JavaScript를 작성하고 나면 최적화한 소스 코드로 변경시켜주는 역할을 할 것을 목표로 지금 개발 중에 있으며 이미 어느 정도의 코드는 변경이 가능하고 시연도 가능한 형태로 공개가 되어 있다.</p>
<p>예를 들어 보면 다음 처럼 코드를 작성해 보자<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'hello'</span>; &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">world</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'world'</span>; &#125;</div><div class="line">  global.s = hello() + <span class="string">' '</span> + world();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>hello world를 출력하는 소스지만 조금 비효율 적으로 보인다. prepack이 어떻게 변환하는지를 살펴보자.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  s = <span class="string">"hello world"</span>;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>우리가 원하는 것처럼 간결하게 줄여준다!  </p>
<h4 id="기술적-배경-설명"><a href="#기술적-배경-설명" class="headerlink" title="기술적 배경 설명"></a>기술적 배경 설명</h4><p>최근에 소스코드를 변경해주는 작업들을 하는 오픈 소스들이 많다. 예를 들어 타입스크립트라던지, ES2015를 브라우저에 맞춰 변경해 준다던지 등의 compile 혹은 transpile 로 대변되기도 하지만 꼭 하나의 용어로만은 꼬집어 말할 수 없는 일련의 작업들이 JavaScript에서는 일어나고 있다. 기존 JavaScript가 어려운 것도 하나의 이유지만 개발자들의 소스코드가 일정 품질에 도달하지 못하는 것도 그 원인 중에 하나라고 보여진다.</p>
<p><img src="/images/babel01.png" alt="babel"></p>
<p>가장 주목을 받았던 프로젝트는 Babel 이라는 프로젝트인데 이 프로젝트는 보통 ES2015로 코드를 짜면 기존 ES5의 JavaScript로 변환해 주는 일들에 많이 사용되었다. 이유는 브라우저 호환성 때문인데 구형 브라우저에서 이해하지 못하는 최신 JavaScript 문법에 맞춰서 코드를 구형 브라우저에서 이해하도록 바꿔주는 역할 들을 했다. 이 Babel 에서 사용하는 AST(Abstract Syntax Tree) 기술을 이용해서 자바스크립트를 이해(parsing)하고 소스코드를 만들어 내었다.</p>
<p>아래 코드를 보자.<br>출처 : <a href="http://resources.jointjs.com/demos/javascript-ast" target="_blank" rel="external">http://resources.jointjs.com/demos/javascript-ast</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">5</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addA</span>(<span class="params">d</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> a + d;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = addA(<span class="number">2</span>) + b;</div></pre></td></tr></table></figure>
<p>이렇게 만들어진 코드를 AST 로 변환을 하면 아래 형태 처럼 만들어진다.  </p>
<p><img src="/images/AST01.png" alt="AST"></p>
<p><code>이 visualization 을 위해서는 Esprima 와 JointJS를 사용했다.</code></p>
<h4 id="어떻게-사용할-것인가"><a href="#어떻게-사용할-것인가" class="headerlink" title="어떻게 사용할 것인가"></a>어떻게 사용할 것인가</h4><p>설치는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;npm install -g prepack</div></pre></td></tr></table></figure>
<p>소스 코드를  helloprepack.js 라고 작성했을 경우는 아래와 같이 실행한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;prepack helloprepack.js</div></pre></td></tr></table></figure></p>
<p>다른 코드로 변경하기 위해서는 아래와 같이 사용한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;prepack helloprepack.js --out helloprepack_new.js</div></pre></td></tr></table></figure></p>
<h3 id="어떤-의미가-있을까"><a href="#어떤-의미가-있을까" class="headerlink" title="어떤 의미가 있을까"></a>어떤 의미가 있을까</h3><p>Babel 의 경우는 사용된 분야가 아무래도 JavaScript가 빠르게 스펙이 올라가는 것을 쫓아가기에 주요하게 사용되었다고 하면 JavaScript VM이 이해하기 더 빠른 코드로 변경하는 역할을 장기적으로 목표로 가지고 작업할 수 있을 것 같다.</p>
<blockquote>
<p>이런 비슷한 일을 하고 있는 코드중에 하나가 asm.js 와 WebAssembly 가 있는데 기계어에 가깝게 코드가 짜여질 수록 브라우저에서 더 빠른 성능을 위한 또 하나의 로드맵으로 보여진다.</p>
</blockquote>
<ul>
<li>링크 : <a href="http://devpools.kr/2017/01/21/webassembly-binaryen-emscripten/" target="_blank" rel="external">WebAssembly – hello world 어셈블리를 브라우저에 올려보자</a></li>
</ul>
<p>사이트의 중간 로드맵에서도 같은 이야기를 하고 있다.<br>최종 목표로는 플랫폼처럼 사용하고 싶고 분석과 자동 테스트 코드 작성까지 보고 있다.  </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;이 글은 회사 기술 블로그에 올리고 있는 내용입니다.회사 기술 블로그에는 이슈가 되고 있는 기술 트렌드와 개인적으로 관심있는 기술 이야기의 주제를 번갈아 가며 연재할 예정입니다. ES2015 리팩토링에 관한 이야기가 다음번
    
    </summary>
    
    
      <category term="chatbot, experience" scheme="http://keen.devpools.kr/tags/chatbot-experience/"/>
    
  </entry>
  
  <entry>
    <title>챗봇 프로젝트를 진행하면서 알게 된 사실들</title>
    <link href="http://keen.devpools.kr/2017/05/30/%5B2017-05-30%2023:19:43%5D%E1%84%8E%E1%85%A2%E1%86%BA%E1%84%87%E1%85%A9%E1%86%BA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%92%E1%85%A2%E1%86%BC%E1%84%92%E1%85%A1%E1%84%86%E1%85%A7%E1%86%AB%E1%84%89%E1%85%A5%20%E1%84%8B%E1%85%A1%E1%86%AF%E1%84%80%E1%85%A6%20%E1%84%83%E1%85%AC%E1%86%AB%20%E1%84%89%E1%85%A1%E1%84%89%E1%85%B5%E1%86%AF%E1%84%83%E1%85%B3%E1%86%AF/"/>
    <id>http://keen.devpools.kr/2017/05/30/[2017-05-30 23:19:43]챗봇 프로젝트를 진행하면서 알게 된 사실들/</id>
    <published>2017-05-30T14:19:43.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/0*cUkbr04Um53uekAF.jpg" alt="AI vs Human Brain"></p>
<p>AI vs Human Brain<br>최근 급하게 프로젝트에 두달간 투입이 되면서 블로그 포스팅을 할 여유가 전혀 없었다.<br>좀 반성하는 차에 진행한 프로젝트에서 얻은 인사이트를 공유하고자 한다.</p>
<h4 id="챗봇을-위한-디자인-원칙들이-속속-나오고-있다"><a href="#챗봇을-위한-디자인-원칙들이-속속-나오고-있다" class="headerlink" title="챗봇을 위한 디자인 원칙들이 속속 나오고 있다."></a>챗봇을 위한 디자인 원칙들이 속속 나오고 있다.</h4><p>어떤 절대적인 가이드라인은 사실 없기 때문에 마음대로 만들 수는 있고 마음대로 기획할 수는 있지만 많은 경우에 지금 활용할 수 있는 가이드라인들은 존재한다. 이른바 먼저 가본 사람들이 적어 놓은 가이드 라인들이 있다.</p>
<p>여기 가장 유명한 두개의 가이드라인만 소개를 할까 한다.</p>
<ol>
<li><a href="https://medium.muz.li/the-ultimate-guide-to-chatbots-why-theyre-disrupting-ux-and-best-practices-for-building-345e2150b682" target="_blank" rel="external">궁극가이드 — 9가지 원칙이라고 국내에는 알려져 있는…</a></li>
</ol>
<ul>
<li>사용자에게 거짓말하지 않는다 (봇이라고 알려라!)</li>
<li>대화를 유도하라</li>
<li>사용자의 감성을 고려해 디자인한다</li>
<li>대화에 제한을 두지 않는다(지속적으로 개선하라!)</li>
<li>경계를 만든다 (사람들이 몰입할 수 있는 경계를 쳐 주라)</li>
<li>사람들을 실망시킬 때는 조심하라</li>
<li>모든 인터랙션은 의미가 있다.(사용자가 이탈하는 부분을 정확히 트래킹하라)</li>
<li>사용자를 잘 도와줘야 시스템이 도움을 받는다.</li>
<li>사용자의 감정을 확인하고 감정을 목표점으로 한다.</li>
</ul>
<ol>
<li><a href="http://refreshstudio.tistory.com/entry/%EB%B4%87-%EB%94%94%EC%9E%90%EC%9D%B8bot-design%EC%9D%98-8%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99" target="_blank" rel="external">디자인 8원칙</a></li>
</ol>
<ul>
<li><strong>인간인 척 하지 말기</strong></li>
<li>단순함을 극도로 유지하기</li>
<li>채팅이라는 표현수단 이해하기</li>
<li>최종 사용자에게 맞추기</li>
<li>간단하게 응답하기</li>
<li>봇으로 안될 경우를 대비할 것</li>
<li>가능하면 구조적인 입력을 만들것</li>
<li>모두가 같은 것을 볼 것 (응답이 제각각이지 않을 것)</li>
</ul>
<p>이 중에서 가장 첫번째 원칙인 인간인척 하지 않는 것. 즉 사용자에게 사람인척 하지 않는 것이 중요한데 사람은 챗봇이라고 생각할 때와 사람이라고 생각할 때에 다르게 행동(입력)하고 기대하는 바도 매우 다르기 때문이다. 그래서 사람이 아닌 챗봇이라 버튼을 활용한다던지 다른 인터페이스에 대한 디자인을 하는 것은 무척이나 중요하다.</p>
<h4 id="인공지능에-대한-이해-보다-중요한-게-있다"><a href="#인공지능에-대한-이해-보다-중요한-게-있다" class="headerlink" title="인공지능에 대한 이해 보다 중요한 게 있다."></a>인공지능에 대한 이해 보다 중요한 게 있다.</h4><p><img src="/images/0*rYIrAKa51Aw1PBte.jpg" alt="사람"></p>
<p>사람<br>디자인 원칙에서 보았듯이 가장 중요한 원칙은 사람에 대한 이해다.<br>사용자가 어떻게 챗봇을 활용할 지를 이해하지 못하면 서비스가 제대로 쓸모 없는 서비스를 하게 마련이다. 그런 의미에서 아직은 인공지능과 사람의 인터페이스는 투박하다.<br>사용자가 어떻게 챗봇을 쓸 것인지를 정의하려면 내가 하려는 서비스가 어떤 것인지를 명확하게 정의해야 하고 어떤 기능을 대체를 하려는지를 기획자 혹은 개발자 스스로가 알고 있어야 한다.</p>
<h4 id="챗봇에-대한-기대는-굉장히-천차-만별이다"><a href="#챗봇에-대한-기대는-굉장히-천차-만별이다" class="headerlink" title="챗봇에 대한 기대는 굉장히 천차 만별이다."></a>챗봇에 대한 기대는 굉장히 천차 만별이다.</h4><p>사용자들과 인터뷰를 하다보면 정작 사용할 사용자들은 챗봇에게 큰 기대를 하지 않는다. 마치 우리가 시리와 빅스비에게 심드렁한 것 처럼. 하지만 기획단계에서의 기획자와 발안자들은 굉장히 많은 기대를 가지고 프로젝트에 접근한다.</p>
<p><strong>심지어 챗봇을 위한 디자인 원칙들을 읽어 보지도 않고 말이다.</strong> 챗봇들이 무엇인가 세상을 바꿀 것 처럼 굉장히 멋진 장표들과 아키텍처들을 보고 있지만 정작 이것이 어떤 문제를 해결할 지 알고 있는 사람은 없다.</p>
<p>개발을 진행하면서 이 프로젝트들이 꽤나 많은 분야의 인력에 대한 감축을 전제로 하고 그런 미래가 바로 닥쳐 있다는 사실을 부정할 수는 없지만 굉장한 청사진 또한 동의할 수 없다. 그래서 현실적이지 않은 요구사항들을 사용자 인터뷰와 가이드라인을 기준으로 다 잘라내고 있지만 의사 결정자들 마저도 굉장한 기대감을 가지고 있다는 사실은 어떻게 보면 슬픈 일이다.</p>
<p>하지만 심지어 페이스북과 같이 작업을 했던 항공 티케팅 분야의 챗봇 담당자는 이렇게 이야기 한다<br>“아무도 챗봇으로 티켓을 사려고 하지는 않아요.”</p>
<h4 id="개발의-대부분은-인공지능과-관련이-없다"><a href="#개발의-대부분은-인공지능과-관련이-없다" class="headerlink" title="개발의 대부분은 인공지능과 관련이 없다."></a>개발의 대부분은 인공지능과 관련이 없다.</h4><p>우리는 구글이 아니다. 이걸 인정하면 마음은 굉장히 편해지지만 대부분의 어른들(?)은 그걸 인정하기가 아들 딸 성적표보다 어려운 모양이다. 하지만 우리에게도 희망은 있다. 챗봇의 아키텍처에서 인공지능이 차지하는 부분은 우리가 기대하는 부분보다 굉장히 작다. 오히려 룰을 어떻게 만들고 어떻게 처리할 것인가 하는 부분이 훨씬 중요한 문제로 다가오게 된다.</p>
<h4 id="개발자는-그래서-또-너무나-중요하다"><a href="#개발자는-그래서-또-너무나-중요하다" class="headerlink" title="개발자는 그래서 또 너무나 중요하다."></a>개발자는 그래서 또 너무나 중요하다.</h4><p>위의 주제의 연속이다. 챗봇의 대부분은 소프트웨어 엔지니어의 영역이다. 그래서 챗봇 엔진을 잘 만들기 위해서는 좋은 엔지니어와 좋은 아키텍트가 당연히 필요하다. 물론 NLU라던지 딥러닝을 잘 하면 할 수록 더욱 좋다. 하지만 좋은 개발만큼 중요한 부분은 없다.</p>
<p>좋은 개발자는 여러가지 복잡하게 얽혀있는 챗봇의 어려움들을 풀어줄 시작과 마지막이다. 점점 인공지능의 세상이 오면 올 수록 사용자의 입장에서 이해하는 개발자가 더 중요해 질 것이다.</p>
<h4 id="우리는-기존의-레거시를-대체해야-한다"><a href="#우리는-기존의-레거시를-대체해야-한다" class="headerlink" title="우리는 기존의 레거시를 대체해야 한다."></a>우리는 기존의 레거시를 대체해야 한다.</h4><p><img src="/images/0*5vgnyq-ln8SBEbYO.jpg" alt="이렇게 죽어있는 레거시는 곤란하다"></p>
<p>이렇게 죽어있는 레거시는 곤란하다</p>
<p>상담이라던지, 견적이라던지 모든 챗봇이 풀고자 하는 문제들은 기존의 시스템이 자리잡고 있다. 그럼 이 레거시들을 어떻게 유기적으로 풀고 어떻게 서비스를 대체할 수 있을까? 마이크로 서비스 아키텍처는 그 중의 좋은 대답이 될 수 있다. 하지만 이것은 만병통치약은 아니다. 가장 중요한 것은 기존 레거시 함수를 묶어주는 표준을 만들어 주는 것이고 그 레거시를 어떻게 접근할지에 대한 해답은 챗봇이 가지고 있어야 한다.</p>
<p>그렇다면 사용자의 자연어와 레거시간의 연계는 어떻게 이루어 질 것인가. 여기에는 기존에 없던 인공지능 분야의 기술이 필요하다.</p>
<h4 id="과소-평가해서도-곤란하다"><a href="#과소-평가해서도-곤란하다" class="headerlink" title="과소 평가해서도 곤란하다."></a>과소 평가해서도 곤란하다.</h4><p><img src="/images/0*EHAkE0QhpD2tOPTZ.jp" alt="stay tuned"></p>
<p>stay tuned<br>이 쪽은 지속적으로 계속 발전할 것이다. 그렇다는 것은 지금 발을 들이기에 무척이나 좋은 시기라는 것이다.<br>아무래도 발전에 대한 틀은 대부분이 갖춰지는 것 같다.<br>누군가가 기가막힌 사용자 인터페이스를 제시할 것이고 그 때 쯤이면 아직까지는 기대할 것 없는 챗봇 분야의 인공지능도 수준이 많이 올라갈 것이다.<br>언제나 관심을 기울이고 있어야 한다는 이야기다.</p>
<hr>
<p><em>Originally published at </em><a href="http://devpools.kr/2017/05/30/%ec%b1%97%eb%b4%87-%ed%94%84%eb%a1%9c%ec%a0%9d%ed%8a%b8%eb%a5%bc-%ec%a7%84%ed%96%89%ed%95%98%eb%a9%b4%ec%84%9c-%ec%95%8c%ea%b2%8c-%eb%90%9c-%ec%82%ac%ec%8b%a4%eb%93%a4/" target="_blank" rel="external"><em>개발바보들</em></a><em>.</em></p>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/179d67a9e2af" target="_blank" rel="external">May 30, 2017</a>.</p>
<p>Exported from <a href="https://medium.com" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/0*cUkbr04Um53uekAF.jpg&quot; alt=&quot;AI vs Human Brain&quot;&gt;&lt;/p&gt;
&lt;p&gt;AI vs Human Brain&lt;br&gt;최근 급하게 프로젝트에 두달간 투입이 되면서 블로그 포스팅을 할 여유가 전혀
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>챗봇 프로젝트를 진행하면서 알게 된 사실들</title>
    <link href="http://keen.devpools.kr/2017/05/30/20170530/"/>
    <id>http://keen.devpools.kr/2017/05/30/20170530/</id>
    <published>2017-05-30T07:04:04.000Z</published>
    <updated>2017-06-01T01:43:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/ai001.jpg" alt="AI vs Human Brain"><br>최근 급하게 프로젝트에 두달간 투입이 되면서 블로그 포스팅을 할 여유가 전혀 없었다.<br>좀 반성하는 차에 진행한 프로젝트에서 얻은 인사이트를 공유하고자 한다.</p>
<h3 id="챗봇을-위한-디자인-원칙들이-속속-나오고-있다"><a href="#챗봇을-위한-디자인-원칙들이-속속-나오고-있다" class="headerlink" title="챗봇을 위한 디자인 원칙들이 속속 나오고 있다."></a>챗봇을 위한 디자인 원칙들이 속속 나오고 있다.</h3><p>어떤 절대적인 가이드라인은 사실 없기 때문에 누구나 마음대로 만들 수 있고 누구나 마음대로 기획할 수 있다.<br>하지만 지금 유용하게 활용할 수 있는 가이드라인들은 이미 존재한다. 먼저 진행해 본 사람들이 적어놓은 가이드 라인들이 있다.</p>
<p>여기 가장 유명한 두개의 가이드라인만 소개를 할까 한다.</p>
<ol>
<li><a href="https://medium.muz.li/the-ultimate-guide-to-chatbots-why-theyre-disrupting-ux-and-best-practices-for-building-345e2150b682" target="_blank" rel="external">궁극가이드 - 9가지 원칙이라고 국내에는 알려져 있는…</a><ul>
<li>사용자에게 거짓말하지 않는다 (<strong>봇이라고 알려라!</strong>)</li>
<li>대화를 유도하라</li>
<li>사용자의 감성을 고려해 디자인한다</li>
<li>대화에 제한을 두지 않는다(지속적으로 개선하라!)</li>
<li>경계를 만든다 (사람들이 몰입할 수 있는 경계를 쳐 주라)</li>
<li>사람들을 실망시킬 때는 조심하라</li>
<li>모든 인터랙션은 의미가 있다.(사용자가 이탈하는 부분을 정확히 트래킹하라)</li>
<li>사용자를 잘 도와줘야 시스템이 도움을 받는다.</li>
<li>사용자의 감정을 확인하고 감정을 목표점으로 한다.</li>
</ul>
</li>
<li><a href="http://refreshstudio.tistory.com/entry/%EB%B4%87-%EB%94%94%EC%9E%90%EC%9D%B8bot-design%EC%9D%98-8%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99" target="_blank" rel="external">디자인 8원칙</a><ul>
<li><strong>인간인 척 하지 말기</strong></li>
<li>단순함을 극도로 유지하기</li>
<li>채팅이라는 표현수단 이해하기</li>
<li>최종 사용자에게 맞추기</li>
<li>간단하게 응답하기</li>
<li>봇으로 안될 경우를 대비할 것</li>
<li>가능하면 구조적인 입력을 만들것</li>
<li>모두가 같은 것을 볼 것 (응답이 제각각이지 않을 것)</li>
</ul>
</li>
</ol>
<p>이 중에서 가장 첫번째 원칙인 인간인척 하지 않는 것(봇이라고 알려라). -사용자에게 사람인척 하지 않는 것- 이 다른 무엇보다 중요하다.<br>사용자는 챗봇이라고 생각할 때와 사람이라고 생각할 때에 다르게 행동(입력)하고 기대하는 바도 매우 다르기 때문이다.<br>그래서 사람이 아닌 챗봇이라고 생각하는 사용자를 위해서 버튼을 입력 도구로 활용한다 거나 또 다른 유용한 인터페이스를 활용한 소프트웨어 디자인을 하는 것은 무척이나 중요하다.</p>
<h3 id="인공지능에-대한-이해-보다-중요한-게-있다"><a href="#인공지능에-대한-이해-보다-중요한-게-있다" class="headerlink" title="인공지능에 대한 이해 보다 중요한 게 있다."></a>인공지능에 대한 이해 보다 중요한 게 있다.</h3><p><img src="/images/ai002.jpg" alt="사람"></p>
<p>앞서 기술한 디자인 원칙에서 보았듯이 가장 중요한 원칙은 사람에 대한 이해다.<br>사용자가 어떻게 챗봇을 이해하는 지와 사용할 지를 이해하지 못하면 서비스의 방향을 못찾고 방황하기 마련이다. 그런 의미에서 아직까지 나온 챗봇 서비스들의 인공지능과 사람간의 인터페이스는 투박하게만 보인다.<br><strong>사용자가 어떻게 챗봇을 쓸 것인지를 정의하려면</strong> 내가 만들고 있는 제품이 어떤 것인지를 명확하게 정의해야 하는 것이 첫번째고 어떤 pain point가 있어서 구체적으로 어떤 기능을 챗봇으로 대체 하려는 지를 기획자 혹은 개발자 스스로가 알고 있어야 한다.</p>
<p><strong>기존의 어떤 무언가를 대체하지 않고 새로운 시장을 창조하려는 경우도</strong> 그게 왜 필요하고 사용자에게 어떻게 전달되어 질 지를 모르면 제대로 된 제품을 만들 수는 없을 것은 자명한 일이다.</p>
<h3 id="챗봇에-대한-기대는-굉장히-천차-만별이다"><a href="#챗봇에-대한-기대는-굉장히-천차-만별이다" class="headerlink" title="챗봇에 대한 기대는 굉장히 천차 만별이다."></a>챗봇에 대한 기대는 굉장히 천차 만별이다.</h3><p><img src="/images/ai004.jpg" alt="정말 다른 기대"></p>
<p>사용자들과 인터뷰를 진행 하다보면 정작 사용자들은 챗봇에게 큰 기대를 하지 않는다. 마치 우리가 시리와 빅스비에게 심드렁한 것 처럼. 하지만 기획단계에서의 기획자와 발안자들은 굉장히 많은 기대를 가지고 프로젝트에 접근한다.( 이런 간극은 어떻게 존재하는 걸까. )</p>
<p><strong>심지어 챗봇을 위한 디자인 원칙들을 읽어 보지도 않고 말이다.</strong> 챗봇들이 무엇인가 세상을 바꿀 것 처럼 굉장히 멋진 장표들과 아키텍처들을 보고 있지만 정작 이것이 어떤 문제를 해결할 지 알고 있는 사람은 없다.</p>
<p>개발을 진행하면서 챗봇 프로젝트들을 바라보든 사람들의 시각과 시장의 수요는 굉장히 많은 분야의 광범위한 인력 감축을 전제로 하기도 하고 챗봇이 모든 것을 해결해 줄 것 같은 분위기와 어쩌면 그런 미래가 바로 우리 앞에 닥쳐 있다는 사실을 부정할 수는 없다. 하지만 장표에 그려진 무지개 빛 청사진 또한 기술적으로 동의할 수는 없어 보인다. 그래서 항당 무게한 요구사항들을 사용자 인터뷰와 가이드라인을 기준으로 다 잘라내고 있는 것이 현실이다. 하지만 잘라도 잘라도 프로젝트는 가벼워지지 않고 프로젝트의 미래를 좌우하는 의사 결정자들 마저도 이상한 기대감을 가지고 있다는 사실은 어떻게 보면 슬픈 일이다.</p>
<p>페이스북과 같이 작업을 했던 스카이 스캐너 분야의 챗봇 담당자는 이렇게 이야기 한다<br>“아무도 챗봇으로 티켓을 사려고 하지는 않아요.”</p>
<h3 id="개발의-대부분은-인공지능과-관련이-없다"><a href="#개발의-대부분은-인공지능과-관련이-없다" class="headerlink" title="개발의 대부분은 인공지능과 관련이 없다."></a>개발의 대부분은 인공지능과 관련이 없다.</h3><p>우리는 구글이 아니다. 이걸 인정하면 몸도 마음도 굉장히 편해지지만 대부분의 어른들(?)은 그걸 인정하기가 아들 딸 성적표를 받아들이기 보다 어려운 모양이다. 하지만 어쩌면 우리에게도 희망은 있다. 챗봇의 아키텍처에서 인공지능이 차지하는 부분은 우리가 기대하는 부분보다 굉장히 작다. 오히려 <strong>룰을 어떻게 만들고 어떻게 처리할 것인가</strong> 하는 부분이 훨씬 실제적이면서도 중요한 문제로 다가오곤 한다.</p>
<h3 id="개발자는-그래서-또-너무나-중요하다"><a href="#개발자는-그래서-또-너무나-중요하다" class="headerlink" title="개발자는 그래서 또 너무나 중요하다."></a>개발자는 그래서 또 너무나 중요하다.</h3><p>위의 주제의 연속이다. 챗봇의 대부분은 소프트웨어 엔지니어의 영역이다. 그래서 챗봇 엔진을 잘 만들기 위해서는 좋은 엔지니어와 좋은 아키텍트가 당연히 필요하다. 물론 NLU라던지 딥러닝을 잘 하면 할 수록 더욱 좋다. 하지만 좋은 개발만큼 중요한 부분은 없다.</p>
<p>좋은 개발자는 여러가지 복잡하게 얽혀있는 챗봇의 어려움들을 풀어줄 시작과 마지막이다. 점점 인공지능의 세상이 오면 올 수록 사용자의 입장에서 이해하는 개발자가 더 중요해 질 것이다. 능숙하고 영민한 개발자를 잘 찾아서 서비스의 전방에 배치하는 것이 인공지능 전문가를 구하는 것보다 ROI가 훨씬 높다.</p>
<h3 id="우리는-기존의-레거시를-대체해야-한다"><a href="#우리는-기존의-레거시를-대체해야-한다" class="headerlink" title="우리는 기존의 레거시를 대체해야 한다."></a>우리는 기존의 레거시를 대체해야 한다.</h3><p><img src="/images/ai-legacy.jpg" alt="이렇게 죽어있는 레거시는 곤란하다"></p>
<p>언제나 챗봇이 있는 곳에는 상담이라던지, 견적같은 - 모든 챗봇이 풀고자 하는 문제들- 에는 기존의 시스템이 유령처럼 자리잡고 있다. 그럼 이 레거시들을 어떻게 유기적으로 풀고 어떻게 서비스를 대체할 수 있을까? 마이크로 서비스 아키텍처는 그 중의 좋은 대답이 될 수 있다. 하지만 이것이 만병통치약은 아니다. 가장 중요한 것은 기존 레거시 함수를 묶어주는 표준을 만들어 주는 것이고 그 레거시를 어떻게 접근할지에 대한 해답은 챗봇이 가지고 있어야 한다. 이런 부분에서는 기존 레거시를 잘 알고 있는 개발자는 도움이 된다.</p>
<p>그렇다면 사용자의 자연어와 레거시간의 연계는 어떻게 이루어 질 것인가. <strong>여기에 기존에 없던 인공지능 분야의 기술이 필요하다.</strong></p>
<h3 id="과소-평가해서도-곤란하다"><a href="#과소-평가해서도-곤란하다" class="headerlink" title="과소 평가해서도 곤란하다."></a>과소 평가해서도 곤란하다.</h3><p><img src="/images/ai003.jpg" alt="stay tuned"></p>
<p>이 쪽은 지속적으로 계속 발전할 것이다. 그렇다는 것은 지금 발을 들이기에 무척이나 좋은 시기라는 것이다.<br>아무래도 발전에 대한 틀은 대부분이 갖춰지는 것 같다.<br>누군가가 기가막힌 사용자 인터페이스를 제시할 것이고 그 때 쯤이면 아직까지는 기대할 것 없는 챗봇 분야의 인공지능도 수준이 많이 올라갈 것이다.<br>언제나 관심을 기울이고 있어야 한다는 이야기다.</p>
<h3 id="어떻게-준비할-것인가"><a href="#어떻게-준비할-것인가" class="headerlink" title="어떻게 준비할 것인가"></a>어떻게 준비할 것인가</h3><p>일단 개발자들은 하던 일들을 열심히 하면서 인공지능에 대한 트렌드는 지속적으로 팔로우업 해야한다.<br>어렵지만 생존을 위한 일이라면 해볼 만한 일이다. 그리고 생각보다 재미 있는 분야다.<br>구글이 모바일 퍼스트에서 드디어 AI퍼스트를 선언한 지금 우리가 맞이할 미래는 모바일이 인터페이스였던 시대를 인공지능이 대체할 것이고 이 인터페이스는 IoT와 맞물려 우리 주위 어디에서든지 우리에게 시도 때도 없이 간섭을 시작할 것이다.<br>가장 처음 이야기 했던 <strong>사람의 이해</strong> - 사람을 이해하는 것은 다시 한번 개발자들에게는 중요한 화두로 던져질 것이라는 데 나의 행보를 던져본다.<br>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/ai001.jpg&quot; alt=&quot;AI vs Human Brain&quot;&gt;&lt;br&gt;최근 급하게 프로젝트에 두달간 투입이 되면서 블로그 포스팅을 할 여유가 전혀 없었다.&lt;br&gt;좀 반성하는 차에 진행한 프로젝트에서 얻은 인사이트를
    
    </summary>
    
    
      <category term="chatbot, experience" scheme="http://keen.devpools.kr/tags/chatbot-experience/"/>
    
  </entry>
  
  <entry>
    <title>first-post</title>
    <link href="http://keen.devpools.kr/2017/05/15/first-post/"/>
    <id>http://keen.devpools.kr/2017/05/15/first-post/</id>
    <published>2017-05-15T07:04:04.000Z</published>
    <updated>2017-05-30T13:37:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo-를-이용한-github-page-블로그-서비스"><a href="#hexo-를-이용한-github-page-블로그-서비스" class="headerlink" title="hexo 를 이용한 github page 블로그 서비스"></a>hexo 를 이용한 github page 블로그 서비스</h1><p>개인 블로그 URL을 운영하다가 도메인이 너무 비싸져서 깃헙 기반으로 옮겨 탔습니다. hexo 는 아직 손에 익숙하지는 않지만 어느순간 손에 익었다 싶으면 다 이쪽으로 가지고 와서 작성을 할까 싶습니다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;hexo-를-이용한-github-page-블로그-서비스&quot;&gt;&lt;a href=&quot;#hexo-를-이용한-github-page-블로그-서비스&quot; class=&quot;headerlink&quot; title=&quot;hexo 를 이용한 github page 블로그 서비스&quot;&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>패턴인식 개요</title>
    <link href="http://keen.devpools.kr/2017/03/18/%5B2017-03-18%2014:56:34%5D%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%89%E1%85%B5%E1%86%A8%20%E1%84%80%E1%85%A2%E1%84%8B%E1%85%AD/"/>
    <id>http://keen.devpools.kr/2017/03/18/[2017-03-18 14:56:34]패턴인식 개요/</id>
    <published>2017-03-18T05:56:34.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="패턴-인식"><a href="#패턴-인식" class="headerlink" title="패턴 인식"></a>패턴 인식</h3><p>주어진 데이터의 집합에 대해 입력값을 바탕으로 하는 Classification. MNIST 처럼 이미지에서 숫자를 도출하는 것도 좋은 예</p>
<ul>
<li>구조적 방법 : 1은 하나의 직선에 가깝고 8은 원 두개.</li>
<li>템플릿 매칭 : 패턴의 원형을 저장해 두고 데이타간의 거리를 계산</li>
<li>기계학습</li>
</ul>
<h4 id="패턴-인식과-관련된-개념"><a href="#패턴-인식과-관련된-개념" class="headerlink" title="패턴 인식과 관련된 개념"></a>패턴 인식과 관련된 개념</h4><h4 id="1-분류와-군집화"><a href="#1-분류와-군집화" class="headerlink" title="1. 분류와 군집화"></a>1. 분류와 군집화</h4><p><strong>분류( Classification ) : MNIST로 숫자를 맞추는 형태</strong></p>
<ul>
<li>베이지안 분류기, K 근접 이웃, 다층 퍼셉트(MLP), 서포트 벡터 머신</li>
<li>지도학습</li>
</ul>
<p><strong>군집화( Clustering ) : 특성 고객층을 하나의 기준으로 분류하기 보다는 여러가지 기준이지만 뭉뚱그리는 것</strong></p>
<ul>
<li>K 편균 클러스터링, 계층적 군집화, 자기조직화 특징맵(SOM)</li>
<li>비지도 학습</li>
</ul>
<h4 id="2-데이터와-데이터-분포"><a href="#2-데이터와-데이터-분포" class="headerlink" title="2. 데이터와 데이터 분포"></a>2. 데이터와 데이터 분포</h4><blockquote>
<p>여러가지 데이터들은 결국 컴퓨터에서 다루어질 수 있게 수치로 표현 되어야 한다. 이 숫자들을 1차원으로 나열하면 벡터, 차원이 높아지면 행렬이 되는데 이런 모임을 Tensorflow에서는 tensor 라고 지칭하고 딥러닝의 과정이 이 tensor가 움직이면서 나타나서 Tensorflow 를 이루게 된다.</p>
</blockquote>
<ul>
<li>표본집합 추출</li>
<li>특징추출</li>
<li>분류와 결정경계</li>
</ul>
<h4 id="분류율과-오차"><a href="#분류율과-오차" class="headerlink" title="분류율과 오차"></a>분류율과 오차</h4><p>학습 오차 : 학습데이타에 대하여 분류 오차를 계산한 것</p>
<p>테스트 오차 : 실제 데이타의 오차</p>
<p>일반화 오차 : 확률분포함수를 이용한 분포에 따른 평균 오차값. 테스트 오차가 절대값 수치 미적용에 따른 왜곡을 가질 수 있으므로 사용한다</p>
<p>교차검증법을 통해 오차값을 얻어내기도 한다</p>
<h4 id="3-과다-적합-overfitting"><a href="#3-과다-적합-overfitting" class="headerlink" title="3. 과다 적합(overfitting)"></a>3. 과다 적합(overfitting)</h4><ul>
<li>Classifier가 학습데이타에 대해서만 지나치게 적합한 형태로 결정경계를 형성하는 경우. train데이타의 범주를 벗어나는 경우는 제대로 분류하지 못하는 경우.</li>
<li><a href="http://sanghyukchun.github.io/59/" target="_blank" rel="external">Machine Learning 스터디 (3) Overfitting</a></li>
</ul>
<p><img src="/images/0*G9gNynok0IWGFWsX" alt=""></p>
<h4 id="4-활용분야"><a href="#4-활용분야" class="headerlink" title="4. 활용분야"></a>4. 활용분야</h4><ul>
<li>문자 인식</li>
<li>생체인식</li>
<li>금융데이터</li>
<li>생물정보</li>
<li>뇌 신호 처리</li>
<li>영상처리</li>
<li>뇌 신호 처리</li>
</ul>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/81a1fd6ca86a" target="_blank" rel="external">March 18, 2017</a>.</p>
<p>Exported from <a href="https://medium.com" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;패턴-인식&quot;&gt;&lt;a href=&quot;#패턴-인식&quot; class=&quot;headerlink&quot; title=&quot;패턴 인식&quot;&gt;&lt;/a&gt;패턴 인식&lt;/h3&gt;&lt;p&gt;주어진 데이터의 집합에 대해 입력값을 바탕으로 하는 Classification. MNIST 처럼 이미지에
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>딥러닝을 위한 수학 1</title>
    <link href="http://keen.devpools.kr/2017/03/13/%5B2017-03-13%2018:26:57%5D%E1%84%83%E1%85%B5%E1%86%B8%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%201/"/>
    <id>http://keen.devpools.kr/2017/03/13/[2017-03-13 18:26:57]딥러닝을 위한 수학 1/</id>
    <published>2017-03-13T09:26:57.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>원문은 아래에 지속적으로 업데이트</p>
<p><a href="https://github.com/ehrudxo/til" title="https://github.com/ehrudxo/til" target="_blank" rel="external"><strong>ehrudxo/til</strong><br>_til - today I learned. 오늘 공부한것을 위키 형식으로 적기시작 해봄._github.com</a><a href="https://github.com/ehrudxo/til" target="_blank" rel="external"></a></p>
<p>수학은 워낙 넓으니까 선형대수를 다 다시 공부할 수도 없고… 주로 나오는 것만 위주로 나열하기로 함.</p>
<p>딥러닝에 왜 이런 여러가지가 나오는지를 먼저 이해하는 것이 중요함. 다른 대부분의 강의나 튜토리얼은 그런 설명없이 바로 수식을 전개함. 너무 간단해서 언급을 안하는 거 같은데, 나 같은 더미를 위해서 이야기 하면 딥러닝을 통해 머신이 내리는 결정은 대부분이 통계와 수학식을 통해 전개됨.</p>
<p>통계를 위해서는 확률을 알아야 하고 이 결정을 위한 확률의 기본이 베이즈 이론이라고 보면 됨. 이후 여러가지 알고리즘과 방법들이 나오는 것도 결국 이 확률이론이 토대가 된다.</p>
<p>뉴럴 네트워크가 들어가는 경우는 부분에 쓰이는 수학은 변수와 모델의 통제라는 측면에서 미분 그 중에서도 편미분이 중요하고 레이어의 계산이 한꺼번에 이루어지는 관점에서는 행렬식이 너무나 중요하다. 정도로만 개념을 잡고 (일단은) 넘어가면 된다.</p>
<p>결국은 문제를 어떻게 정의하는가가 핵심이고 그 문제를 푸는 방법으로써의 딥러닝이 각광을 받고 있다고 보면 내가 가지고 있는 해결해야 하는 문제들을 수학적으로 어떻게 정의하는지를 알아야 하는 것이 첫번째, 그리고 그것을 해결하는 다양한 방법들을 배우는 것을 두번째라고 생각하면 된다.</p>
<p>일단 확률에 대해서 알아보자.</p>
<h3 id="조건부-확률"><a href="#조건부-확률" class="headerlink" title="조건부 확률"></a>조건부 확률</h3><ul>
<li>P(Y=y|X=x) : 구름(X)이 꼈을때(true) 비(Y)가 올 확률을 의미함. — 출처 <a href="https://ko.wikipedia.org/wiki/%EC%A1%B0%EA%B1%B4%EB%B6%80_%ED%99%95%EB%A5%A0" target="_blank" rel="external">위키피디아 : 조건부 확률</a></li>
<li>P(E|F) = P(E and F)/P(F)</li>
<li>곱셈 정리 : P(E and F) = P(E|F) * P(F)</li>
<li>치환 정리 : P(E|F) * P(F) = P(F|E) * P(E)</li>
</ul>
<h4 id="한-개의-주사위를-두-번-던질-때-합이-3이-나올-확률-vs-두-개의-주사위를-던져서-합이-3이-나올-확률"><a href="#한-개의-주사위를-두-번-던질-때-합이-3이-나올-확률-vs-두-개의-주사위를-던져서-합이-3이-나올-확률" class="headerlink" title="한 개의 주사위를 두 번 던질 때 합이 3이 나올 확률 vs 두 개의 주사위를 던져서 합이 3이 나올 확률 :"></a>한 개의 주사위를 두 번 던질 때 합이 3이 나올 확률 vs 두 개의 주사위를 던져서 합이 3이 나올 확률 :</h4><ul>
<li>(1/6*1/6)/1/6 = 1/6 vs 2/36 = 1/18</li>
<li>표본 공간이 바뀌었다(축소 표본 공간)</li>
</ul>
<h4 id="1개의-주사위를-네번-굴려서-6이-한번-나오는-경우-vs-2개의-주사위를-24번-굴려서-동시에-6이-한번-나오는-경우-드-메레-문제"><a href="#1개의-주사위를-네번-굴려서-6이-한번-나오는-경우-vs-2개의-주사위를-24번-굴려서-동시에-6이-한번-나오는-경우-드-메레-문제" class="headerlink" title="1개의 주사위를 네번 굴려서 6이 한번 나오는 경우 vs 2개의 주사위를 24번 굴려서 동시에 6이 한번 나오는 경우 ( 드 메레 문제 )"></a>1개의 주사위를 네번 굴려서 6이 한번 나오는 경우 vs 2개의 주사위를 24번 굴려서 동시에 6이 한번 나오는 경우 ( 드 메레 문제 )</h4><ul>
<li>여사건 정의(1-P(E))를 통해서 풀어야 하는데 그 이유는 처음에 6이 나오면 표본공간 자체가 필요없어지기 때문에 절대 안나오는 확률을 기준으로 계산을 한 다음에 여사건 정의로 푼다 1-(5/6)⁴ = 0.518 : 같은 방법.</li>
<li>표본공간을 확보하는 것이 관건</li>
<li>2개의 주사위를 굴려서 동시에 안 나오는 경우는 1 -(35/36)²⁴ = 0.491 — “세상에서 가장 재미있는 통계학”</li>
</ul>
<h3 id="베이즈-정리"><a href="#베이즈-정리" class="headerlink" title="베이즈 정리"></a>베이즈 정리</h3><ul>
<li>개요 : 베이즈 정리는 1740년대의 영국의 목사인 토머스 베이즈(Thomas Bayes)가 정립한, 조건부 확률에 대한 수학적 정리이다. 사건 A가 있고 사건 B가 있을 때 사건 B가 일어난 것을 전제로 한 사건 A의 조건부 확률을 구하고 싶다. 그런데 지금 알고 있는 것은 사건 A가 일어난 것을 전제로 한 사건 B의 조건부 확률, A의 확률, B의 확률뿐이다. 그럴 때 다음과 같이 구할 수가 있다. 출처 : <a href="https://namu.wiki/w/%EB%B2%A0%EC%9D%B4%EC%A6%88%20%EC%A0%95%EB%A6%AC" target="_blank" rel="external">나무위키</a> .</li>
<li>조금 더 수식으로 풀어 쓰면</li>
</ul>
<p><img src="/images/0*s9FyujgqEUU8HAKf.jp" alt="">출처 <a href="https://namu.wiki/w/%EB%B2%A0%EC%9D%B4%EC%A6%88%20%EC%A0%95%EB%A6%AC" target="_blank" rel="external">나무 위키 베이즈 정리</a></p>
<ul>
<li>인구 1000명당 한 명꼴로 걸리는 희귀병. 병에 걸린 사람의 경우는 90% 양성, 건강한 사람의 2% 가 양성 -> 양성반응을 보인 사람의 병에 걸릴 확률은?</li>
<li>즉, 인간의 사고는 처음에는 아무 정보가 없던 상태에서 <strong>새로운 정보를 받아들이고, 이를 통해 자신이 가지고 있던 일종의 사전 확률 체계를 업데이트시켜 세상을 해석하거나 판단을 내리고 의사결정을 하는 방향으로 발전되어 왔다는 것이다</strong>. 그리고 이렇게 발전된 사후 확률 체계는 새로운 사전 확률이 되어, 새로운 정보가 유입될 때마다 업데이트를 반복해간다. — 나무위키 인지과학 및 인공지능에서의 베이즈 정리</li>
</ul>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/c5e1cb31a7ca" target="_blank" rel="external">March 13, 2017</a>.</p>
<p>Exported from <a href="https://medium.com" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;원문은 아래에 지속적으로 업데이트&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ehrudxo/til&quot; title=&quot;https://github.com/ehrudxo/til&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>딥러닝 생초짜를 위한 로드맵을 짜주마</title>
    <link href="http://keen.devpools.kr/2017/03/11/%5B2017-03-11%2018:22:15%5D%E1%84%83%E1%85%B5%E1%86%B8%E1%84%85%E1%85%A5%E1%84%82%E1%85%B5%E1%86%BC%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%8E%E1%85%A9%E1%84%8D%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%85%E1%85%A9%E1%84%83%E1%85%B3%E1%84%86%E1%85%A2%E1%86%B8%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%8D%E1%85%A1%E1%84%8C%E1%85%AE%E1%84%86%E1%85%A1/"/>
    <id>http://keen.devpools.kr/2017/03/11/[2017-03-11 18:22:15]딥러닝 생초짜를 위한 로드맵을 짜주마/</id>
    <published>2017-03-11T09:22:15.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Today I Summarized라는 프로젝트를 깃헙에 만들었다.</p>
<p><a href="https://github.com/ehrudxo/tis" title="https://github.com/ehrudxo/tis" target="_blank" rel="external"><strong>ehrudxo/tis</strong><br>_tis - Today I Summarized. 오늘 요약한 것을 위키 형식으로 적기. 시작 해봄._github.com</a><a href="https://github.com/ehrudxo/tis" target="_blank" rel="external"></a></p>
<p>매일 발표나 스터디 요약을 위해 정리하는 자리인데 아무래도 나야말로 딥러닝 생초짜이기 때문에 꼭 정확한 방법이라고 할 수는 없지만 이 프로젝트에는 지속적으로 전체 큰그림을 구조화 하고 상세화 해서 누구나 읽을 수 있도록 업로드 하도록 하겠다. 그러면서 매일 매일의 내용은 같이 스터디 하는 팀에 공유 하도록 하겠다.</p>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/c295bf9e565c" target="_blank" rel="external">March 11, 2017</a>.</p>
<p>Exported from <a href="https://medium.co" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Today I Summarized라는 프로젝트를 깃헙에 만들었다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ehrudxo/tis&quot; title=&quot;https://github.com/ehrudxo/tis&quot; target=&quot;_blan
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>안옥윤에게서 오이디푸스를 찾다</title>
    <link href="http://keen.devpools.kr/2017/03/07/%5B2017-03-07%2009:57:53%5D%E1%84%8B%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%A9%E1%86%A8%E1%84%8B%E1%85%B2%E1%86%AB%E1%84%8B%E1%85%A6%E1%84%80%E1%85%A6%E1%84%89%E1%85%A5%20%E1%84%8B%E1%85%A9%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B5%E1%84%91%E1%85%AE%E1%84%89%E1%85%B3%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8E%E1%85%A1%E1%86%BD%E1%84%83%E1%85%A1/"/>
    <id>http://keen.devpools.kr/2017/03/07/[2017-03-07 09:57:53]안옥윤에게서 오이디푸스를 찾다/</id>
    <published>2017-03-07T00:57:53.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://namu.wiki/w/%EC%95%94%EC%82%B4%282015%29" title="https://namu.wiki/w/%EC%95%94%EC%82%B4(2015)" target="_blank" rel="external"><strong>암살(2015) - 나무위키</strong><br>_안옥윤, 속사포, 그리고 황덕삼은 상하이 임시정부 사무실에서 김원봉이 제안하고 상하이 대한민국 임시정부 경무국 대장인 염석진의 주도로 나라를 팔아먹은 매국노 강인국과 조선 주둔군 사령관인 일본 육군소장 카와구치 …_namu.wiki</a><a href="https://namu.wiki/w/%EC%95%94%EC%82%B4%282015%29" target="_blank" rel="external"></a></p>
<h4 id="이것은-지나친-망상일까"><a href="#이것은-지나친-망상일까" class="headerlink" title="이것은 지나친 망상일까."></a>이것은 지나친 망상일까.</h4><p>미치코와 안옥윤이 마주치는 순간 오이디푸스 컴플렉스의 변주를 생각한 것은. 그래 인정하자. 너무 나갔다. 아버지를 죽이는 동기도 그렇고 오이디푸스는 예언을 이루게 하지 않기 위하여 돌아 돌았지만 예언에 따라 움직인 것이라고 생각을 하면 이것은 너무나도 의지에 대한 이야기니까.</p>
<p>하지만 내내 이 작품에서 운명론적인 장치가 들어 있었다면 더욱 마음 졸이며 봤을까. 안옥윤이 고민하는 모습이 있었다면 더 안타까웠을까.</p>
<p>영화 전반부 안옥윤의 생모가 강인국에게 “딸에게 죽을 것” 이라는 저주를 퍼붓고 도망치다 죽었다면, 미치꼬 마저도 다른 집에 입양되었다가 강인국을 죽이고 난 뒤에 생부라는 것을 알았다면</p>
<p>……</p>
<p>여성이 더 강인하게 부각되는 현대사회에 오이디푸스의 이야기를 변주했어도 좋았을 거 같다.</p>
<p><a href="https://namu.wiki/w/%EC%98%A4%EC%9D%B4%EB%94%94%ED%91%B8%EC%8A%A4" title="https://namu.wiki/w/%EC%98%A4%EC%9D%B4%EB%94%94%ED%91%B8%EC%8A%A4" target="_blank" rel="external"><strong>오이디푸스 - 나무위키</strong><br>_오이디푸스는 테바이의 라이오스 왕과 이오카스테 왕비 사이에서 아들로 태어났다. 그러나 델포이의 신전에서 오이디푸스에 대하여 ‘아버지를 죽이고 어머니와 동침할 것이다’라는 신탁을 내놓자 이에 기겁한 라이오스 왕은 …_namu.wiki</a><a href="https://namu.wiki/w/%EC%98%A4%EC%9D%B4%EB%94%94%ED%91%B8%EC%8A%A4" target="_blank" rel="external"></a></p>
<h4 id="하지만-재미없었겠지-ㅎㅎ"><a href="#하지만-재미없었겠지-ㅎㅎ" class="headerlink" title="하지만 재미없었겠지..ㅎㅎ"></a>하지만 재미없었겠지..ㅎㅎ</h4><p><img src="/images/1*OtVM62TH8z6RGOnpUIAovA.pn" alt="">막짤은 프로이트.</p>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/d18a1c8584df" target="_blank" rel="external">March 7, 2017</a>.</p>
<p>Exported from <a href="https://medium.com" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://namu.wiki/w/%EC%95%94%EC%82%B4%282015%29&quot; title=&quot;https://namu.wiki/w/%EC%95%94%EC%82%B4(2015)&quot; target=&quot;_blank&quot; rel=&quot;exte
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>ES2015 리팩토링 — 1. 몸풀기</title>
    <link href="http://keen.devpools.kr/2017/03/06/%5B2017-03-06%2017:19:24%5DES2015%20%E1%84%85%E1%85%B5%E1%84%91%E1%85%A2%E1%86%A8%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%86%BC%20%E2%80%94%201.%20%E1%84%86%E1%85%A9%E1%86%B7%E1%84%91%E1%85%AE%E1%86%AF%E1%84%80%E1%85%B5/"/>
    <id>http://keen.devpools.kr/2017/03/06/[2017-03-06 17:19:24]ES2015 리팩토링 — 1. 몸풀기/</id>
    <published>2017-03-06T08:19:24.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES2015는 프론트엔드 개발자들에게 많은 화두를 던졌고 아주 진지하게 자바스크립트(JavaScript)가 세상을 집어삼킬 거라는 포부를 던지고 있다. 가지고 있던 언어적인 난해함을 벗어던지고 더 많은 개발자들이 좀 더 손쉽게 Java와 C 처럼 개발할 수 있도록 많은 개념들을 제시했다. 여타 다른 객체언어처럼 클래스(class)를 도입하고 화살(arrow)함수를 도입한게 그 좋은 예라고 볼 수 있을 것이다.</p>
<p>지금부터 시작하는 시리즈는 ES2015가 가고자 하는 방향에 맞춰 예전에 만들었던 많은 프로젝트들을 리팩토링 해 볼 것이다. 순서는 아마도 다음과 같이 진행이 될 것이다. (중간에 순서와 목차는 바뀔 수 있다)</p>
<ol>
<li>몸풀기</li>
<li>빠레꽁(var let const)</li>
<li>함수와 모듈화가 JavaScript에 당췌 왜 필요할까</li>
<li>Promise 혹은 Async. 그래도 콜백지옥은 피할 수 없어</li>
<li>JavaScript로 바라보는 함수형 프로그래밍의 미래</li>
<li>이터레이터를 어떻게 쓸까</li>
<li>타입스크립트 도입은 바람직할까</li>
</ol>
<h3 id="몸풀기"><a href="#몸풀기" class="headerlink" title="몸풀기"></a>몸풀기</h3><p>시작하기 전에ES2015를 지금 당장 시작할 수 있을까 하는 생각을 하고 있는 사람이 있을텐데 지금은 어느덧 2017년. 이미 스펙은 오래전부터 안정화 되어 있다.</p>
<p><img src="/images/0*dAMrpjCihyvWaPHG.jpg" alt=""></p>
<p>링크 : <a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external">https://kangax.github.io/compat-table/es6/</a></p>
<h4 id="트랜스파일러를-선택하자-꼬오오오오옥이요"><a href="#트랜스파일러를-선택하자-꼬오오오오옥이요" class="headerlink" title="트랜스파일러를 선택하자. 꼬오오오오옥이요."></a>트랜스파일러를 선택하자. 꼬오오오오옥이요.</h4><p>위의 사이트 통계에 따르면 사파리는 100%, Edge14는 93%, chrome은 97%, FireFox는 94% 정도의 compatibility를 보장하고 있으니 최신 브라우저를 사용한다고 하면 대부분은 그냥 쓸 수 있다고 보면 될 것으로 보인다. 그럼에도 불구하고 ES2015를 쓰려고 하면 필자가 세가지 정도 이유에서 아직은 babel 같은 transpiler를 써야하는데 첫번째는 가장 중요한 것으로 보이는 모듈화에 대한 스펙이 ES2015에는 올라왔지만 번들링이슈를 포함한 개발환경과 브라우저에 동작하는 것이 다른 부분에 대한 어려움 때문이고 두번째는 아직 Internet Explorer를 많이 쓰고 있는 한국 환경이 걸림돌이고 마지막으로는 성능이슈이다.</p>
<p>첫번째 이야기 모듈에 대한 이야기는 좀 복잡한데 간단하게 설명하자면 ES2015 개발 환경이라면 아래 처럼 코드는 사용될 것이다</p>
<p>import somemodule from ‘ModuleFile’</p>
<p>이런 식이라면 아래 그림처럼 상대 경로를 통해 해당 함수에 대한 로딩이 이루어져하는데 현재 번들링하는 관점에서는 비효율적으로 동작할 것이다.</p>
<p><img src="/images/0*Vkmolk-_a4uhpikC.png" alt=""></p>
<p>Button 액션을 담당하는 파일을 로딩해서 그 함수를 사용하게 되는 것이지만 일반적으로 작성하는 HTML을 생각해 보면 보통 JavaScript를 저렇게 로딩하고 있지 않고 아래처럼 script 태그를 이용해서 로딩을 시도하게 된다.</p>
<script src="someScript.js" \="">

<p>이렇게 소스코드를 만들 때에는 보통 번들링이라는 형태로 여러파일들을 하나로 묶거나 (unify) 줄이는 ( uglify)를 하게 되는데 이런 과정을 거치는 이유는 js 파일을 다운로드 받는 속도의 문제와 보안문제 때문이다.</p>
<p>또 한꺼번에 js 파일들을 모두 로딩하는 것이 비효율적이라는 생각을 가지고 AMD 스펙같은데에서는 다이나믹 로딩을 사용하고 있다. 마침 dynamic import 에 대한 spec 또한 tc39의 3단계까지 올라가 있다</p>
<p><a href="https://github.com/tc39/proposal-dynamic-import" title="https://github.com/tc39/proposal-dynamic-import"><strong>tc39/proposal-dynamic-import</strong><br>_proposal-dynamic-import - import() proposal for JavaScript_github.com</a><a href="https://github.com/tc39/proposal-dynamic-import"></a></p>
<p>아무래도 이게 정해지고 나면 import 에 대한 브라우저들의 지원이 확실해 질 듯하고 아마 모듈 로딩에 대해서도 코드 표준들이 바뀔 수 있을 것으로 보인다.</p>
<p>두번째 이유는 더이상 자세한 설명은 생략한다</p>
<p>세번째는 ES2015의 Iterator라던지 변수 scope등은 이전까지 JavaScript에 대해 잘 알지 못하던 사람들이 실수하던 코드를 다른 언어처럼 짤 수 있게 한 부분이 많아서 왠만한 개발자들이 짜던 것보다 코드 품질이 좋게 변환을 해 준다.</p>
<p><a href="http://sculove.github.io/blog/2016/07/26/Babel-%EB%84%88-%EB%AF%BF%EC%9D%84%EC%88%98-%EC%9E%88%EB%8B%88/" title="http://sculove.github.io/blog/2016/07/26/Babel-%EB%84%88-%EB%AF%BF%EC%9D%84%EC%88%98-%EC%9E%88%EB%8B%88/"><strong>Babel 너 믿을수 있니?</strong><br>_누군가나 내 코드를 임의로 바꾼다는 것은 개발자에게는 결코 유쾌한 일이 아닙니다. 더군다나, 사람이 아닌, 기계가 자동적으로 바꾼다는 것은 더욱더 신뢰할 수 없는 일이죠. 하지만, 요즘은 많이 바뀐 것 같습니다…._sculove.github.io</a><a href="http://sculove.github.io/blog/2016/07/26/Babel-%EB%84%88-%EB%AF%BF%EC%9D%84%EC%88%98-%EC%9E%88%EB%8B%88/"></a></p>
<p>관련 블로그를 링크를 걸었는데 중요한 문단은 다음과 같다.</p>
<blockquote>
<p>“한마디로 정리한다면… 안타깝지만, Babel 은 저 보다 코드를 더 잘짰습니다. ㅠㅠ”</p>
</blockquote>
<h4 id="그럼-어떤-트랜스파일러를-사용할-것인가"><a href="#그럼-어떤-트랜스파일러를-사용할-것인가" class="headerlink" title="그럼 어떤 트랜스파일러를 사용할 것인가"></a>그럼 어떤 트랜스파일러를 사용할 것인가</h4><p>어떤 프레임워크를 사용하는가에 따라서 트랜스파일러도 보통은 선택되는 상황이지만 크게 babel과 traceur 로 양분이 되는데 작년 기준이기는 하지만 거의 babel의 압승으로 끝나는 듯한 모습이다.</p>
<p>타입스크립트의 경우는 약간 다른 경우니까 나중에 다뤄보도록 하겠다.</p>
<h4 id="Linter를-사용할-것"><a href="#Linter를-사용할-것" class="headerlink" title="Linter를 사용할 것"></a>Linter를 사용할 것</h4><p>Linting이라고 하는 것은 기본적으로 버그가 날 수 있는 코드를 표시를 해주는 툴로써 이바닥의 요다인 Douglas 옹이 JSLint를 만들고 가장 많이 사용되는 툴은 ESLint 툴이다. 많은 에디터가 ESLint 플러그인을 제공하고 있으므로 꼭 설치하고 시작하는 것이 좋다.</p>
<p>Webstrom 관련된 내용은 기존의 아티클을 읽어보기를 추천한다.</p>
<p><img src="/images/0*5KuYlcm5RjfeXUji.jp" alt=""></p>
<h4 id="스타일-가이드를-활용하자"><a href="#스타일-가이드를-활용하자" class="headerlink" title="스타일 가이드를 활용하자"></a>스타일 가이드를 활용하자</h4><p>JavaScript 관련해서 좋은 회사의 스타일 가이드들을 활용하는 것은 매우 추천할 만한 일이다. JavaScript관련해서 가장 핫한 스타일 가이드 중 하나는 airbnb의 스타일 가이드이고 이후 이어지는 글들은 상당히 많이 참조할 것이다.</p>
<p><a href="https://github.com/airbnb/javascript" title="https://github.com/airbnb/javascript"><strong>airbnb/javascript</strong><br>_javascript - JavaScript Style Guide_github.com</a><a href="https://github.com/airbnb/javascript"></a></p>
<h4 id="기존-프로젝트를-재활용"><a href="#기존-프로젝트를-재활용" class="headerlink" title="기존 프로젝트를 재활용"></a>기존 프로젝트를 재활용</h4><p>아무래도 이런 리팩토링은 legacy 프로젝트가 있어야 한다. 기존에 만들었던 서버리스 아키텍처 관련 프로젝트를 legacy로 리팩토링 해 보도록 하겠다.</p>
<p><a href="https://github.com/ehrudxo/standup" title="https://github.com/ehrudxo/standup"><strong>ehrudxo/standup</strong><br>_standup project for newbi_github.com</a><a href="https://github.com/ehrudxo/standup"></a></p>
<hr>
<p><em>Originally published at </em><a href="http://devpools.kr/2017/03/06/es2015%eb%a6%ac%ed%8c%a9%ed%86%a0%eb%a7%811%eb%aa%b8%ed%92%80%ea%b8%b0/"><em>개발바보들</em></a><em>.</em></p>
<p>By <a href="https://medium.com/@keendev">Keen Dev</a> on <a href="https://medium.com/p/39fb2c66b023">March 6, 2017</a>.</p>
<p>Exported from <a href="https://medium.com">Medium</a> on May 31, 2017.</p>
</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2015는 프론트엔드 개발자들에게 많은 화두를 던졌고 아주 진지하게 자바스크립트(JavaScript)가 세상을 집어삼킬 거라는 포부를 던지고 있다. 가지고 있던 언어적인 난해함을 벗어던지고 더 많은 개발자들이 좀 더 손쉽게 Java와 C 처럼
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>ES2015 리팩토링 – 1. 몸풀기</title>
    <link href="http://keen.devpools.kr/2017/03/06/refactoring01/"/>
    <id>http://keen.devpools.kr/2017/03/06/refactoring01/</id>
    <published>2017-03-06T06:54:57.000Z</published>
    <updated>2017-08-06T07:23:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES2015는 프론트엔드 개발자들에게 많은 화두를 던졌고 아주 진지하게 자바스크립트(JavaScript)가 세상을 집어삼킬 거라는 포부를 던지고 있다. 가지고 있던 언어적인 난해함을 벗어던지고 더 많은 개발자들이 좀 더 손쉽게 Java와 C 처럼 개발할 수 있도록 많은 개념들을 제시했다. 여타 다른 객체언어처럼 클래스(class)를 도입하고 화살(arrow)함수를 도입한게 그 좋은 예라고 볼 수 있을 것이다.</p>
<p>지금부터 시작하는 시리즈는  ES2015가 가고자 하는 방향에 맞춰 예전에 만들었던 많은 프로젝트들을 리팩토링 해 볼 것이다. 순서는 아마도 다음과 같이 진행이 될 것이다. (중간에 순서와 목차는 바뀔 수 있다)</p>
<ol>
<li>몸풀기</li>
<li>빠레꽁(var let const)</li>
<li>함수와 모듈화가 JavaScript에 당췌 왜 필요할까</li>
<li>Promise 혹은 Async. 그래도 콜백지옥은 피할 수 없어</li>
<li>JavaScript로 바라보는 함수형 프로그래밍의 미래</li>
<li>이터레이터를 어떻게 쓸까</li>
<li>타입스크립트 도입은 바람직할까</li>
</ol>
<p>시작하기 전에ES2015를 지금 당장 시작할 수 있을까 하는 생각을 하고 있는 사람이 있을텐데 지금은 어느덧 2017년. 이미 스펙은 오래전부터 안정화 되어 있다.</p>
<p><img src="/images/es6_table.jpg" alt="ES6 호환성 테이블"></p>
<h2 id="트랜스파일러를-선택하자-꼬오오오오옥이요"><a href="#트랜스파일러를-선택하자-꼬오오오오옥이요" class="headerlink" title="트랜스파일러를 선택하자. 꼬오오오오옥이요."></a>트랜스파일러를 선택하자. <del>꼬오오오오옥이요.</del></h2><p>위의 사이트 통계에 따르면 사파리는 100%, Edge14는 93%, chrome은 97%, FireFox는 94% 정도의 compatibility를 보장하고 있으니 최신 브라우저를 사용한다고 하면 대부분은 그냥 쓸 수 있다고 보면 될 것으로 보인다. 그럼에도 불구하고 ES2015를 쓰려고 하면 필자가 세가지 정도 이유에서 아직은 babel 같은 transpiler를 써야하는데 첫번째는 가장 중요한 것으로 보이는 모듈화에 대한 스펙이 ES2015에는 올라왔지만 번들링이슈를 포함한 개발환경과 브라우저에 동작하는 것이 다른 부분에 대한 어려움 때문이고 두번째는 아직 Internet Explorer를 많이 쓰고 있는 한국 환경이 걸림돌이고 마지막으로는 성능이슈이다.</p>
<p>첫번째 이야기 모듈에 대한 이야기는 좀 복잡한데 간단하게 설명하자면 ES2015 개발 환경이라면 아래 처럼 코드는 사용될 것이다</p>
<p>import somemodule from ‘ModuleFile’</p>
<p>이런 식이라면 아래 그림처럼 상대 경로를 통해 해당 함수에 대한 로딩이 이루어져하는데 현재 번들링하는 관점에서는 비효율적으로 동작할 것이다.</p>
<p><img src="/images/importing.png" alt="import 구문"></p>
<p>Button 액션을 담당하는 파일을 로딩해서 그 함수를 사용하게 되는 것이지만 일반적으로 작성하는  HTML을 생각해 보면 보통 JavaScript를 저렇게 로딩하고 있지 않고 아래처럼 script 태그를 이용해서 로딩을 시도하게 된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">”someScript.js”/</span>&gt;</span><span class="undefined"></span></div></pre></td></tr></table></figure>
<p>이렇게 소스코드를 만들 때에는 보통 번들링이라는 형태로 여러파일들을 하나로 묶거나 (unify)  줄이는 ( uglify)를 하게 되는데 이런 과정을 거치는 이유는 js 파일을 다운로드 받는 속도의 문제와 보안문제 때문이다.</p>
<p>또 한꺼번에  js 파일들을 모두 로딩하는 것이 비효율적이라는 생각을 가지고 AMD 스펙같은데에서는 다이나믹 로딩을 사용하고 있다. 마침 dynamic import 에 대한 spec 또한 tc39의 3단계까지 올라가 있다</p>
<p><img src="/images/tc39.jpg" alt="tc39 Stage 3 Draft / February 13, 2017"><br>링크 : <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="external">dynamic import 깃허브 프로젝트</a></p>
<p>아무래도 이게 정해지고 나면 import 에 대한 브라우저들의 지원이 확실해 질 듯하고 아마 모듈 로딩에 대해서도 코드 표준들이 바뀔 수 있을 것으로 보인다.</p>
<p>두번째 이유는 <del>더이상 자세한 설명은 생략한다</del></p>
<p>세번째는 ES2015의 Iterator라던지 변수 scope등은 이전까지 JavaScript에 대해 잘 알지 못하던 사람들이 실수하던 코드를 다른 언어처럼 짤 수 있게 한 부분이 많아서 왠만한 개발자들이 짜던 것보다 코드 품질이 좋게 변환을 해 준다.</p>
<p><img src="/images/babel_trust.jpg" alt="손찬욱 블로그"><br>링크 :<a href="http://sculove.github.io/blog/2016/07/26/Babel-%EB%84%88-%EB%AF%BF%EC%9D%84%EC%88%98-%EC%9E%88%EB%8B%88/" target="_blank" rel="external">Babel 너 믿을수 있니?</a></p>
<p>관련 블로그를 링크를 거는데 중요한 문단은 다음과 같다.</p>
<blockquote>
<p>“한마디로 정리한다면… 안타깝지만, Babel 은 저 보다 코드를 더 잘짰습니다. ㅠㅠ”</p>
</blockquote>
<h2 id="그럼-어떤-트랜스파일러를-사용할-것인가"><a href="#그럼-어떤-트랜스파일러를-사용할-것인가" class="headerlink" title="그럼 어떤 트랜스파일러를 사용할 것인가"></a>그럼 어떤 트랜스파일러를 사용할 것인가</h2><p>어떤 프레임워크를 사용하는가에 따라서 트랜스파일러도 보통은 선택되는 상황이지만 크게 babel과 traceur 로 양분이 되는데 작년 기준이기는 하지만 거의 babel의 압승으로 끝나는 듯한 모습이다.</p>
<p><img src="/images/babel_win.jpg" alt="바벨의 승리"><br>링크 : <a href="https://www.reddit.com/r/javascript/comments/33c9la/which_es6_transpiler/" target="_blank" rel="external">레딧 쓰레드</a></p>
<p>타입스크립트의 경우는 약간 다른 경우니까 나중에 다뤄보도록 하겠다</p>
<h2 id="Linter를-사용할-것"><a href="#Linter를-사용할-것" class="headerlink" title="Linter를 사용할 것"></a>Linter를 사용할 것</h2><p>Linting이라고 하는 것은 기본적으로 버그가 날 수 있는 코드를 표시를 해주는 툴로써 이바닥의 요다인 Douglas 옹이 JSLint를 만들고 가장 많이 사용되는 툴은 ESLint  툴이다. 많은 에디터가 ESLint 플러그인을 제공하고 있으므로 꼭 설치하고 시작하는 것이 좋다.</p>
<p>Webstrom 관련된 내용은 기존의 아티클을 읽어보기를 추천한다.<br><img src="/images/webstorm.jpg" alt="ESLint with WebStorm"></p>
<p>링크 : <a href="http://devpools.kr/2017/02/16/javascript-eslint-webstorm/" target="_blank" rel="external">개발바보들 - ESLint with WebStorm</a></p>
<h2 id="스타일-가이드를-활용하자"><a href="#스타일-가이드를-활용하자" class="headerlink" title="스타일 가이드를 활용하자"></a>스타일 가이드를 활용하자</h2><p>JavaScript 관련해서 좋은 회사의 스타일 가이드들을 활용하는 것은 매우 추천할 만한 일이다. JavaScript관련해서 가장 핫한 스타일 가이드 중 하나는 airbnb의 스타일 가이드이고 이후 이어지는 글들은 상당히 많이 참조할 것이다.</p>
<p><img src="/images/airbnbstyle.jpg" alt="airbnb 스타일 가이드"><br>링크 : <a href="https://github.com/airbnb/javascript" target="_blank" rel="external">스타일 가이드 깃허브 소스</a></p>
<h2 id="기존-프로젝트를-재활용"><a href="#기존-프로젝트를-재활용" class="headerlink" title="기존 프로젝트를 재활용"></a>기존 프로젝트를 재활용</h2><p>아무래도 이런 리팩토링은 legacy 프로젝트가 있어야 한다. 기존에 만들었던 서버리스 아키텍처 관련 프로젝트를 legacy로 리팩토링 해 보도록 하겠다.</p>
<p><img src="/images/standup.jpg" alt="standup 프로젝트"></p>
<p>링크 : <a href="https://github.com/ehrudxo/standup" target="_blank" rel="external">standup 깃허브 소스</a><br>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2015는 프론트엔드 개발자들에게 많은 화두를 던졌고 아주 진지하게 자바스크립트(JavaScript)가 세상을 집어삼킬 거라는 포부를 던지고 있다. 가지고 있던 언어적인 난해함을 벗어던지고 더 많은 개발자들이 좀 더 손쉽게 Java와 C 처럼
    
    </summary>
    
    
      <category term="JavaScript, Refactoring" scheme="http://keen.devpools.kr/tags/JavaScript-Refactoring/"/>
    
  </entry>
  
  <entry>
    <title>개발자들의 인문학 이야기</title>
    <link href="http://keen.devpools.kr/2017/03/06/%5B2017-03-06%2008:33:39%5D%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%8C%E1%85%A1%E1%84%83%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%86%E1%85%AE%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%20%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A3%E1%84%80%E1%85%B5/"/>
    <id>http://keen.devpools.kr/2017/03/06/[2017-03-06 08:33:39]개발자들의 인문학 이야기/</id>
    <published>2017-03-05T23:33:39.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>사람들이랑 시작해 보려고 한번 장소를 마련해 봤습니다.</p>
<p><img src="/images/1*hELtmVbDlk5hPE_O7QjN8A.jpe" alt=""></p>
<p>인문의 바다에서 한번 우리 헤엄쳐 봅시다.</p>
<p>일단은 지대넓얕 요약으로 시작하지만 점점 시야를 확장해 보면 언젠가는 거인이 되어 있으리라 서로 믿어봅시다.</p>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/6ca84ccc5ebb" target="_blank" rel="external">March 5, 2017</a>.</p>
<p>Exported from <a href="https://medium.com" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;사람들이랑 시작해 보려고 한번 장소를 마련해 봤습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/1*hELtmVbDlk5hPE_O7QjN8A.jpe&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;인문의 바다에서 한번 우리 헤엄쳐 봅시다.&lt;/p&gt;
&lt;p&gt;일단은 지
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
  <entry>
    <title>ESLint with WebStorm</title>
    <link href="http://keen.devpools.kr/2017/03/05/%5B2017-03-05%2015:10:19%5DESLint%20with%20WebStorm/"/>
    <id>http://keen.devpools.kr/2017/03/05/[2017-03-05 15:10:19]ESLint with WebStorm/</id>
    <published>2017-03-05T06:10:19.000Z</published>
    <updated>2017-09-04T09:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>원본 투고 글 : <a href="http://devpools.kr/2017/02/16/javascript-eslint-webstorm/" target="_blank" rel="external">http://devpools.kr/2017/02/16/javascript-eslint-webstorm/</a></p>
<p>IntelliJ 의 웹 버전인 WebStorm을 사용할 때 ESLint를 사용하는 방법을 알아보겠습니다. 프로젝트에도 적용할 수 있겠지만 에디터에서 자동으로 문제가 있는 (혹은 버그를 생산하는) 코드를 미리 찾아 볼 수 있습니다.</p>
<h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>“Linting”이라는 행위는 버그가 날 수 있을 만한 코드를 찾아서 체크를 해 주는일을 의미합니다.</p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Computer_programming" title="Computer programming" target="_blank" rel="external">computer programming</a>, <strong>lint</strong> is a Unix utility that flags some <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29#Language_tools" title="C (programming language)" target="_blank" rel="external">suspicious and non-portable constructs</a> (likely to be bugs) in <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29" title="C (programming language)" target="_blank" rel="external">C language</a><a href="https://en.wikipedia.org/wiki/Source_code" title="Source code" target="_blank" rel="external">source code</a>; generically, lint or a <strong>linter</strong> is any tool that flags suspicious usage in software written in any <a href="https://en.wikipedia.org/wiki/Computer_language" title="Computer language" target="_blank" rel="external">computer language</a>. The term <strong>lint-like behavior</strong> is sometimes applied to the process of flagging suspicious language usage. Lint-like tools generally perform <a href="https://en.wikipedia.org/wiki/Static_code_analysis" title="Static code analysis" target="_blank" rel="external">static analysis</a> of source code. — 위키피디아 <a href="https://en.wikipedia.org/wiki/Lint_%28software%29" target="_blank" rel="external">Lint</a></p>
</blockquote>
<p>JavaScript 에서 이 Lint라는 의미를 처음 얘기한 사람은 Douglas crockford 였고 그는 JsLint라는 툴을 만들어 냅니다. JavaScript Definite Guide 같은 책에서도 내용을 언급하고 있습니다.</p>
<p><a href="http://www.jslint.com/" title="http://www.jslint.com/" target="_blank" rel="external"><strong>JSLint: The JavaScript Code Quality Tool</strong><br>_JSLint, The JavaScript Code Quality Tool. This file allows JSLint to be run from a web browser. It can accept a source…_www.jslint.com</a><a href="http://www.jslint.com/" target="_blank" rel="external"></a></p>
<p>하지만 최근의 대부분의 JavaScript 커뮤니티에서 사용하는 Lint 툴은 ESLint 툴입니다.</p>
<p>Nicholas Jakas에 의해 2013년에 나온 이 툴은 현재 여러 툴들에서 플러그인으로 사용되고 있습니다.</p>
<p><a href="http://eslint.org/" title="http://eslint.org/" target="_blank" rel="external"><strong>ESLint - Pluggable JavaScript linter</strong><br>_A pluggable and configurable linter tool for identifying and reporting on patterns in JavaScript. Maintain your code…_eslint.org</a><a href="http://eslint.org/" target="_blank" rel="external"></a></p>
<p>“JSX” 지원하는 것에 대해서 언급이 첫페이지에 있습니다. React 와 JSX는 다르다고 하는군요. 아무래도 Pluggable한 아키텍처로 이루어져 있기에 오리지날인 JSLint에 비해 많이 쓰이는 거라고 보여집니다.</p>
<h3 id="webstorm"><a href="#webstorm" class="headerlink" title="webstorm"></a>webstorm</h3><p>웹스톰은 IntelliJ를 만든 Jetbrains에서 만든 웹 개발자용 IDE 입니다. 이클립스가 약간은 범용에 가깝다고 하면 이 웹 스톰은 JavaScript 최근 트렌드 및 개발 환경에 대한 이해가 큰 IDE 입니다. Node 모듈에 대한 이해도 가지고 있고 npm 을 기본적으로 작동시킬 수 있습니다. 유료 IDE기는 하지만 IntelliJ에 적응된 개발자들은 이webstorm의 여러가지 기능에 대해서 많이 만족하고 쓰고 있습니다. 최근 팝잇에 올라온 IntelliJ에 관한 글을 읽어보면 많은 인사이트들을 얻을 수 있습니다.</p>
<p><a href="http://www.popit.kr/%EC%9D%B8%ED%85%94%EB%A6%ACj-%ED%99%9C%EC%9A%A9-%EA%BF%80%ED%8C%81-42%EA%B0%80%EC%A7%80-%EC%A0%95%EB%A6%AC/" title="http://www.popit.kr/%EC%9D%B8%ED%85%94%EB%A6%ACj-%ED%99%9C%EC%9A%A9-%EA%BF%80%ED%8C%81-42%EA%B0%80%EC%A7%80-%EC%A0%95%EB%A6%AC/" target="_blank" rel="external"><strong>인텔리J 활용 꿀팁 42가지 정리 | Popit</strong><br>_인텔리J가 유료 IDE이다 보니 사용하면서 기능들을 최대한 활용하지 않는다면 손해라는 생각이 들었습니다. 그래서 인터넷을 찾아보다 발견한 인텔리J 42가지 팁 소개 동영상를 보고 정리한 글입니다. 해당 동영상은 …_www.popit.kr</a><a href="http://www.popit.kr/%EC%9D%B8%ED%85%94%EB%A6%ACj-%ED%99%9C%EC%9A%A9-%EA%BF%80%ED%8C%81-42%EA%B0%80%EC%A7%80-%EC%A0%95%EB%A6%AC/" target="_blank" rel="external"></a></p>
<h3 id="WebStrom-ESLint"><a href="#WebStrom-ESLint" class="headerlink" title="WebStrom + ESLint"></a>WebStrom + ESLint</h3><p>이 WebStorm에서 ESLint를 설정하는 방법은 다음과 같습니다.</p>
<p>preference -> Languges &amp; Framework -> ESLint</p>
<p><img src="/images/0*qBlmLC3cTz8oJ-Jf." alt=""></p>
<p>두가지를 셋팅해 주셔야 하는데 하나는 Node 를 지정하는 것이고 또 다른 하나는 ESLint 폴더를 지정해 주는 것입니다. Node 는 각자의 환경을 정하면 될 것입니다.</p>
<p>ESLint 폴더를 지정할 때는</p>
<pre><code>$ npm list -g|more
</code></pre><p>옵션을 통해서 어디에 설치를 했는지 확인해 주시면 됩니다.</p>
<p>확인이 되셨으면</p>
<pre><code>`$ npm install -g eslint`
</code></pre><p><a href="https://github.com/eslint/eslint" title="https://github.com/eslint/eslint" target="_blank" rel="external"><strong>eslint/eslint</strong><br>_eslint - A fully pluggable tool for identifying and reporting on patterns in JavaScript._github.com</a><a href="https://github.com/eslint/eslint" target="_blank" rel="external"></a></p>
<p>이후 몇가지 모듈을 더 설치해야 합니다.</p>
<pre><code>$npm install eslint-plugin-react eslint-plugin-jsx-a11y eslint-plugin-import -g
</code></pre><p>실행해 주고 나서 WebStorm을 다시 작동시키면 아래와 같은 좋은 예를 볼 수 있습니다.</p>
<p><img src="/images/0*IJ_x1kEFxnkgv5PQ" alt=""></p>
<p>By <a href="https://medium.com/@keendev" target="_blank" rel="external">Keen Dev</a> on <a href="https://medium.com/p/bf9d418993b2" target="_blank" rel="external">March 5, 2017</a>.</p>
<p>Exported from <a href="https://medium.com" target="_blank" rel="external">Medium</a> on May 31, 2017.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;원본 투고 글 : &lt;a href=&quot;http://devpools.kr/2017/02/16/javascript-eslint-webstorm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://devpools.kr/2017/02/1
    
    </summary>
    
    
      <category term="github, github-trend, tech-trend" scheme="http://keen.devpools.kr/tags/github-github-trend-tech-trend/"/>
    
  </entry>
  
</feed>
